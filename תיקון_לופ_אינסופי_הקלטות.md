# תיקון בעיית תור הקלטות תקוע - מניעת לופים אינסופיים בממשק

## הבעיה שזוהתה

על פי תיאור הבעיה:
- תור עבודות תקוע
- השרת מחזיר סטטוסים לא נכונים (404, 502)
- הממשק נכנס ללופים אינסופיים
- כל בקשה ל־`/api/recordings/file/` נתקעת

## ניתוח שורש הבעיה

הבעיה התרחשה כאשר:
1. **עבודת הקלטה נתקעת** בתור (הסטטוס נשאר 'queued' או 'running' לנצח)
2. **הממשק שולח בקשות חוזרות** דרך AudioPlayer שמנסה עד 12 פעמים עם backoff
3. **השרת תמיד מחזיר 202 Accepted** כאשר עבודה קיימת ב־DB, גם אם היא תקועה
4. **הממשק נכנס ללופ אינסופי** כי 202 אומר לו "נסה שוב מאוחר יותר"

## הפתרון שיושם

### 1. זיהוי אוטומטי של עבודות תקועות

הוספנו קוד שבודק אם עבודה נתקעה (נמצאת בסטטוס 'queued' או 'running' יותר מ־5 דקות).

### 2. סימון עבודות תקועות כנכשלות

כאשר עבודה מזוהה כתקועה:
- הסטטוס משתנה ל־'failed'
- מתווסף הודעת שגיאה ברורה עם הסטטוס המקורי
- מתועד timestamp של סיום

### 3. יצירת עבודה חדשה אוטומטית

לאחר סימון העבודה התקועה כנכשלה, השרת יוצר אוטומטית עבודה חדשה להורדת ההקלטה.

### 4. החזרת תגובה נכונה לממשק

במקום 202 אינסופי:
- אם נוצרה עבודה חדשה בהצלחה → 202 עם Retry-After: 3
- אם נכשלה יצירת עבודה חדשה → 500 עם הודעת שגיאה ברורה

## הקבצים שהשתנו

### `server/routes_recordings.py`

1. **קבוע JOB_TIMEOUT_MINUTES** (5 דקות)
   - עבודות שנתקעו יותר זמן נחשבות כנכשלות

2. **פונקציה cleanup_stuck_recording_jobs()**
   - מוצאת עבודות בסטטוס 'queued'/'running' ישנות מ־5 דקות
   - מסמנת אותן כ־'failed'
   - ניתן לקרוא לה תקופתית או לפי דרישה

3. **פונקציה handle_stuck_job_and_retry()** ✨ חדש
   - מונעת שכפול קוד בין endpoints
   - מזהה אם עבודה תקועה
   - מסמנת עבודה תקועה כנכשלה
   - יוצרת עבודה חדשה אוטומטית
   - מחזירה תגובה נכונה (202 או 500)

4. **שיפור endpoint של serve_recording_file**
   - משתמש בפונקציית העזר
   - מזהה עבודות תקועות ומתאושש אוטומטית
   - מחזיר 202 עם עבודה חדשה או 500 אם נכשל

5. **שיפור endpoint של prepare_recording**
   - משתמש בפונקציית העזר
   - אותו לוגיקה של זיהוי והתאוששות

### `test_stuck_recording_job_fix.py`

- נוצרה חבילת בדיקות מקיפה
- תוקנו imports מיותרים

## איך זה פותר את הבעיה

### לפני:
```
עבודה נתקעת → השרת מחזיר 202 לנצח → הממשק בלופ אינסופי
```

### אחרי:
```
עבודה נתקעת (>5 דק') → השרת מזהה → מסמן כנכשל → יוצר עבודה חדשה → הממשק מקבל הורדה חדשה
```

## בדיקות אבטחה

✅ **CodeQL scan עבר בהצלחה** - 0 התראות אבטחה

## יתרונות

✅ **אין יותר לופים אינסופיים** - עבודות תקועות מזוהות אחרי 5 דקות
✅ **התאוששות אוטומטית** - עבודות חדשות נוצרות כאשר הישנות נכשלות
✅ **דיווח שגיאות טוב יותר** - הודעות ברורות עם סטטוס מקורי נכון
✅ **ידידותי למשתמש** - הממשק מקבל עבודה עובדת במקום תקועה
✅ **מונע שגיאות 502** - עבודות חדשות מחליפות תקועות
✅ **קוד ניתן לתחזוקה** - פונקציית עזר אחת, אין כפילות
✅ **מאובטח** - 0 פגיעויות אבטחה זוהו

## המלצות לבדיקה

### 1. סימולציה של עבודה תקועה
```python
# צור RecordingRun עם created_at ישן
stuck_job = RecordingRun(
    business_id=1,
    call_sid='CAtest123',
    status='queued',
    created_at=datetime.utcnow() - timedelta(minutes=10)
)
# בקש /api/recordings/file/CAtest123
# וודא שהעבודה מסומנת כנכשלת ונוצרת חדשה
```

### 2. ווידוא שהממשק לא נכנס ללופ
1. נגן הקלטה עם עבודה תקועה
2. אשר שהממשק בסופו של דבר מקבל עבודה חדשה ומצליח

### 3. בדיקת פונקציית הניקוי
```python
cleanup_stuck_recording_jobs()
# וודא שעבודות תקועות ישנות מסומנות כנכשלות
```

## מוכן לפרודקשן ✅

כל הדרישות מתקיימות:
- [x] הקוד נכתב ונבדק
- [x] Code review בוצע וכל המשוב טופל
- [x] סריקת אבטחה עברה (0 התראות)
- [ ] מומלץ לבצע בדיקה ידנית

## סיכום טכני

השינוי מוסיף מנגנון זיהוי והתאוששות אוטומטי לעבודות הקלטה תקועות:
- עבודות שנמצאות בסטטוס 'queued' או 'running' יותר מ־5 דקות מסומנות אוטומטית כ־'failed'
- השרת יוצר עבודה חדשה כדי לנסות שוב
- הממשק מקבל תגובה תקינה (202 עם עבודה חדשה או 500) במקום לופ אינסופי

זה פותר את הבעיה המקורית של תור עבודות תקוע שגרם לממשק להיכנס ללופים אינסופיים.
