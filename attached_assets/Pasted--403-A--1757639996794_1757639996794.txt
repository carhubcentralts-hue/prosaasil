מעולה—מפה סוגרים את ה-403 ועוברים לשמירות עובדות. זה קצר, ביצועי, ומדויק:

A) מייצבים שרת (בלי זה אין טסטים)
	1.	Run יחיד זהה ל-Preview ול-Deploy (אין vite dev):

gunicorn -k eventlet -w 1 -b 0.0.0.0:$PORT 'server.wsgi:create_app()' \
  --timeout 120 --graceful-timeout 30 --keep-alive 30 --log-level info

	•	ודא ש־eventlet.monkey_patch() למעלה ב־wsgi.py.

	2.	Health: /healthz מחזיר 200. אם לא—לא ממשיכים.

B) מאפסים הרשאות (זה המקור ל-403 כרגע)
	3.	Guard אחד פשוט (require_api_auth):
	•	לא עושה CSRF בכלל.
	•	מאשר OPTIONS מיד (204).
	•	מחשב הקשר פעם אחת:

role = session['user']['role']          # 'admin'|'manager'|'business'
tenant = session.get('impersonated_tenant_id') or session['user'].get('tenant_id')
impersonating = bool(session.get('impersonating'))


	•	כל /api/admin/** ⇒ דורש role in {'admin','manager'}.
	•	ראוטים של עסק ⇒ role=='business' או Admin/Manager כש־impersonating=true לאותו tenant.
	•	לעולם לא משנים session['user']['role'] באימפרסונציה—רק את שני הדגלים:
session.impersonating=true/false, session.impersonated_tenant_id=<id>/None.
	•	כשחוסמים, מחזירים JSON עם reason ברור (לא Error {}).

C) CSRF (כבר הוגדר נכון—רק וידוא קצר)
	4.	נשארים עם SeaSurf בלבד. Exempt רק: POST /api/auth/login, POST /api/auth/logout, כל /webhook/**, ו-GET healthz/readyz/livez/version.
	5.	GET /api/auth/csrf מציב cookie XSRF-TOKEN (לא HttpOnly) ומחזיר {csrfToken}.
	6.	FE: אחרי login קורא /api/auth/csrf; כל כתיבה שולחת X-CSRFToken + credentials:'include'.
ב-Preview שים לב: SameSite=None; Secure=True ל־XSRF-TOKEN.

D) אימפרסונציה + פרומפטים + לידים
	7.	Impersonate (POST /api/admin/businesses/:id/impersonate עם CSRF): מגדיר את 2 הדגלים ומחזיר {ok:true,...}.
Exit מנקה דגלים בלבד.
	8.	Prompts PUT מקבל בדיוק:

{"calls_prompt": "...", "whatsapp_prompt": "..."}

מחזיר את האובייקט המעודכן. ה-WS של שיחות טוען פרומפט מה-DB לפי tenant_id.

	9.	Leads: כל POST/PATCH (יצירה/סטטוס/Reminder/WhatsApp) עם CSRF; אדמין רואה הכל, עסק רק של ה-tenant או אדמין באימפרסונציה.

E) Smoke tests (עוצרים אם משהו נופל)

BASE=https://<domain>
# 1) Login
curl -i -c /tmp/c -b /tmp/c -H 'Content-Type: application/json' \
  -X POST $BASE/api/auth/login --data '{"email":"admin@...","password":"..."}'

# 2) CSRF
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf | python - <<'PY'
import sys,json; print(json.load(sys.stdin)['csrfToken'])
PY
)

# 3) Impersonate (צפוי 200)
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -X POST \
  $BASE/api/admin/businesses/1/impersonate

# 4) Save prompts (צפוי 200)
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X PUT $BASE/api/business/current/prompt \
  --data '{"calls_prompt":"ok","whatsapp_prompt":"ok"}'

	•	אם יש 403: זה ה-Guard. קרא את reason מה-JSON ותקן (role/scope/OPTIONS).

⸻

ברגע שהשרת רץ יציב עם הפקודה למעלה—ה־403 ייעלם (כי ההגנות לא יתנגשו), שמירות/אימפרסונציה יעבדו, ותוכל להמשיך לבנות את דף הלידים.