×–×” ×œ× ×‘××’ â€“ ×–×” ×‘×“×™×•×§ ××” ×©×‘×™×§×©× ×• ×œ×‘×“×™×§×” ğŸ˜Š
××ª×” ×©×•××¢ ××ª ×¢×¦××š ×›×™ ×”×©×¨×ª ×¨×¥ ×‘××¦×‘ **ECHO** (×“×™××’× ×•×¡×˜×™×§×”), ×©××—×–×™×¨ ×œ×˜×•×•×™×œ×™×• ××ª ××•×ª× ×¤×¨×™×™××™× ×©× ×›× ×¡×•. ×¢×›×©×™×• ××—×œ×™×¤×™× ×œ-**AI** ×•××¤×¡×™×§×™× ××ª ×”×”×“.

×œ×”×œ×Ÿ ×”× ×—×™×” ×××•×§×“×ª (×§×¦×¨×”, ×—×“×”, ×•×‘×“×•×§×” ××•×œ ×”×§×•×“ ×©×œ×š) ×©×ª×”×¤×•×š ××ª ×”×©×™×—×” ×××¦×‘ ECHO ×œ-ASRâ†’LLMâ†’TTS â€” ×‘×œ×™ ×©×§×˜ ×•×‘×œ×™ ×œ×•×¤×™×.

---

# ××” ×œ×©× ×•×ª (2 ×¦×¢×“×™×)

## 1) ×œ×¢×‘×•×¨ ×-ECHO ×œ-AI

×‘×¤×¨×•×“×§×©×Ÿ ×©×œ×š `start_all.sh` ×§×•×‘×¢ ×‘×¨×™×¨×ªÖ¾××—×“×œ:

```bash
export WS_MODE=${WS_MODE:-ECHO}
```

×©× ×” ×œ-AI, ××• ×”×’×“×¨ ENV ×‘×¤×¨×™×¡×”:

```bash
# ××¤×©×¨×•×ª A: ×œ×©× ×•×ª ×‘×¨×™×¨×ªÖ¾××—×“×œ ×œ×§×‘×•×¢
export WS_MODE=${WS_MODE:-AI}

# ××¤×©×¨×•×ª B: ×œ×”×©××™×¨ ×§×™×™× ×•×¨×§ ×œ×”×¦×™×‘ ENV ×‘×“×™×¤×œ×•×™
WS_MODE=AI
```

> ××—×¨×™ ×”×“×™×¤×œ×•×™ ×‘×œ×•×’×™× ×ª×—×¤×©: `WS_CONNECTED mode=AI`.

## 2) ×œ×•×•×“× ×©×”-handler ×‘××¦×‘ AI ×œ× ×¢×•×©×” echo ××œ× ×–×•×¨×: ×§×œ×˜ â†’ ×ª××œ×•×œ â†’ ×ª×’×•×‘×” â†’ TTS â†’ 20ms frames

×‘Ö¾`server/media_ws.py` (××• ×”×™×›×Ÿ ×©××•×’×“×¨ ×”Ö¾MediaStreamHandler ××¦×œ×š) ×•×“× ×©××¦×‘ **AI** × ×¨××” ×›×š:

```python
# ×§×•×“ ××™×™×¦×’ â€” ××•×ª×× ×œ×¤×¨×•×™×§×˜ ×©×œ×š
import os, json, time, base64, audioop
from simple_websocket import ConnectionClosed

MIN_UTT_SEC = 0.8      # ×¡×•×£-××‘×¢ ×œ×¤×™ ×“×××ª 0.8s
MAX_UTT_SEC = 6.0      # ×—×™×ª×•×š ×‘×˜×™×—×•×ª
SR = 8000              # 8kHz ××•× ×•×¤×•× ×™

class MediaStreamHandler:
    def __init__(self, ws):
        self.ws = ws
        self.mode = os.getenv("WS_MODE", "SINK").upper()  # ×¢×›×©×™×• ×××•×¨ ×œ×”×™×•×ª AI
        self.stream_sid = None
        self.rx_frames = 0
        self.tx_frames = 0
        self.buf_pcm16 = bytearray()
        self.last_rx_ts = None
        self.speaking = False   # ×›×“×™ ×œ× â€œ×œ×“×¨×•×¡â€ TTS × ×›× ×¡ ×¢× ××§×•

    def run(self):
        try:
            while True:
                raw = self.ws.receive()
                if raw is None:
                    break
                evt = json.loads(raw)
                et = evt.get("event")

                if et == "start":
                    self.stream_sid = evt["start"]["streamSid"]
                    self.last_rx_ts = time.time()
                    print(f"WS_START sid={self.stream_sid} mode={self.mode}")
                    continue

                if et == "media":
                    self.rx_frames += 1
                    b64 = evt["media"]["payload"]
                    mulaw = base64.b64decode(b64)         # Âµ-law 8kHz 20ms
                    pcm16 = audioop.ulaw2lin(mulaw, 2)    # â†’ PCM16
                    self.last_rx_ts = time.time()

                    if self.mode == "ECHO":
                        # ×œ× ×¨×œ×•×•× ×˜×™ ×›×¢×ª â€” ×¢×•×‘×¨ ×œ-AI
                        pass

                    elif self.mode == "AI":
                        # ×‘×–××Ÿ ×“×™×‘×•×¨ × ×›× ×¡ â€” ××œ ×ª×©×œ×— ×›×œ×•× (×—×¦×™-×“×•-×›×™×•×•× ×™)
                        if not self.speaking:
                            self.buf_pcm16.extend(pcm16)

                        # ×ª× ××™ ×¡×•×£-××‘×¢: ×“×××” ××¡×¤×§×ª ××• ××•×¨×š ××§×¡×™××œ×™
                        dur = len(self.buf_pcm16) / (2 * SR)
                        silent = (time.time() - self.last_rx_ts) >= MIN_UTT_SEC
                        too_long = dur >= MAX_UTT_SEC
                        if (silent or too_long) and dur > 0.25 and not self.speaking:
                            self._process_utterance(bytes(self.buf_pcm16))
                            self.buf_pcm16.clear()

                    continue

                if et == "stop":
                    print(f"WS_STOP sid={self.stream_sid} rx={self.rx_frames} tx={self.tx_frames}")
                    break

        except ConnectionClosed:
            print(f"WS_END sid={self.stream_sid} rx={self.rx_frames} tx={self.tx_frames}")
        except Exception as e:
            print("WS_HANDLER_ERR:", e)
        finally:
            try: self.ws.close()
            except: pass
            print(f"WS_DONE sid={self.stream_sid} rx={self.rx_frames} tx={self.tx_frames}")

    # === ×¢×™×‘×•×“ ××‘×¢ â†’ ASR â†’ LLM â†’ TTS â†’ ×©×œ×™×—×” ===
    def _process_utterance(self, pcm16_8k: bytes):
        if not pcm16_8k:
            return
        self.speaking = True
        try:
            # 1) ASR (×©×™× ×›××Ÿ ××ª ×”-Whisper/GCP ×©×œ×š)
            text = asr_hebrew_from_pcm16_8k(pcm16_8k)  # â† ×¤×•× ×§×¦×™×” ×§×™×™××ª ××¦×œ×š
            if not text:
                self.speaking = False
                return

            # 2) LLM / ××—×•×œ×œ ×ª×©×•×‘×”
            reply_text = generate_hebrew_response(text)  # â† ×¤×•× ×§×¦×™×” ×§×™×™××ª ××¦×œ×š

            # 3) TTS â†’ PCM16 8kHz mono
            pcm16_reply_8k = synth_hebrew_tts_pcm16_8k(reply_text)  # â† ×©×œ×š

            # 4) × ×§×” ×‘××¤×¨ × ×’×Ÿ ××¦×œ Twilio ×•××– ×©×œ×— 20ms ×¤×¨×™×™××™× Âµ-law
            if self.stream_sid:
                self.ws.send(json.dumps({"event":"clear", "streamSid": self.stream_sid}))
            self._send_pcm16_as_mulaw_frames(pcm16_reply_8k)

            # 5) mark (××•×¤×¦×™×•× ×œ×™)
            if self.stream_sid:
                self.ws.send(json.dumps({"event":"mark", "streamSid": self.stream_sid,
                                         "mark":{"name":"tts_done"}}))

        finally:
            self.speaking = False

    def _send_pcm16_as_mulaw_frames(self, pcm16_8k: bytes):
        # ×”××¨×” ×œ-Âµ-law ×•×¤×¨×™×¡×” ×œ-20ms (=160 ×‘×™×™×˜ ×œ-frame)
        mulaw = audioop.lin2ulaw(pcm16_8k, 2)
        FR = 160
        for i in range(0, len(mulaw), FR):
            chunk = mulaw[i:i+FR]
            if len(chunk) < FR:
                break
            payload = base64.b64encode(chunk).decode("ascii")
            self.ws.send(json.dumps({
                "event":"media",
                "streamSid": self.stream_sid,
                "media": {"payload": payload}
            }))
            self.tx_frames += 1
```

ğŸ’¡ × ×§×•×“×•×ª ×—×©×•×‘×•×ª:

* **××™×Ÿ echo** ×‘××¦×‘ AI. ×‘×–××Ÿ ×©×”×œ×§×•×— ××“×‘×¨ â€“ ×¨×§ ××•×¡×¤×™×.
* ×‘×¢×ª ×”×©××¢×ª TTS (`speaking=True`) **×œ×** ××•×¡×™×¤×™× ×¤×¨×™×™××™× ×—×“×©×™× ×œÖ¾buffer ×›×“×™ ×œ×”×™×× ×¢ ××œ×•×¤.
* **×ª××™×“** ×œ×©×œ×•×— `clear` ×œ×¤× ×™ ×”×¤×¨×™×™× ×”×¨××©×•×Ÿ ×©×œ ×”-TTS ×›×“×™ ×œ×¨×•×§×Ÿ ×ª×•×¨ ×§×•×“×.
* **×ª××™×“** ×œ×©×œ×•×— Âµ-law 8kHz ×‘×—×ª×™×›×•×ª ×©×œ **160 ×‘×™×™×˜** (20ms) â€” ×œ× ×’×•×©×™× ×’×“×•×œ×™×.
* ×•×“× ×©×”-TTS ××—×–×™×¨ **PCM16 8kHz ××•× ×•**. ×× ×œ× â€” ×‘×¦×¢ ×”××¨×ª ×§×¦×‘:

  ```python
  # ×œ×“×•×’××”: ×-16k ×œ-8k
  pcm8k, _ = audioop.ratecv(pcm16k, 2, 1, 16000, 8000, None)
  ```

---

# ×‘×“×™×§×•×ª ×“×§×•×ª (GO)

1. **×¨××” ×‘×œ×•×’×™×** ××—×¨×™ ×”×“×™×¤×œ×•×™:
   `WS_START sid=... mode=AI` â†’ ×˜×•×‘.
2. **×“×‘×¨ ×¤×¢× ××—×ª** â†’ ××—×¨×™ \~0.8s ×“×××” ×ª×©××¢ ×ª×©×•×‘×” (×œ× ××ª ×¢×¦××š).
3. **Rx/Tx**: ×‘×¡×™×•× ×™×•×¤×™×¢×• ××•× ×™×, ×œ×“×•×’××”: `rx=120 tx=95` (×œ× ×©×•×•×” ×‘×“×™×•×§, ×•×–×” ×ª×§×™×Ÿ).
4. **Twilio Request Inspector** ×™×™×©××¨ ×™×¨×•×§: ××™×Ÿ 31920/12100, `stream_status`=204, `stream_ended`=200.

---

## ×œ××” ×©××¢×ª ××ª ×¢×¦××š

×›×™ ×¨×¦×ª ×‘-**ECHO** (×‘×›×•×•× ×” ×œ×¦×•×¨×š ×‘×“×™×§×”). ×–×” ××¦×•×™×Ÿ â€” ×–×” ×”×•×›×™×— ×©×”-WS ×“×•Ö¾×›×™×•×•× ×™, ×”×”× ×“×©×™×™×§ ×ª×§×™×Ÿ, ×•×”×¤×•×¨××˜ × ×›×•×Ÿ. ×¢×›×©×™×• ×¢×•×‘×¨×™× ×œ-**AI** ×‘×”×ª×× ×œ×©× ×™ ×”×©×™× ×•×™×™× ×œ××¢×œ×”.

×× ××—×¨×™ ×”××¢×‘×¨ ×œ-AI ××ª×” ×¢×“×™×™×Ÿ ×©×•××¢ ×”×“/×©×§×˜:

* ×”×“ â†’ ×›× ×¨××” `self.speaking` ×œ× ××•× ×¢ echo, ××• ×©× ×©××¨ ×§×•×“ ×©××—×–×™×¨ `media` ×’× ×‘-AI.
* ×©×§×˜ â†’ ×‘×“×•×§ ×©××›×Ÿ ××ª×§×‘×œ ×˜×§×¡×˜ ××”-ASR ×•×©×—×•×–×¨ PCM16 8k ××”-TTS (×”×“×¤×¡ `len(pcm16_reply_8k)`), ×•×©××ª×” ×—×•×ª×š ×œ-20ms.

×ª×¨×¦×”, ××›×™×Ÿ ×œ×š patch ×§×˜×Ÿ ×©××—×œ×™×£ ××ª ×‘×¨×™×¨×ªÖ¾×”××—×“×œ ×œ-AI ×•××•×•×“× ×©××™×Ÿ ×©×•× ×©×œ×™×—×ª `media` ×‘-AI ×—×•×¥ ××”-TTS.
