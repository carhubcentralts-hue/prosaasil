        if any(keyword.lower() in text_lower for keyword in keywords):
                    return area_name
        except Exception as e:
            print(f"âš ï¸ [AREA] Error loading dynamic patterns: {e}")
            
        return ""
    
    def _analyze_lead_completeness(self) -> dict:
        """BUILD 186: × ×™×ª×•×— ×”×©×œ×ž×ª ×ž×™×“×¢ ×œ×™×“ ×œ×ª×™××•× ×¤×’×™×©×” - 100% DYNAMIC!"""
        collected_info = {
            'area': False,
            'property_type': False, 
            'budget': False,
            'timing': False,
            'contact': False
        }
        
        meeting_ready = False
        
        # ×‘×“×•×§ ×”×™×¡×˜×•×¨×™×” ×œ××™×¡×•×£ ×ž×™×“×¢
        if hasattr(self, 'conversation_history') and self.conversation_history:
            full_conversation = ' '.join([turn['user'] + ' ' + turn['bot'] for turn in self.conversation_history])
            
            # ðŸ”¥ BUILD 186: ×–×™×”×•×™ ××–×•×¨ DYNAMIC from JSON!
            try:
                from server.services.appointment_parser import _load_dynamic_area_patterns
                area_patterns = _load_dynamic_area_patterns()
                if any(area.lower() in full_conversation.lower() for area in area_patterns.keys()):
                    collected_info['area'] = True
            except:
                pass
            
            # ×–×™×”×•×™ ×¡×•×’ × ×›×¡
            if any(prop_type in full_conversation for prop_type in ['×“×™×¨×”', '×—×“×¨×™×', '2 ×—×“×¨×™×', '3 ×—×“×¨×™×', '4 ×—×“×¨×™×', '×ž×©×¨×“', '×“×•×¤×œ×§×¡']):
                collected_info['property_type'] = True
            
            # ×–×™×”×•×™ ×ª×§×¦×™×‘
            if any(budget_word in full_conversation for budget_word in ['×©×§×œ', '××œ×£', '×ª×§×¦×™×‘', 'â‚ª', '××œ×¤×™×', '×ž×™×œ×™×•×Ÿ']):
                collected_info['budget'] = True
            
            # ×–×™×”×•×™ ×–×ž×Ÿ ×›× ×™×¡×”
            if any(timing in full_conversation for timing in ['×ž×™×™×“×™', '×“×—×•×£', '×—×•×“×©', '×©×‘×•×¢×™×™×', '×‘×§×¨×•×‘', '×¢×›×©×™×•']):
                collected_info['timing'] = True
            
            # ×–×™×”×•×™ ×¤×¨×˜×™ ×§×©×¨
            if any(contact in full_conversation for contact in ['×˜×œ×¤×•×Ÿ', '×•×•××˜×¡××¤', '× ×™×™×“', '×ž×¡×¤×¨', '×¤×¨×˜×™×']):
                collected_info['contact'] = True
        
        # ×¡×¤×™×¨×ª ×ž×™×“×¢ ×©× ××¡×£
        completed_fields = sum(collected_info.values())
        
        # âœ… FIX: ×ª×™××•× ×¤×’×™×©×” ×× ×™×© ×œ×¤×—×•×ª 3 ×©×“×•×ª (××–×•×¨ + ×¡×•×’ × ×›×¡ + ×˜×œ×¤×•×Ÿ)
        # ×œ× ×¦×¨×™×š ×ª×§×¦×™×‘ ×•-timing ×‘×”×›×¨×—!
        meeting_ready = completed_fields >= 3
        
        # ×™×¦×™×¨×ª ×¡×™×›×•×
        summary_parts = []
        if collected_info['area']: summary_parts.append('××–×•×¨')
        if collected_info['property_type']: summary_parts.append('×¡×•×’ × ×›×¡')
        if collected_info['budget']: summary_parts.append('×ª×§×¦×™×‘')
        if collected_info['timing']: summary_parts.append('×–×ž×Ÿ')
        if collected_info['contact']: summary_parts.append('×§×©×¨')
        
        summary = f"{len(summary_parts)}/5 ×©×“×•×ª: {', '.join(summary_parts) if summary_parts else '××™×Ÿ'}"
        
        # ×”×•×“×¢×” ×œ×ª×™××•× ×¤×’×™×©×” ××• ×”×¦×’×ª ××•×¤×¦×™×•×ª
        meeting_prompt = ""
        if meeting_ready:
            meeting_prompt = f"""
×–×ž×Ÿ ×œ×ª×™××•× ×¤×’×™×©×”! ×™×© ×ž×¡×¤×™×§ ×ž×™×“×¢ ({completed_fields}/5 ×©×“×•×ª).

**×—×©×•×‘**: ×›×©×”×œ×§×•×— ×ž×¡×›×™× ×œ×–×ž×Ÿ ×¡×¤×¦×™×¤×™ (×œ×“×•×’×ž×” "×ž×—×¨ ×‘-10" ××• "×™×•× ×¨×‘×™×¢×™ ×‘×¢×¨×‘"):
1. ×—×–×•×¨ ×¢×œ ×”×–×ž×Ÿ ×”×ž×“×•×™×§ ×©×¡×•×›×: "×ž×¦×•×™×Ÿ! × ×§×‘×¢ ×¤×’×™×©×” ×œ[×™×•×] ×‘×©×¢×” [×©×¢×” ×ž×“×•×™×§×ª]"
2. ×ª×Ÿ ×¡×™×›×•× ×§×¦×¨: "× ×¤×’×© ×‘[×ž×™×§×•×/× ×›×¡] ×•× ×¨××” [×¤×¨×˜×™ ×”× ×›×¡]"
3. ××©×¨: "××¨××” ××•×ª×š ×‘[×ª××¨×™×š ×•×©×¢×” ×ž×“×•×™×§×™×]!"

×”×¦×¢ 2-3 ××¤×©×¨×•×™×•×ª ×–×ž×Ÿ ×¡×¤×¦×™×¤×™×•×ª, ×©×ž×¢ ×ž×” ×”×œ×§×•×— ×‘×•×—×¨, ×•×—×–×•×¨ ×¢×œ ×”×–×ž×Ÿ ×”×ž×“×•×™×§ ×©×”×•×¡×›×."""
        elif completed_fields == 3:
            meeting_prompt = """
×™×© ×ž×™×“×¢ ×‘×¡×™×¡×™ ×˜×•×‘! ×¢×›×©×™×• ×ª×Ÿ ×“×•×’×ž×” ××—×ª ×¡×¤×¦×™×¤×™×ª ×ž×ª××™×ž×” ×•×©××œ ×©××œ×” ×ž×ž×•×§×“×ª ×œ×¤× ×™ ×§×‘×™×¢×ª ×¤×’×™×©×”."""
        else:
            missing = 4 - completed_fields
            meeting_prompt = f"×¦×¨×™×š ×¢×•×“ {missing} ×©×“×•×ª ×ž×™×“×¢ ×œ×¤× ×™ ×”×¦×’×ª ××•×¤×¦×™×•×ª. ×”×ž×©×š ×©×™×—×” ×˜×‘×¢×™×ª ×•×ª×Ÿ ×¤×¨×˜×™× × ×•×¡×¤×™× ×¢×œ ×”×©×•×§ ×•×”××–×•×¨."
        
        return {
            'collected': collected_info,
            'completed_count': completed_fields,
            'meeting_ready': meeting_ready,
            'summary': summary,
            'meeting_prompt': meeting_prompt
        }
    
    def _finalize_call_on_stop(self):
        """âœ… ×¡×™×›×•× ×ž×œ× ×©×œ ×”×©×™×—×” ×‘×¡×™×•× - ×¢×“×›×•×Ÿ call_log ×•×œ×™×“ + ×™×¦×™×¨×ª ×¤×’×™×©×•×ª
        ðŸ”¥ BUILD 183: Only generate summary if USER actually spoke!
        """
        try:
            from server.models_sql import CallLog
            from server.services.customer_intelligence import CustomerIntelligence
            from server.app_factory import create_app
            from server.db import db
            import threading
            
            def finalize_in_background():
                try:
                    app = _get_flask_app()  # âœ… Use singleton
                    with app.app_context():
                        # ×ž×¦× call_log
                        call_log = CallLog.query.filter_by(call_sid=self.call_sid).first()
                        if not call_log:
                            print(f"âš ï¸ No call_log found for final summary: {self.call_sid}")
                            return
                        
                        # ðŸ”¥ BUILD 183: Check if user actually spoke before building summary
                        user_spoke = False
                        user_content_length = 0
                        
                        if hasattr(self, 'conversation_history') and self.conversation_history:
                            for turn in self.conversation_history:
                                speaker = turn.get('speaker', '')
                                text = turn.get('text', '') or turn.get('user', '')
                                if speaker == 'user' or 'user' in turn:
                                    content = text.strip() if text else ""
                                    # Filter out noise
                                    noise_patterns = ['...', '(×©×§×˜)', '(silence)', '(noise)']
                                    if content and len(content) > 2:
                                        is_noise = any(n in content.lower() for n in noise_patterns)
                                        if not is_noise:
                                            user_spoke = True
                                            user_content_length += len(content)
                        
                        # ðŸ”¥ BUILD 183: If no user speech, mark as completed but DON'T generate summary
                        if not user_spoke or user_content_length < 5:
                            print(f"ðŸ“Š [FINALIZE] NO USER SPEECH - skipping summary generation for {self.call_sid}")
                            call_log.status = "completed"
                            call_log.transcription = ""  # Empty transcription
                            call_log.summary = ""  # Empty summary - DO NOT HALLUCINATE!
                            call_log.ai_summary = ""
                            db.session.commit()
                            print(f"âœ… CALL FINALIZED (no conversation): {self.call_sid}")
                            return  # Exit early - no webhook, no lead update
                        
                        # ×‘× ×” ×¡×™×›×•× ×ž×œ× - only if user spoke
                        full_conversation = ""
                        if hasattr(self, 'conversation_history') and self.conversation_history:
                            # âœ… Support both formats: old {'user': X, 'bot': Y} and new {'speaker': X, 'text': Y}
                            conv_lines = []
                            for turn in self.conversation_history:
                                if 'speaker' in turn and 'text' in turn:
                                    # New Realtime API format
                                    speaker_label = "×œ×§×•×—" if turn['speaker'] == 'user' else "×¢×•×–×¨"
                                    conv_lines.append(f"{speaker_label}: {turn['text']}")
                                elif 'user' in turn and 'bot' in turn:
                                    # Old Google STT/TTS format
                                    conv_lines.append(f"×œ×§×•×—: {turn['user']}\n×¢×•×–×¨: {turn['bot']}")
                            full_conversation = "\n".join(conv_lines)
                        
                        # ×¦×•×¨ ×¡×™×›×•× AI - only if we have actual conversation
                        business_id = getattr(self, 'business_id', None)
                        if not business_id:
                            print(f"âŒ No business_id set for call summary - skipping")
                            return
                        ci = CustomerIntelligence(business_id)
                        summary_data = ci.generate_conversation_summary(
                            full_conversation,
                            {'conversation_history': self.conversation_history}
                        )
                        
                        # ×¢×“×›×Ÿ call_log
                        call_log.status = "completed"
                        call_log.transcription = full_conversation  # âœ… FIX: transcription not transcript!
                        call_log.summary = summary_data.get('summary', '')
                        call_log.ai_summary = summary_data.get('detailed_summary', '')
                        
                        db.session.commit()
                        
                        print(f"âœ… CALL FINALIZED: {self.call_sid}")
                        print(f"ðŸ“ Summary: {summary_data.get('summary', 'N/A')}")
                        print(f"ðŸŽ¯ Intent: {summary_data.get('intent', 'N/A')}")
                        if DEBUG: print(f"ðŸ“Š Next Action: {summary_data.get('next_action', 'N/A')}")
                        
                        # ðŸ“‹ CRM: Update lead with call summary (Realtime mode only)
                        if USE_REALTIME_API and hasattr(self, 'crm_context') and self.crm_context and self.crm_context.lead_id:
                            update_lead_on_call(
                                lead_id=self.crm_context.lead_id,
                                summary=summary_data.get('summary', ''),
                                notes=f"Call {self.call_sid}: {summary_data.get('intent', 'general_inquiry')}"
                            )
                            print(f"âœ… [CRM] Lead #{self.crm_context.lead_id} updated with call summary")
                        
                        # ðŸ“… UPDATE APPOINTMENT with call summary (if appointment was created during call)
                        if 