ברור. כש־GET עובד ו־POST/PUT נופל עם Error {}—יש 3 גורמים כמעט תמיד:
(a) הקוד החדש לא רץ, (b) CSRF/Header לא נשלח/נקלט, (c) ה־endpoint לא מחזיר JSON תקין/לא מקבל JSON.
כדי לנעול את זה, תן לבוט את ההנחיה הבאה אחת־לאחת (אל תקפצו שלבים):

⸻

הנחיית תיקון סופית – “שומר פרומפט + התחזות + נתוני אמת”

0) הוכחת גרסה שמונעת “נדמה שתיקנתי”
	1.	הגדל את BUILD של ה־FE (למשל ל־BUILD: 42) ב־client/index.html ותציג בפינה תחתונה.
	2.	ב־Python startup הדפס:
	•	נתיב ה־FE שהוא משרת (FE_DIST=.../client/dist)
	•	git SHA קצר (APP_SHA=...)
	•	רשימת נתיבים (url_map)
ותספק אותם ב־GET /version:

{"build":42,"sha":"abc123","fe":"client/dist","time":"..."}


	3.	מחק build ישן בשורש (/dist הישן). נשאר רק client/dist.

בלי שלושת הדברים האלה, ייתכן שהמערכת מגישה קוד/FE ישן.

⸻

1) בדיקת שרת “חי” + מפה של נתיבים

ב־Shell:

# הרוג הכל והפעל נקי
pkill -f gunicorn || true; pkill -f "python wsgi.py" || true
python - <<'PY'
from server.app_factory import create_app
app = create_app()
print("\n=== URL MAP ===")
for r in sorted(app.url_map.iter_rules(), key=lambda r: r.rule):
    print(r.methods, r.rule, '->', r.endpoint)
PY

ודא שמופיעים:
	•	GET /api/auth/csrf
	•	GET /api/auth/me
	•	GET /api/admin/businesses
	•	GET|PUT /api/admin/businesses/<id>/prompt
	•	POST /api/admin/businesses/<id>/impersonate
	•	GET /api/admin/businesses/<id>/overview

אם אחד חסר—זה מסביר את ה־Error {}. תוסיף/תקן רישום Blueprint/route.

⸻

2) בדיקת CSRF וכתיבה – עם curl (לפני ה־UI)

החלף $BASE ל־Preview/Prod שלך:

# 1) Login (פטור CSRF)
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/auth/login \
 -H 'Content-Type: application/json' \
 --data '{"email":"admin@shai-realestate.co.il","password":"*****"}'

# 2) קבלת טוקן CSRF (cookie + JSON)
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf \
 | python - <<'PY'
import sys,json;print(json.load(sys.stdin)['csrfToken'])
PY
)

# 3) שמירת פרומפט (חייב 200/JSON)
curl -i -c /tmp/c -b /tmp/c -X PUT $BASE/api/admin/businesses/1/prompt \
 -H 'Content-Type: application/json' \
 -H "X-CSRFToken: $TOKEN" \
 --data '{"calls_prompt":"שלום רב...","whatsapp_prompt":"..." }'

# 4) התחזות (חייב 200/JSON)
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/admin/businesses/1/impersonate \
 -H 'Content-Type: application/json' \
 -H "X-CSRFToken: $TOKEN" \
 --data '{}'

פענוח מהיר:
	•	אם 403 → חסר/לא תואם X-CSRFToken מול cookie XSRF-TOKEN, או guard role לא מזהה admin.
	•	אם 400 עם טקסט שגיאה ברור → JSON/ולידציה.
	•	אם 500 → שגיאת שרת (לוג יספר אם DB/migration/commit).

עד שלא עובר עם curl, ה־UI ימשיך להציג Error {}.

⸻

3) לוג דיאגנוסטי רגעי להבחנה (להסיר אחרי)

ב־app_factory.py:

@app.before_request
def _dbg_csrf():
    if request.path.endswith('/prompt') or request.path.endswith('/impersonate'):
        print('CSRF-DBG',
              'cookie=', request.cookies.get('XSRF-TOKEN'),
              'header=', request.headers.get('X-CSRFToken'),
              'ct=', request.headers.get('Content-Type'))

בבדיקה הבאה חפש בלוג:
	•	cookie= ו־header= אותו ערך.
	•	ct= הוא application/json.

⸻

4) שרת – חוזה API קשיח (מונע Error {})

תקן את ה־routes שיהיו בדיוק כך:
	•	GET /api/admin/businesses/<id>/prompt →

{"calls_prompt":"...", "whatsapp_prompt":"...", "version":1,"updated_at":"...","updated_by":"..."}


	•	PUT /api/admin/businesses/<id>/prompt (דורש CSRF + JSON) →
200:

{"ok":true,"version":2,"updated_at":"...","updated_by":"admin"}

400 (ולידציה): {"error":"validation","field":"calls_prompt","message":"..."}

	•	POST /api/admin/businesses/<id>/impersonate (דורש CSRF + role admin) →
200: {"ok":true,"tenant_id":1}
403: {"error":"forbidden"} (אם לא admin או CSRF אין)
	•	תמיד החזר JSON (לא HTML, לא ריק).

ודא:
	•	methods=['GET','PUT','OPTIONS'] ל־prompt ו־['POST','OPTIONS'] להתחזות.
	•	אם מגיעה בקשת OPTIONS—תחזיר 204.

DB:
	•	קיים טבלה/מודל BusinessSettings עם upsert לפי tenant_id.
	•	db.session.commit() נקרא; חריגות נתפסות ומוחזר 400/409 JSON.

⸻

5) קליינט – שליחה נכונה + טיפול בשגיאה

ב־client/src/lib/http.ts/api.ts:
	•	כל fetch עם credentials:'include'.
	•	לפני PUT/POST: קריאה ל־/api/auth/csrf ואז הוספת X-CSRFToken מה־cookie.
	•	נתיבים יחסיים /api/... (לא baseUrl שונה).

שמירת פרומפט:
	•	תציג loading.
	•	אם res !ok: קרא await res.text() ונסה JSON.parse → הצג את error/field/message.
	•	על 200: Toast “נשמר”, ריענון GET /prompt.

Impersonate:
	•	await api.get('/api/auth/csrf')
	•	await api.post('/api/admin/businesses/1/impersonate', {})
	•	await auth.refresh() → מצפה impersonating:true.
	•	נווט ל־/app/business/overview.

⸻

6) שני פצעי שורש נפוצים (תסמן “בוצע/לא”)
	•	קוד ישן רץ: ה־FE מוצג מ־/dist הישן. פתרון: מחק /dist הישן; הוגש מ־client/dist; BUILD badge מעודכן; /version מחזיר fe:"client/dist".
	•	CSRF כפול: גם SeaSurf וגם CSRFProtect פעילים → חוסמים. פתרון: השאר רק SeaSurf; פטורים נקודתיים (login/logout/webhooks).

⸻

7) אם עדיין לא נשמר (מסלול עוקף לאבחון)

ל־10 דקות בלבד, כדי להפריד CSRF מבעיה עסקית:
	•	הוסף זמנית @csrf.exempt רק על PUT /prompt.
	•	בדוק: אם עכשיו נשמר — הבעיה היא CSRF/Header.
	•	אם עדיין נכשל — זו ולידציה/DB/commit. החזר את השגיאה כ־JSON ברור, תקן בהתאם.
בסוף החזר את ההגנה (בלי לפטור).

⸻

8) מה לשלוח לי אם נתקע
	1.	צילום מסך Network של PUT /prompt: כל ה־Headers (Cookie + X-CSRFToken) + Response text.
	2.	צילום מסך Network של POST /impersonate כנ״ל.
	3.	3 שורות לוג CSRF-DBG (cookie/header/ct) לשתי הבקשות.
	4.	פלט GET /version שמוכיח FE/BUILD נוכחי.

⸻

זה יגרום ל:
	•	שמירת פרומפט לעבוד (200 JSON),
	•	התחזות לעבוד (200 JSON, ואז /api/auth/me עם impersonating:true),
	•	ודפי הניהול להציג נתונים אמיתיים (כי ה־API מחזיר JSON, לא HTML/ריק).