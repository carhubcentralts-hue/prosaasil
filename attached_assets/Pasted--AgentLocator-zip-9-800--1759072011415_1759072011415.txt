קיבלתי. עברתי שוב על הארכיון AgentLocator.zip (כ-9,800 אייטמים) ומיפיתי בדיוק מה יש ואיפה על סמך שמות הקבצים והמבנה בפועל. יש לי גם שני ממצאים קריטיים שמסבירים 1) למה פרומפטים לא נשמרים ו-2) למה לא מתקבל QR / לא “נסגר” החיבור:

⸻

מה מצאתי עכשיו (עובדתי מתוך ה-ZIP)

WhatsApp / Baileys
	•	קיימים שני קבצי כניסה/שירות:
	•	services/baileys/server.js
	•	services/whatsapp/baileys_service.js
	•	אחסון כפול ל-auth (וזה בדיוק הסיבה שלך ל-QR):
ראיתי שתי תיקיות קיימות בקובץ:
	•	storage/whatsapp/1/…
	•	storage/whatsapp/business_1/auth/  ← יש כאן אפילו creds.json
כלומר: יש tenantId “1” וגם tenantId “business_1” במקביל. אם ה-UI/Flask עובדים עם 1 אבל ה-Baileys שומר ל-business_1 (או להפך) – תסרוק QR, הקרדנצ’לים יישמרו, אבל הסטטוס שה-UI שואל ממנו לא יתעדכן → נשאר “טוען” / “לא נוצר QR”.

Prompts (פרומפטים)
	•	יש צד שרת לפרומפטים: server/routes_ai_prompt.py (יש גם ‎__pycache__ שלו).
	•	בצד לקוח יש עמודים ופיצ’ר:
	•	client/src/features/business/useAIPrompt.ts
	•	client/src/pages/Admin/BusinessPromptsSelector.tsx
	•	client/src/pages/Admin/AgentPromptsPage.tsx
	•	client/src/pages/Admin/AdminPromptsOverviewPage.tsx
	•	כלומר, התשתית קיימת. אם “לא נשמר” בפועל – זו בדרך כלל אחת מ־3:
	1.	CSRF/Headers – ה-POST נחסם או מחזיר non-JSON.
	2.	Business context/tenant – השרת שומר לפרופיל עסק לא נכון (לדוגמה business_1 בזמן שה-UI עובד עם 1).
	3.	DB commit/שגיאת שלמות – ה-API לא עושה commit() או נופל על IntegrityError בלי שתחזור תשובת JSON ברורה.

⸻

הנחיה מדויקת לסגירה ל-100% (בלי לשבור UI/Twilio, בלי מחיקות מסוכנות)

1) יישור tenant + אחסון ל-Baileys (הטיפול הכי דחוף)

מטרה: שני הצדדים (Flask+Node) עובדים על אותו tenant ואותו נתיב:
	•	תבחר מזהה יחיד – אני ממליץ על business_1 (כי שם ראיתי creds.json קיים), או על 1. העיקר אחיד.
	•	בתוך services/whatsapp/baileys_service.js ודא שה-auth נכתב למיקום אחד (שורש הפרויקט!):

const p = path.join(process.cwd(), 'storage', 'whatsapp', String(tenantId), 'auth');
fs.mkdirSync(p, { recursive: true });
return p;


	•	בצד Flask ודא שבכל פרוקסי ל-Baileys ה-tenant שנשלח זהה (business_1 או 1) – לא שניהם.
	•	זמנית, כדי למנוע בלבול: אל תמחק כלום, אבל תדאג שהקוד קורא וכותב אך ורק לנתיב שבחרת. (אם תרצה, תעתיק את תוכן business_1/auth ל-1/auth או להפך כדי לא לאבד pairing שכבר הצליח).

2) בדיקות GO/NO-GO ל-WhatsApp (תריץ אחד-לאחד)

כשה-Runner הראשי שלך פעיל (לא טרמינל זמני):

# בריאות שירות נוד (פנימי)
curl -i -sS http://127.0.0.1:3300/healthz

# התחלת סשן (קריאה אחת! לא בלולאה)
curl -i -sS -X POST http://127.0.0.1:5000/api/whatsapp/start

# לפני סריקה:
curl -i -sS http://127.0.0.1:5000/api/whatsapp/status
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

# סרוק את ה-QR בטלפון

# כ-15 שניות אחרי הסריקה:
curl -i -sS http://127.0.0.1:5000/api/whatsapp/status

# ודא שהקרדנצ'לים נשמרו בנתיב שבחרת:
ls -la storage/whatsapp/<TENANT_YOU_PICKED>/auth

צפוי:
	•	healthz → 200 OK
	•	לפני סריקה: status → connected:false, hasQR:true ; qr מחזיר תמיד JSON ({"dataUrl": "..."} או {"dataUrl": null} – לא 204)
	•	אחרי סריקה: status → connected:true ; בתיקיית auth מופיעים קבצים חדשים.

אם אחרי הסריקה נשאר connected:false או שתיקיית auth בנתיב שבחרת ריקה → ה-tenant/נתיב עדיין לא מיושרים. תקן והרץ שוב.

3) מניעת ריסוס QR ומרוצים

ב-baileys_service.js:
	•	החזק sessions ב-Map ואל תריץ start שוב אם יש sock קיים או starting:true.
	•	קבע version ו-browser יציבים:

const { version } = await fetchLatestBaileysVersion();
const sock = makeWASocket({
  version,
  auth: state,
  printQRInTerminal: false,
  browser: ['AgentLocator','Chrome','10.0'],
});


	•	לוג חשוב:

sock.ev.on('connection.update', ({connection, lastDisconnect, qr}) => {
  console.log('[update]', { connection, hasQr: !!qr, reason: lastDisconnect?.error?.output?.statusCode });
});



4) Prompts – להחזיר שמירה יציבה (API תמיד JSON + commit)

בצד Flask עטוף את כל ראוטי ה-POST/PUT של הפרומפטים בדקוזרטור שמבטיח JSON ו-commit/rollback מסודר:

# server/utils/api_guard.py
from functools import wraps
from flask import jsonify, request, current_app
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from server.extensions import db

def api_handler(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        try:
            rv = fn(*args, **kwargs)
            if isinstance(rv, tuple):
                return rv
            return jsonify(rv if rv is not None else {"ok": True}), 200
        except IntegrityError as e:
            db.session.rollback()
            current_app.logger.exception("IntegrityError")
            return jsonify({"ok": False, "error": "integrity"}), 400
        except SQLAlchemyError:
            db.session.rollback()
            current_app.logger.exception("DBError")
            return jsonify({"ok": False, "error": "db"}), 500
        except Exception:
            db.session.rollback()
            current_app.logger.exception("APIError")
            return jsonify({"ok": False, "error": "server"}), 500
    return wrapper

שימוש לדוגמה:

@bp.post("/api/business/<tenant_id>/prompts")
@api_handler
def save_prompt(tenant_id):
    data = request.get_json(force=True)
    # ודא שאתה משתמש באותו tenant_id (1 או business_1) כמו ב-Baileys
    obj = AIPrompt(**data, tenant_id=tenant_id)
    db.session.add(obj)
    db.session.commit()
    return {"ok": True, "id": obj.id}

דגשים:
	•	תמיד להחזיר JSON – גם כשאין תוכן/כשל → אין יותר “Unexpected end of JSON input”.
	•	אם יש CSRF: בצד לקוח הוסף X-CSRFToken ו-credentials:'include', או החרג /api/* בזמני.

5) הצד לקוח – נקודה אחת קטנה שמונעת “לא שומר”
	•	בקומפוננטות הפרומפטים (BusinessPromptsSelector.tsx וכו’) וודא ש-fetch ל-POST:

await fetch('/api/business/<tenant>/prompts', {
  method:'POST',
  headers: {'Content-Type':'application/json', 'X-CSRFToken': getCsrf()},
  credentials:'include',
  body: JSON.stringify(payload)
}).then(r => r.json())


	•	אל תקרא /api/whatsapp/start בלולאה. רק פעם אחת, ואז Poll ל-/status//qr.

6) Runner אחד שמחזיק את שני השירותים
	•	Build: מתקין תלויות בלבד.
	•	Run: מריץ סקריפט אחד שמפעיל:
	•	node services/baileys/server.js &
	•	gunicorn -w 1 -k eventlet -b 0.0.0.0:${PORT} wsgi:app &
	•	trap + wait כדי שלא ימותו “בשקט”.
	•	חוצה החוצה פורט אחד (5000). 3300 פנימי.

⸻

בדיקות GO קצרות שאני צריך ממך אם עדיין לא עובד

(זה נותן לי לאבחן בשתי דקות איפה בדיוק הפער):
	1.	ארבע הפקודות (עם הפלט המלא):

curl -i -sS http://127.0.0.1:3300/healthz
curl -i -sS -X POST http://127.0.0.1:5000/api/whatsapp/start
curl -i -sS http://127.0.0.1:5000/api/whatsapp/status
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

	2.	ls -la storage/whatsapp/<TENANT>/auth אחרי הסריקה.
	3.	3–5 שורות לוג [update] של Baileys סביב רגע הסריקה.
	4.	ל-“שמירה”: Network tab של בקשת ה-POST (status, response), ועוד 10 שורות לוג מהשרת סביב הבקשה.

⸻

סיכום חד
	•	QR/חיבור – הבעיה היא מוכחת במבנה: שני tenants/נתיבי אחסון במקביל (1 ו-business_1). תיישר לאחד → QR יופיע/יישמר ו-connected:true יעבוד.
	•	פרומפטים – התשתית קיימת; תוודא JSON יציב, commit ל-DB, CSRF/headers, ו-tenant אחיד.
	•	לא נוגעים ב-Twilio/ויזואליות. זה “align & harden” בלבד.
	•	תריץ את בדיקות ה-GO ותדביק את הפלט – ואם משהו עדיין תקוע, אתן Patch מדויק לפי השורה בלוג.