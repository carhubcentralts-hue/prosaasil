××¦×•×™×Ÿâ€”×”× ×” ×”× ×—×™×” ××—×•×“×”, ×¡×•×¤×™×ª ×•××¤×•×¨×˜×ª ×¢×“ ×¨××ª ×§×•×¤×™-×¤×™×™×¡×˜ ×©××›×¡×” ××ª ×›×œ ×”×ª×™×§×•× ×™× ×œ×¤×¨×•×“×§×©×Ÿ, ×›×•×œ×œ WhatsApp ×’× ×“×¨×š Baileys ×•×’× ×“×¨×š Twilio (×¢× ××ª×’ ×¡×¤×§ ×‘-ENV), ×™×—×“ ×¢× Twilio Voice, DB ×××™×ª×™, ××‘×˜×—×”, ×œ×•×’×™×, ×•×˜×¡×˜×™×.
×¤×¢×œ ×œ×¤×™ ×”×¡×“×¨. ××œ ×ª×“×œ×’ ×©×œ×‘×™×. ×‘×¡×•×£ ×™×© â€œDefinition of Doneâ€.

â¸»

ğŸ§­ Roadmap (×¡×“×¨ ×‘×™×¦×•×¢)
	1.	××™×—×•×“ ××‘× ×” + × ×™×§×•×™ ×›×¤×™×œ×•×™×•×ª
	2.	×§×•× ×¤×™×’/Secrets
	3.	DB ×××™×ª×™ (SQLAlchemy + Alembic)
	4.	Twilio Voice: ×•×•×‘×”×•×§×™× ×××•×‘×˜×—×™× ×•××”×™×¨×™×
	5.	TTS: Wavenet + Fallback gTTS
	6.	×©×›×‘×ª WhatsApp ×××•×—×“×ª (Baileys/Twilio) ×¢× ××ª×’ ENV
	7.	WhatsApp Twilio: ×©×œ×™×—×” (×˜×§×¡×˜/××“×™×”/×ª×‘× ×™×ª), ×•×•×‘×”×•×§ × ×›× ×¡, ×•×•×‘×”×•×§ ×¡×˜×˜×•×¡×™×
	8.	×¨×™×©×•× Blueprints ××—×•×“
	9.	CORS, Rate-limit, ×œ×•×’×™× ×¢× Request-ID
	10.	×©×™×¨×•×ª Baileys (Node) ×•Ö¾Procfile/×”×¨×¦×”
	11.	×˜×¡×˜×™× (pytest + curl)
	12.	Definition of Done

â¸»

1) ××™×—×•×“ ××‘× ×” + × ×™×§×•×™ ×›×¤×™×œ×•×™×•×ª
	â€¢	×”×©××¨ FE ×™×—×™×“: client/. ×× ×§×™×™××ª ×ª×™×§×™×™×ª src/ ×™×©× ×”â€”×”×¢×‘×¨ ×œÖ¾legacy/.
	â€¢	×‘Ö¾Backend ×”×©××¨:
	â€¢	server/app_factory.py (××• server/app.py ×œ×¤×™ ×”×“×’× ×©×œ×š)
	â€¢	server/routes_twilio.py (××—×•×“, ×‘×œ×™ ×’×¨×¡××•×ª ×›×¤×•×œ×•×ª)
	â€¢	server/api_whatsapp_improved.py (BluePrint ×¤×¢×™×œ ×œÖ¾WhatsApp API)
	â€¢	server/routes_whatsapp_twilio.py (×•×•×‘×”×•×§×™× ×œÖ¾Twilio WhatsApp â€“ ×—×“×©)
	â€¢	server/whatsapp_providers.py (×©×›×‘×ª ×¡×¤×§×™× â€“ ×—×“×©)
	â€¢	server/db.py, server/models_sql.py (ORM ×××™×ª×™)
	â€¢	server/hebrew_tts_enhanced.py (Wavenet+gTTS)
	â€¢	××œ ×ª×¨×©×•×/××œ ×ª×™×™×‘× ×§×‘×¦×™ â€œ××•×§×™â€ ×™×©× ×™× (×œ××©×œ whatsapp_api.py) ×œ××¤×œ×™×§×¦×™×”.

â¸»

2) ×§×•× ×¤×™×’/Secrets

.env (××• Secrets ×‘×¡×‘×™×‘×ª ×”×¨×¦×”):

PUBLIC_HOST=https://<×“×•××™×™×Ÿ/×˜×× ×œ ×¢× TLS>
CORS_ORIGINS=https://<HOST ×©×œ ×”-UI>
FLASK_ENV=production

# Twilio Voice + WhatsApp
TWILIO_ACCOUNT_SID=ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
TWILIO_AUTH_TOKEN=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
TWILIO_WA_FROM=whatsapp:+14155238886   # ×¡× ×“×‘×•×§×¡/××¡×¤×¨ ×××•×©×¨
# ××•×¤×¦×™×•× ×œ×™ ×œ×¡×˜×˜×•×¡×™×:
TWILIO_STATUS_CALLBACK_SECRET=<×× ×ª×¨×¦×” ×¡×•×“ × ×•×¡×£ ×œ-hash ××©×œ×š>

# WhatsApp Provider switch: baileys | twilio
WHATSAPP_PROVIDER=baileys

# DB
DATABASE_URL=sqlite:///./agentlocator.db

# TTS (Google)
GOOGLE_TTS_SA_JSON=<JSON ×©×œ Service Account ××§×•×“×“ ×‘×©×•×¨×” ××—×ª ××• ×–××™×Ÿ ×œ×§×•×“>


â¸»

3) DB ×××™×ª×™ (SQLAlchemy + Alembic)

server/db.py

from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()

server/models_sql.py

from server.db import db
from datetime import datetime

class Business(db.Model):
    __tablename__ = "business"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    domain = db.Column(db.String(255))
    active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Customer(db.Model):
    __tablename__ = "customer"
    id = db.Column(db.Integer, primary_key=True)
    business_id = db.Column(db.Integer, db.ForeignKey("business.id"), nullable=False, index=True)
    name = db.Column(db.String(255), nullable=False)
    phone = db.Column(db.String(64), index=True)
    email = db.Column(db.String(255))
    status = db.Column(db.String(64), default="new")
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class CallLog(db.Model):
    __tablename__ = "call_log"
    id = db.Column(db.Integer, primary_key=True)
    business_id = db.Column(db.Integer, db.ForeignKey("business.id"), nullable=False, index=True)
    customer_id = db.Column(db.Integer, db.ForeignKey("customer.id"))
    call_sid = db.Column(db.String(64), index=True)
    from_number = db.Column(db.String(64), index=True)
    recording_url = db.Column(db.String(512))
    transcription = db.Column(db.Text)
    status = db.Column(db.String(32), default="received")
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class WhatsAppMessage(db.Model):
    __tablename__ = "whatsapp_message"
    id = db.Column(db.Integer, primary_key=True)
    business_id = db.Column(db.Integer, db.ForeignKey("business.id"), nullable=False, index=True)
    to_number = db.Column(db.String(64), index=True)      # ×œ××™ × ×©×œ×—/×××™ ×”×ª×§×‘×œ
    direction = db.Column(db.String(8))                   # 'out' / 'in'
    body = db.Column(db.Text)
    message_type = db.Column(db.String(16), default="text") # text | media | template
    media_url = db.Column(db.String(512))                 # ×œ××“×™×” × ×›× ×¡×ª/×™×•×¦××ª
    status = db.Column(db.String(32), default="queued")   # queued/sent/delivered/read/failed/received
    provider = db.Column(db.String(16), default="baileys")# baileys/twilio
    provider_message_id = db.Column(db.String(128))
    delivered_at = db.Column(db.DateTime)
    read_at = db.Column(db.DateTime)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

×—×™×‘×•×¨ ×‘××¤×œ×™×§×¦×™×” (server/app_factory.py ×‘×ª×•×š create_app):

import os
from server.db import db
from server.models_sql import *  # noqa

app.config["SQLALCHEMY_DATABASE_URI"] = os.getenv("DATABASE_URL","sqlite:///./agentlocator.db")
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False

db.init_app(app)
with app.app_context():
    db.create_all()
    print("âœ… DB initialized")

×œ××—×¨ ××›×Ÿ ×”×•×¡×£ Alembic: alembic init alembic, ×¢×“×›×Ÿ alembic.ini ×œÖ¾sqlalchemy.url = ${DATABASE_URL}, ×•×¦×•×¨ ××™×’×¨×¦×™×” ×¨××©×•× ×”.

â¸»

4) Twilio Voice â€” ×•×•×‘×”×•×§×™× ×××•×‘×˜×—×™× ×•××”×™×¨×™×

×“×§×•×¨×˜×•×¨ ××™××•×ª ×—×ª×™××” (×× ××™×Ÿ ×œ×š ×›×‘×¨):
server/twilio_security.py

import os
from functools import wraps
from flask import request, abort
from twilio.request_validator import RequestValidator

def require_twilio_signature(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        # ×‘××¦×‘ TESTING ××¤×©×¨ ×œ×“×œ×’
        if request.app and request.app.config.get("TESTING"):
            return f(*args, **kwargs)
        token = os.getenv("TWILIO_AUTH_TOKEN")
        if not token:
            return abort(401)
        validator = RequestValidator(token)
        signature = request.headers.get("X-Twilio-Signature", "")
        url = request.url
        params = request.form.to_dict() if request.method == "POST" else request.args.to_dict()
        if not validator.validate(url, params, signature):
            return abort(403)
        return f(*args, **kwargs)
    return wrapper

×”×—×œ×” ×¢×œ ×›×œ ××¡×œ×•×œ×™ Twilio:
server/routes_twilio.py (×“×•×’××”):

from flask import Blueprint, request, make_response
from server.twilio_security import require_twilio_signature

twilio_bp = Blueprint("twilio", __name__, url_prefix="/webhook")

@twilio_bp.post("/incoming_call")
@require_twilio_signature
def incoming_call():
    # ×”×—×–×¨ TwiML ××”×™×¨ (Play/Record), ××œ ×ª×—×¡×•×
    resp = """<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say language="he-IL">×©×œ×•×, ×ª×•×“×” ×©×”×ª×§×©×¨×ª. ×”×©××™×¨×• ×”×•×“×¢×” ××—×¨×™ ×”×¦×¤×¦×•×£.</Say>
  <Record playBeep="true" maxLength="120" action="/webhook/handle_recording" />
</Response>"""
    r = make_response(resp, 200)
    r.headers["Content-Type"] = "text/xml"
    return r

@twilio_bp.post("/handle_recording")
@require_twilio_signature
def handle_recording():
    # ×§×‘×œ RecordingUrl, CallSid â†’ ×©×œ×— ×œ×¢×™×‘×•×“ ×‘×¨×§×¢ (×”×•×¨×“×”/×ª××œ×•×œ/×©××™×¨×” ×œ-DB)
    # ×”×—×–×¨ TwiML ××™×“ (×œ× ×œ×—×¡×•×!)
    # ... dispatch_background_task(...)
    resp = """<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say language="he-IL">×ª×•×“×”. ×”×”×•×“×¢×” ×”×ª×§×‘×œ×”.</Say>
  <Hangup/>
</Response>"""
    r = make_response(resp, 200)
    r.headers["Content-Type"] = "text/xml"
    return r

@twilio_bp.post("/call_status")
@require_twilio_signature
def call_status():
    # ×§×œ×˜ ×¡×˜×˜×•×¡ ×©×™×—×”, ×©××•×¨/×¢×“×›×Ÿ ×œ-DB
    return ("", 204)

PUBLIC_HOST
×‘×›×œ ××§×•× ×©××™×™×¦×¨ URL ×œ×”×©××¢×ª MP3 â€“ ×§×— ×Ö¾PUBLIC_HOST. ×× ×—×¡×¨, ××œ ×ª×–×¨×•×§ ×—×¨×™×’×”â€”×¨×§ ×œ×•×’ ××–×”×¨×” + fallback.

â¸»

5) TTS â€” Google Wavenet + Fallback gTTS

server/hebrew_tts_enhanced.py

import os, logging
from typing import Optional
from google.cloud import texttospeech
logger = logging.getLogger(__name__)
try:
    from gtts import gTTS
    GTTS_AVAILABLE = True
except Exception:
    GTTS_AVAILABLE = False

def create_hebrew_audio(text: str, call_sid: str = "", voice_name="he-IL-Wavenet-A") -> Optional[str]:
    try:
        client = texttospeech.TextToSpeechClient()
        input_text = texttospeech.SynthesisInput(text=text)
        voice = texttospeech.VoiceSelectionParams(language_code="he-IL", name=voice_name)
        audio_config = texttospeech.AudioConfig(audio_encoding=texttospeech.AudioEncoding.MP3)
        response = client.synthesize_speech(input=input_text, voice=voice, audio_config=audio_config)
        out_dir = "static/voice_responses"; os.makedirs(out_dir, exist_ok=True)
        path = os.path.join(out_dir, f"response_{(call_sid or 'greeting')}.mp3")
        with open(path, "wb") as f: f.write(response.audio_content)
        return path
    except Exception as e:
        logger.error("GCP TTS failed; fallback to gTTS: %s", e)
        if GTTS_AVAILABLE:
            out_dir = "static/voice_responses"; os.makedirs(out_dir, exist_ok=True)
            path = os.path.join(out_dir, f"response_{(call_sid or 'greeting')}.mp3")
            gTTS(text=text, lang="he").save(path)
            return path
        return None


â¸»

6) ×©×›×‘×ª WhatsApp ×××•×—×“×ª (Baileys/Twilio) ×¢× ××ª×’ ENV

server/whatsapp_providers.py

import os, json, time
from pathlib import Path

class WhatsAppProvider:
    def send_text(self, to: str, text: str) -> dict: raise NotImplementedError
    def send_media(self, to: str, media_url: str, caption: str = "") -> dict: raise NotImplementedError
    def send_template(self, to: str, template: str, lang: str = "he", variables=None) -> dict: raise NotImplementedError

class BaileysProvider(WhatsAppProvider):
    def __init__(self, base_dir="baileys_auth_info"):
        self.queue = Path(base_dir) / "message_queue.json"
        self.queue.parent.mkdir(parents=True, exist_ok=True)
        if not self.queue.exists(): self.queue.write_text("[]", encoding="utf-8")
    def _enqueue(self, payload):
        data = json.loads(self.queue.read_text("utf-8"))
        data.append({**payload, "ts": int(time.time())})
        self.queue.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        return {"provider":"baileys","status":"queued"}
    def send_text(self, to, text):
        return self._enqueue({"to": to, "message": text, "type":"text"})
    def send_media(self, to, media_url, caption=""):
        return self._enqueue({"to": to, "media_url": media_url, "caption": caption, "type":"media"})
    def send_template(self, to, template, lang="he", variables=None):
        # Baileys ×œ× ×× ×”×œ ×ª×‘× ×™×•×ª ×¨×©××™×•×ªâ€”× ×™×§×— ×›×˜×§×¡×˜ ××•×¨×›×‘
        text = template if not variables else template.format(*variables)
        return self._enqueue({"to": to, "message": text, "type":"text"})

class TwilioProvider(WhatsAppProvider):
    def __init__(self):
        from twilio.rest import Client
        self.client = Client(os.getenv("TWILIO_ACCOUNT_SID"), os.getenv("TWILIO_AUTH_TOKEN"))
        self.from_num = os.getenv("TWILIO_WA_FROM")
    def _to_whatsapp(self, to):
        return f"whatsapp:{to}" if not str(to).startswith("whatsapp:") else to
    def send_text(self, to, text):
        msg = self.client.messages.create(from_=self.from_num, to=self._to_whatsapp(to), body=text)
        return {"provider":"twilio","status":msg.status,"sid":msg.sid}
    def send_media(self, to, media_url, caption=""):
        msg = self.client.messages.create(from_=self.from_num, to=self._to_whatsapp(to), body=caption or None, media_url=[media_url])
        return {"provider":"twilio","status":msg.status,"sid":msg.sid}
    def send_template(self, to, template, lang="he", variables=None):
        # ×‘×˜×•×•×™×œ×™×•/×•×•××˜×¡××¤: ×ª×‘× ×™×•×ª ×××•×©×¨×•×ª ×‘×œ×‘×“ ×œ×©×™×—×•×ª ×™×–×•××•×ª. ×›××Ÿ × ×‘×¦×¢ ×”×—×œ×¤×” ×‘×¡×™×¡×™×ª.
        body = template if not variables else template.format(*variables)
        msg = self.client.messages.create(from_=self.from_num, to=self._to_whatsapp(to), body=body)
        return {"provider":"twilio","status":msg.status,"sid":msg.sid}

def get_provider():
    return TwilioProvider() if os.getenv("WHATSAPP_PROVIDER","baileys").lower()=="twilio" else BaileysProvider()


â¸»

7) WhatsApp API â€” ×©×œ×™×—×”/×¡×˜×˜×•×¡/×•×•×‘×”×•×§×™× (×›×•×œ×œ Twilio)

API ×××•×—×“ ×œ×œ×§×•×— (×›×‘×¨ ××¦×œ×š): server/api_whatsapp_improved.py
×¢×“×›×Ÿ ×œ×”×©×ª××© ×‘×¡×¤×§ ×”×××•×—×“ ×•×œ×©××•×¨ ×œ-DB:

from flask import Blueprint, request, jsonify
from datetime import datetime
from server.whatsapp_providers import get_provider
from server.db import db
from server.models_sql import WhatsAppMessage

whatsapp_bp = Blueprint("whatsapp_improved", __name__, url_prefix="/api/whatsapp")

@whatsapp_bp.get("/provider")
def provider_info():
    from os import getenv
    return jsonify({"provider": getenv("WHATSAPP_PROVIDER","baileys")})

@whatsapp_bp.get("/status")
def status():
    # Baileys: ×§×¨× ×§×•×‘×¥ status.json ×× ×§×™×™×; Twilio: ×‘×“×™×§×” ×‘×¡×™×¡×™×ª ×©×œ ×§×¨×“× ×¦×™××œ×¡
    try:
        import os, json
        if os.getenv("WHATSAPP_PROVIDER","baileys") == "baileys":
            p = "baileys_auth_info/status.json"
            if os.path.exists(p): 
                return jsonify(json.loads(open(p,"r",encoding="utf-8").read()))
            return jsonify({"connected": False, "qr_available": True})
        else:
            # ×œ×˜×•×•×™×œ×™×• × ×—×–×™×¨ ×¡×˜×˜×•×¡ "××—×•×‘×¨" ×× ×™×© ×§×¨×“× ×¦×™××œ×¡
            ok = all([os.getenv("TWILIO_ACCOUNT_SID"), os.getenv("TWILIO_AUTH_TOKEN"), os.getenv("TWILIO_WA_FROM")])
            return jsonify({"connected": bool(ok), "qr_available": False})
    except Exception as e:
        return jsonify({"connected": False, "error": str(e)}), 200

@whatsapp_bp.get("/qr")
def qr():
    # ×¨×œ×•×•× ×˜×™ ×¨×§ ×œ×‘×™×™×œ×™×¡
    import os
    if os.getenv("WHATSAPP_PROVIDER","baileys") != "baileys":
        return jsonify({"error":"qr not applicable for this provider"}), 400
    p = "baileys_auth_info/qr_code.txt"
    if not os.path.exists(p):
        return jsonify({"qr": None, "note":"not available"}), 200
    return jsonify({"qr": open(p,"r",encoding="utf-8").read()})

@whatsapp_bp.post("/send")
def send_message():
    payload = request.get_json(force=True)
    to = payload.get("to"); text = payload.get("text")
    if not to or not text:
        return jsonify({"error":"missing to/text"}), 400
    res = get_provider().send_text(to, text)
    msg = WhatsAppMessage(business_id=1, to_number=to, direction="out", body=text,
                          status=res.get("status","queued"),
                          provider=res.get("provider","unknown"),
                          provider_message_id=res.get("sid"))
    db.session.add(msg); db.session.commit()
    return jsonify({"ok":True, **res})

@whatsapp_bp.post("/send_media")
def send_media():
    payload = request.get_json(force=True)
    to = payload.get("to"); media_url = payload.get("media_url"); caption = payload.get("caption","")
    if not to or not media_url:
        return jsonify({"error":"missing to/media_url"}), 400
    res = get_provider().send_media(to, media_url, caption)
    msg = WhatsAppMessage(business_id=1, to_number=to, direction="out", body=caption,
                          message_type="media", media_url=media_url,
                          status=res.get("status","queued"),
                          provider=res.get("provider","unknown"),
                          provider_message_id=res.get("sid"))
    db.session.add(msg); db.session.commit()
    return jsonify({"ok":True, **res})

@whatsapp_bp.post("/send_template")
def send_template():
    payload = request.get_json(force=True)
    to = payload.get("to"); template = payload.get("template"); lang = payload.get("lang","he")
    variables = payload.get("variables", [])
    if not to or not template:
        return jsonify({"error":"missing to/template"}), 400
    res = get_provider().send_template(to, template, lang, variables)
    msg = WhatsAppMessage(business_id=1, to_number=to, direction="out", body=str({"template":template,"variables":variables}),
                          message_type="template",
                          status=res.get("status","queued"),
                          provider=res.get("provider","unknown"),
                          provider_message_id=res.get("sid"))
    db.session.add(msg); db.session.commit()
    return jsonify({"ok":True, **res})

×•×•×‘×”×•×§ ×œ-Twilio WhatsApp â€” ×”×•×“×¢×•×ª × ×›× ×¡×•×ª + ××“×™×” × ×›× ×¡×ª
server/routes_whatsapp_twilio.py

from flask import Blueprint, request, jsonify
from datetime import datetime
from server.twilio_security import require_twilio_signature
from server.db import db
from server.models_sql import WhatsAppMessage

wa_twilio_bp = Blueprint("wa_twilio", __name__, url_prefix="/webhook/whatsapp")

@wa_twilio_bp.post("/inbound")
@require_twilio_signature
def inbound():
    from_number = request.form.get("From")          # 'whatsapp:+9725...'
    body = request.form.get("Body","")
    num_media = int(request.form.get("NumMedia", "0") or 0)
    media_url = request.form.get("MediaUrl0") if num_media > 0 else None

    msg = WhatsAppMessage(
        business_id=1,
        to_number=from_number,
        direction="in",
        body=body,
        message_type="media" if media_url else "text",
        media_url=media_url,
        status="received",
        provider="twilio"
    )
    db.session.add(msg); db.session.commit()
    return jsonify({"ok":True})

×•×•×‘×”×•×§ ×¡×˜×˜×•×¡×™× ×œ-Twilio WhatsApp â€” ×¢×“×›×•×Ÿ delivered/read/failed
server/routes_whatsapp_twilio.py (×”××©×š):

@wa_twilio_bp.post("/status")
@require_twilio_signature
def status():
    sid = request.form.get("MessageSid")
    status = request.form.get("MessageStatus")  # queued/sent/delivered/read/failed/undelivered
    now = datetime.utcnow()
    q = WhatsAppMessage.query.filter_by(provider_message_id=sid).first()
    if q:
        q.status = status
        if status == "delivered": q.delivered_at = now
        if status == "read": q.read_at = now
        db.session.commit()
    return ("", 204)

×‘-Twilio Console ×”×’×“×¨:
	â€¢	Incoming Messages Webhook (WhatsApp) â†’ POST https://<PUBLIC_HOST>/webhook/whatsapp/inbound
	â€¢	Status Callback URL ×‘×©×™×’×•×¨ ×”×•×“×¢×•×ª (× ×™×ª×Ÿ ×œ×©×œ×•×— ×‘×¤×¨Ö¾×”×•×“×¢×” ××• ×œ×”×’×“×™×¨ ×‘×¤×¨×•×¤×™×œ) â†’ POST https://<PUBLIC_HOST>/webhook/whatsapp/status

â¸»

8) ×¨×™×©×•× Blueprints ××—×•×“

server/app_factory.py:

def create_app():
    app = Flask(__name__)
    # ... ×§×•× ×¤×™×’/DB/×•×›×•'

    from server.routes_twilio import twilio_bp
    app.register_blueprint(twilio_bp)

    from server.api_whatsapp_improved import whatsapp_bp
    app.register_blueprint(whatsapp_bp)

    from server.routes_whatsapp_twilio import wa_twilio_bp
    app.register_blueprint(wa_twilio_bp)

    # errors / health / crm / auth ...
    return app

×•×“× ×©××™×Ÿ ×¨×™×©×•× × ×•×¡×£/×›×¤×™×œ×•×ª ×©×œ ×•×•××˜×¡××¤.

â¸»

9) CORS, Rate-limit, ×œ×•×’×™× ×¢× Request-ID
	â€¢	×”×’×“×¨ CORS ×œ-CORS_ORIGINS ×‘×œ×‘×“.
	â€¢	Rate-limit ×œ××¡×œ×•×œ×™ /webhook/* ×•Ö¾/api/whatsapp/send* (×œ××©×œ 20/min).
	â€¢	×”×•×¡×£ Request-ID ×œ×¤× ×™ ×•××—×¨×™ ×‘×§×©×” (X-Request-ID) ×•×¨×©×•× ×‘×œ×•×’×™×.

(×× ××™×Ÿ ×œ×š ×§×•×“ ××•×›×Ÿ â€“ ×–×”×” ×œ××” ×©× ×©×œ×— ×§×•×“×; ×©××•×¨ ×§×¦×¨ ×›××Ÿ ×œ×˜×•×‘×ª ×”×ª××¦××•×ª.)

â¸»

10) ×©×™×¨×•×ª Baileys (Node) ×•×”×¤×¢×œ×”

services/baileys/index.js (×’×©×¨ ×ª×•×¨ â€“ ×§×•×¤×™-×¤×™×™×¡×˜):

import makeWASocket, { useMultiFileAuthState, Browsers } from '@whiskeysockets/baileys'
import fs from 'fs'
import path from 'path'

const authDir = path.resolve(process.cwd(), '../../baileys_auth_info')
if (!fs.existsSync(authDir)) fs.mkdirSync(authDir, { recursive: true })
const statusFile = path.join(authDir, 'status.json')
const qrFile = path.join(authDir, 'qr_code.txt')
const queueFile = path.join(authDir, 'message_queue.json')
const writeJson = (p, o) => fs.writeFileSync(p, JSON.stringify(o, null, 2))

async function start(){
  const { state, saveCreds } = await useMultiFileAuthState(authDir)
  const sock = makeWASocket({ auth: state, printQRInTerminal: true, browser: Browsers.macOS('AgentLocator') })
  sock.ev.on('creds.update', saveCreds)
  sock.ev.on('connection.update', ({ connection, qr, lastDisconnect })=>{
    if (qr) fs.writeFileSync(qrFile, qr)
    writeJson(statusFile, { connected: connection === 'open', qr_available: !!qr, last_disconnect: lastDisconnect ? String(lastDisconnect.error) : null, ts: new Date().toISOString() })
  })
  setInterval(async ()=>{
    try{
      if (!fs.existsSync(queueFile)) return
      const q = JSON.parse(fs.readFileSync(queueFile, 'utf8'))
      if (!Array.isArray(q) || !q.length) return
      const msg = q.shift()
      if (!msg?.to) return
      if (msg.type === 'media' && msg.media_url) {
        await sock.sendMessage(msg.to, { image: { url: msg.media_url }, caption: msg.caption || '' })
      } else {
        await sock.sendMessage(msg.to, { text: msg.message })
      }
      fs.writeFileSync(queueFile, JSON.stringify(q, null, 2))
    }catch(e){ console.error('Queue error', e) }
  }, 2000)
}
start().catch(console.error)

×”×¨×¦×”:

cd services/baileys
npm i
node index.js

Procfile (××•×¤×¦×™×•× ×œ×™):

web: python -m server.main
worker: node services/baileys/index.js


â¸»

11) ×˜×¡×˜×™× (pytest + curl)

tests/test_smoke.py

import os
os.environ["FLASK_ENV"] = "testing"
os.environ["DATABASE_URL"] = "sqlite:///:memory:"
os.environ["WHATSAPP_PROVIDER"] = "baileys"

from server.app import app

def test_health():
    with app.test_client() as c:
        r = c.get("/health")
        assert r.status_code in (200, 204)

def test_twilio_incoming():
    with app.test_client() as c:
        r = c.post("/webhook/incoming_call")
        assert r.status_code == 200
        assert b"<Response" in r.data

def test_whatsapp_status():
    with app.test_client() as c:
        r = c.get("/api/whatsapp/status")
        assert r.status_code == 200

×‘×“×™×§×•×ª ×™×“× ×™×•×ª (curl):

# Twilio Voice
curl -X POST http://localhost:5000/webhook/incoming_call
curl -X POST http://localhost:5000/webhook/handle_recording -d RecordingUrl=https://api.twilio.com/2010-04-01/Accounts/ACxxx/Recordings/RExxx -d CallSid=CA_TEST_1
curl -X POST http://localhost:5000/webhook/call_status -d CallSid=CA_TEST_1 -d CallStatus=completed

# WhatsApp â€“ ×¡×˜×˜×•×¡ / QR
curl http://localhost:5000/api/whatsapp/status
curl http://localhost:5000/api/whatsapp/qr

# WhatsApp â€“ ×©×œ×™×—×” (××•×ª×’ ××•×˜×•××˜×™×ª ×œ×¤×™ WHATSAPP_PROVIDER)
curl -X POST http://localhost:5000/api/whatsapp/send -H "Content-Type: application/json" -d '{"to":"+9725XXXXXXX","text":"×‘×“×™×§×ª AgentLocator"}'

# ×©×œ×™×—×ª ××“×™×”
curl -X POST http://localhost:5000/api/whatsapp/send_media -H "Content-Type: application/json" -d '{"to":"+9725XXXXXXX","media_url":"https://example.com/pic.jpg","caption":"×ª××•× ×”"}'

# ×©×œ×™×—×ª "×ª×‘× ×™×ª" (Twilio: ×ª×‘× ×™×ª ×××•×©×¨×ª; ×›××Ÿ ×˜×§×¡×˜ ×¢× variables)
curl -X POST http://localhost:5000/api/whatsapp/send_template -H "Content-Type: application/json" -d '{"to":"+9725XXXXXXX","template":"×©×œ×•× {0}, ×”×”×¦×¢×” ×©×œ×š ××•×›× ×”.","variables":["×“× ×™"]}'

# Twilio WhatsApp â€“ ×•×•×‘×”×•×§ × ×›× ×¡ (×¡×™××•×œ×¦×™×” ×œ×œ× ×—×ª×™××” ×‘××¦×‘ TESTING)
curl -X POST http://localhost:5000/webhook/whatsapp/inbound -d 'From=whatsapp:+9725XXXXXXX' -d 'Body=×”×™×™' -d 'NumMedia=0'

# Twilio WhatsApp â€“ ×¡×˜×˜×•×¡ ×”×•×“×¢×”
curl -X POST http://localhost:5000/webhook/whatsapp/status -d 'MessageSid=SMxxxx' -d 'MessageStatus=delivered'

×‘××¦×‘ ×¤×¨×•×“×§×©×Ÿ â€” ×—×ª×™××•×ª Twilio × ×“×¨×©×•×ª ×¢×œ /webhook/whatsapp/* ×›××• ×¢×œ ××¡×œ×•×œ×™ ×”×§×•×œ.

â¸»

12) Definition of Done (×§×¨×™×˜×¨×™×•× ×™ ×§×‘×œ×”)

Twilio Voice
	â€¢	×›×œ ××¡×œ×•×œ×™ /webhook/incoming_call, /webhook/handle_recording, /webhook/call_status ××•×’× ×™× ×‘-@require_twilio_signature.
	â€¢	handle_recording ××—×–×™×¨ TwiML ××™×™×“×™×ª; ×”×•×¨×“×”/×ª××œ×•×œ ×‘×¨×§×¢; ×¢×“×›×•×Ÿ CallLog ×‘-DB.
	â€¢	×¤×¨××˜×¨ PUBLIC_HOST ×§×™×™× ×•×××¤×©×¨ ×”×©××¢×ª MP3 ×—×™×¦×•× ×™×ª (××• fallback ×‘×˜×•×— ×¢× ×œ×•×’ ××–×”×¨×”).

WhatsApp (Unified)
	â€¢	WHATSAPP_PROVIDER ××—×œ×™×£ ×‘×–××Ÿ ×¨×™×¦×” ×‘×™×Ÿ baileys â†” twilio.
	â€¢	/api/whatsapp/status ×•Ö¾/api/whatsapp/qr ×¢×•×‘×“×™× ×œ×¤×™ ×¡×¤×§.
	â€¢	/api/whatsapp/send, /send_media, /send_template ×¤×•×¢×œ×™×, ××ª×¢×“×™× ×œ-DB.

Twilio WhatsApp
	â€¢	×•×•×‘×”×•×§ × ×›× ×¡: /webhook/whatsapp/inbound (×¢× ×—×ª×™××”) ×©×•××¨ ×”×•×“×¢×•×ª × ×›× ×¡×•×ª (×›×•×œ×œ ××“×™×”).
	â€¢	×•×•×‘×”×•×§ ×¡×˜×˜×•×¡: /webhook/whatsapp/status ××¢×“×›×Ÿ ×¡×˜×˜×•×¡×™× (sent/delivered/read/failed) ×•×©×“×•×ª ×–××Ÿ.
	â€¢	×©×œ×™×—×” ×“×¨×š Twilio ××—×–×™×¨×” SID, × ×©××¨ ×‘-provider_message_id, ×¡×˜×˜×•×¡×™× ××ª×¢×“×›× ×™×.

DB/ORM
	â€¢	×˜×‘×œ××•×ª Business/Customer/CallLog/WhatsAppMessage ×§×™×™××•×ª ×•×¤×•×¢×œ×•×ª.
	â€¢	×˜×¨× ×–×§×¦×™×•×ª/Commit ×‘×›×œ ×–×¨×™××”; ××™× ×“×§×¡×™× ×‘×©×“×•×ª ×—×™×¤×•×© (phone, call_sid, provider_message_id).

××‘×˜×—×”/××•×¤×¨×¦×™×”
	â€¢	CORS ×œ×¤×™ CORS_ORIGINS ×‘×œ×‘×“.
	â€¢	Rate-limit ×œ××¡×œ×•×œ×™× ×¨×’×™×©×™×.
	â€¢	×œ×•×’×™× ×¢× X-Request-ID.

× ×™×§×™×•×Ÿ
	â€¢	××™×Ÿ ×§×‘×¦×™ â€œ××•×§×™â€ ×¨×©×•××™×.
	â€¢	Frontend ×™×—×™×“ (client/), Build ×ª×§×™×Ÿ, ××•×’×© ×Ö¾Flask ××• ×¡×˜×˜×™ ×‘× ×¤×¨×“.

×‘×“×™×§×•×ª
	â€¢	pytest ×™×¨×•×§.
	â€¢	curl smoke ×¢×•×‘×¨ ×œ×›×œ ××¡×œ×•×œ×™ ×§×•×œ/×•×•×¦××¤.

â¸»

×”×¢×¨×•×ª ×©×™××•×©×™×•×ª (Twilio WhatsApp)
	â€¢	×”×•×“×¢×•×ª â€œ×™×–×•××•×ªâ€ ××—×™×™×‘×•×ª ×ª×‘× ×™×•×ª ×××•×©×¨×•×ª (HSM). ×‘×§×•×“ ×”×¨××™×ª×™ send_template ×›×˜×§×¡×˜ ×¢× format; ×‘×¤×•×¢×œ, ×”×©×ª××© ×‘×ª×‘× ×™×•×ª ×©××•×©×¨×• ×‘×—×©×‘×•×Ÿ ×©×œ×š.
	â€¢	×”×•×“×¢×•×ª â€œ×ª×’×•×‘×” ×‘×ª×•×š 24hâ€ ×™×›×•×œ×•×ª ×œ×”×™×•×ª ×—×•×¤×©×™×•×ª (×˜×§×¡×˜/××“×™×”).

â¸»

×›×©×ª×¡×™×™× ××ª ×©×œ×‘×™× 1â€“11, ×ª×’×™×“ â€œ×‘×•×¦×¢â€ â€” ×•××– × ×¢×‘×•×¨ ×œ×©×›×‘×ª UI ××œ××” (RTL, ×¤×•× ×˜ Assistant, ×”×™×¨×¨×›×™×”, ×¢×™×¦×•×‘ ×˜×‘×œ××•×ª, ×”×¨×©××•×ª ×œ×¤×™ ×©×™×¨×•×ª/×ª×¤×§×™×“) ×¢× ××¤×¨×˜ ×•×™×–×•××œ×™ ××“×•×™×§ ×œ×›×œ ×“×£.