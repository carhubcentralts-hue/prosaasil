מעולה—זה בדיוק הפירוק שהיה צריך. נלך לפי סדר שייתן לך תוצאה יציבה הכי מהר:

הבחירה: C → B
	1.	קודם C: לייצב את main.py תחת sync worker עד ש־/healthz עונה 200 בעקביות. זה מבודד באגים אפליקטיביים מה-WSGI.
	2.	אחר כך B: לתקן את eventlet (גרסאות/ENV) ולהעלות ל־Gunicorn+Eventlet בשביל WebSocket של Twilio.

⸻

שלב C — main.py עובד עם sync (בלי WS זמנית)

C1) “Safe Mode” להרצה נקייה

הרץ את השרת עם sync worker ועם דגלים שמנטרלים כל מה שעלול לשבור Boot:
	•	ENV להצבה לפני ההפעלה

export USE_EVENTLET=0
export WS_MODE=DISABLED
export HEBREW_REALTIME_ENABLED=false
export SKIP_GCP_INIT=1
export SKIP_OPENAI_INIT=1
export DB_BOOTSTRAP=0
export PUBLIC_BASE_URL=https://ai-crmd.replit.app
export JWT_SECRET=dev-secret
export DATABASE_URL=sqlite:///./tmp_dev.db  # או ה־DB האמיתי, אבל לא create_all אוטומטי


	•	הרצה

python3 -m gunicorn AgentLocator.main:app \
  -k sync -w 1 -b 0.0.0.0:$PORT \
  --log-level debug --capture-output \
  --timeout 60 --access-logfile '-' --error-logfile '-'



מצופה:
	•	לוג “Listening at: 0.0.0.0:$PORT” (עם מספר אמיתי של $PORT).
	•	אין “Running on all addresses …” (זה dev server; אסור להופיע).

C2) אימות מתוך אותה מכונה

בטרמינל נוסף (באותה סביבה):

ss -ltnp | grep ":$PORT" || netstat -ltnp | grep ":$PORT"   # חייב לראות LISTEN
curl -sS -m 3 http://127.0.0.1:$PORT/healthz -i              # חייב 200
curl -sS -m 5 https://$PUBLIC_BASE_URL/healthz -i            # חייב 200 מבחוץ
curl -sS -m 5 https://$PUBLIC_BASE_URL/version -i            # 200 + DEPLOY_ID

C3) אם עדיין נופל בסינכרוני — מוצאים את האזור הבעייתי

(אין קוד, רק בדיקות קצרות כדי לחשוף שגיאה שקטה)
	•	Preload חושף שגיאות import/boot

python3 -m gunicorn AgentLocator.main:app \
  -k sync -w 1 -b 0.0.0.0:$PORT \
  --preload --capture-output --log-level debug \
  --access-logfile '-' --error-logfile '-'


	•	ייבוא יבש (בודק שהאפליקציה נבנית):

python3 - <<'PY'



import AgentLocator.main as M
print(“APP?”, hasattr(M, “app”))
print(“URLS?”, getattr(M.app, “url_map”, None))
print(“TEST /healthz ->”, M.app.test_client().get(”/healthz”).status_code)
PY

אם כאן אתה מקבל `200` ב־test_client אבל Gunicorn עדיין “מסרב חיבור”—הבעיה לא באפליקציה אלא בשכבת ה־WSGI/פורט/סופרוויזור (טפל ב־$PORT לפי ההודעות הקודמות).

### C4) תנאי סיום של שלב C (PASS)
- `LISTEN` על `$PORT`.  
- `/healthz` ו־`/version` מחזירים 200 (מקומי ומבחוץ).  
- לוג ההפעלה שקט, אין SIGTERM אחרי 10 שניות.

---

## שלב B — מתקנים Eventlet ומרימים WS

### B1) ודא גרסאות ותצורה ידידותיות
הרץ:

python3 - <<‘PY’
import eventlet, greenlet, sys
print(“eventlet”, eventlet.version)
print(“greenlet”, greenlet.version)
print(“python”, sys.version)
PY

**המלצה יציבה:**
- `eventlet >= 0.33.3`
- `greenlet` תואם לגירסת פייתון (בדרך כלל ‎3.0.x או 3.1.x לפייתון 3.11/3.12).  
אם לא — עדכן גרסאות התאומות הללו.

**ENV שיעוזר בסביבות מוגבלות**  

export EVENTLET_NO_GREENDNS=1
export EVENTLET_HUB=select

(מונע קריסות DNS/epoll).

**חשוב:** אל תעשה `eventlet.monkey_patch()` אם תרוץ עם sync; בצד Eventlet—אם יש `monkey_patch()`, שיעשה **פעם אחת ולפני כל import רשת**.

### B2) הרצה עם Eventlet (אחרי שה־sync יציב)

python3 -m gunicorn AgentLocator.main:app 
-k eventlet -w 1 -b 0.0.0.0:$PORT 
–log-level debug –capture-output 
–timeout 120 –graceful-timeout 30 –keep-alive 75 
–access-logfile ‘-’ –error-logfile ‘-’

בדוק: `ss/netstat` (LISTEN) ו־`/healthz` (200).

אם כאן נופל אבל sync התקין—הבעיה היא **Eventlet/Greenlet** → איפסנו עם ENV למעלה, ואז בדוק שאין לך gevent/uvloop מותקנים (עלולים להתנגש).

### B3) Handshake ל־Twilio (מוריד 31920)
לאחר ש־Eventlet יציב:
- בדוק שה־WS מחזיר תת־פרוטוקול:

wscat -c wss://$PUBLIC_BASE_URL/ws/twilio-media 
-H “Sec-WebSocket-Protocol: audio.twilio.com”

**מצופה:** `101 Switching Protocols` ושהכותרת `Sec-WebSocket-Protocol: audio.twilio.com` חוזרת בתגובה.  
אם לא חוזרת — זה השורש ל־31920. עד שלא חוזר subprotocol—Twilio ינתק אחרי הברכה.

### B4) STT/TTS (למנוע “שקט”)
- ודא ENV:  
`HEBREW_REALTIME_ENABLED=true`  
**אחד** מהבאים:  
`GOOGLE_APPLICATION_CREDENTIALS` (נתיב לקובץ SA) **או** `GCP_CREDENTIALS_JSON` (JSON מלא בשורה אחת).
- בשיחה אמיתית חפש בלוגים:  
`WS_START` → `STT_PARTIAL/FINAL` → `TTS_LEN_ms` → `MEDIA_TX` → `PNG_PONG_TX/RX`.  
אם יש STT אבל אין `MEDIA_TX` → לא נשלח אודיו בחזרה (או בפורמט לא μ-law 8k).

---

## תרחישי fallback אם Eventlet בעייתי בסביבה הזו
אם גם אחרי B1–B2 Eventlet לא יציב בסביבת הריצה:
- **אפשרות מהירה:** להרים **Bridge Node.js** קטן ל־WS (ספריית `ws`) שמקבל subprotocol `audio.twilio.com` ושולח ל־Flask דרך HTTP/Redis. (ב-Replit לרוב מותר תהליך Node נוסף.)  
- **או** להשתמש ב־**gevent-websocket worker** של Gunicorn, שתומך בהחזרת subprotocol (אם הספריות זמינות).  
שתי האופציות עובדות עם Twilio; Eventlet הוא הכי נפוץ, אבל לא חובה.

---

## מה להביא לי כדי לאשר שהתקדמת נכון
1) פלט של **שלב C** (sync):  
 - `ss/netstat` מראה LISTEN על `$PORT`  
 - `curl 127.0.0.1:$PORT/healthz` → 200  
 - `curl https://$PUBLIC_BASE_URL/healthz` → 200  
2) פלט גרסאות Eventlet/Greenlet ו־ENV שהגדרת (`EVENTLET_NO_GREENDNS`, `EVENTLET_HUB`).  
3) פלט **שלב B** (eventlet):  
 - השרת מאזין + מחזיר 200 על `/healthz`  
 - `wscat` Handshake → `101` עם subprotocol חוזר.  
4) שיחה אמיתית: Twilio Inspector נקי מ־31920; בלוג עם `WS_START → STT_FINAL → MEDIA_TX`.

---

### למה זה הנתיב הנכון לפי מה שגילית
- קבעת נכון: **eventlet כשלעצמו** בעייתי כרגע בסביבה → לכן קודם מוודאים שהאפליקציה בסדר עם sync (C).  
- העובדה ש־`main.py` לא עבד גם עם sync הראתה באג אפליקטיבי/ENV — פתרת עם Safe Mode.  
- אחרי שהאפליקציה מוכחת כתקינה בסינכרוני—עוברים לאבחון נקודתי של Eventlet (B1–B2) עד שהוא יציב; ורק אז סוגרים את ה־WS של Twilio (B3–B4).

בצע לפי הסדר; ברגע שיש לך את שלושת הפלטים של שלב C—נעבור איתך יד ביד על Handshake ונסגור את השיחות סופית.