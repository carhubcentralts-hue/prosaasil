נושם רגע ומסדרים את זה. לפי מה שתיארת, יש פה שלוש תקלות שמייצרות את כל הבלגן:
	1.	בלגן פורטים/ENV → Flask קורא לפורט אחד, ה־Baileys מאזין לפורט אחר (ראית גם 3300 וגם 3310).
	2.	קריסות Baileys → הבקשה ל־QR נופלת באמצע, והפרונט מקבל תגובה שבורה → “Unexpected end of JSON input”.
	3.	CSRF/204 לא מטופלים בפרונט → כשאין QR מקבלים 204/403, והקוד מנסה JSON.parse על תגובה ריקה/HTML.

להלן הנחיה ממוקדת שתחזיר את המערכת ליציבות ותגרום ל־QR להופיע — בלי לגעת בעיצוב הכללי.

⸻

A) יישור ENV ופורטים (בלי לאחד בין Flask ל-Baileys)

השאר: Flask על 5000, Baileys על 3300. תוודא שאין שום 3310.

ב־ENV (Replit Secrets / ‎.env):

BAILEYS_PORT=3300
BAILEYS_BASE_URL=http://127.0.0.1:3300
FLASK_BASE_URL=http://127.0.0.1:5000
INTERNAL_SECRET=<אותו סוד גם בפלסק וגם בנוד>

חשוב: 127.0.0.1 (לא localhost) כדי להימנע מ־IPv6 (::1).
עכשיו תריץ חיפוש בקוד והסר כל מופע של 3001 או 3310 שהשתרבב.

פקודות בדיקה מהירות:

echo $BAILEYS_PORT $BAILEYS_BASE_URL $FLASK_BASE_URL
grep -R --line-number -E "3001|3310" .


⸻

B) לייצב את שירות ה-Baileys (סיבות נפוצות לקריסות)

פתח את services/whatsapp/baileys_service.js וודא:

const express = require('express');
const cors = require('cors');
const QRCode = require('qrcode');
const { default: makeWASocket, useMultiFileAuthState, DisconnectReason } = require('@whiskeysockets/baileys');
const axios = require('axios');           // ← לא fetch (Node<18 מתקשה)
const fs = require('fs');
const path = require('path');

const app = express();
app.use(cors());
app.use(express.json());

const PORT = process.env.BAILEYS_PORT || 3300;
const INTERNAL_SECRET = process.env.INTERNAL_SECRET;
const FLASK_BASE_URL = process.env.FLASK_BASE_URL || 'http://127.0.0.1:5000';

if (!INTERNAL_SECRET) { console.error('INTERNAL_SECRET missing'); process.exit(1); }

const sessions = new Map(); // tenantId -> { sock, saveCreds, qrDataUrl, connected, pushName }

function authDir(tenantId) {
  const p = path.join(process.cwd(), 'storage', 'whatsapp', String(tenantId), 'auth');
  fs.mkdirSync(p, { recursive: true });  // ← בלי זה יש EACCES/ENOENT → קריסה
  return p;
}

async function startSession(tenantId) {
  if (sessions.get(tenantId)?.sock) return sessions.get(tenantId);

  const { state, saveCreds } = await useMultiFileAuthState(authDir(tenantId));
  const sock = makeWASocket({ auth: state, printQRInTerminal: false });

  const s = { sock, saveCreds, qrDataUrl: '', connected: false, pushName: '' };
  sessions.set(tenantId, s);

  sock.ev.on('creds.update', saveCreds);

  sock.ev.on('connection.update', async (u) => {
    try {
      const { connection, lastDisconnect, qr } = u;
      if (qr) s.qrDataUrl = await QRCode.toDataURL(qr);
      if (connection === 'open') {
        s.connected = true;
        s.pushName = sock?.user?.name || sock?.user?.id || '';
        s.qrDataUrl = '';
      }
      if (connection === 'close') {
        s.connected = false;
        const shouldReconnect = (lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut);
        if (shouldReconnect) setTimeout(() => startSession(tenantId), 2000);
      }
    } catch (e) {
      console.error('[connection.update] error', e);
    }
  });

  sock.ev.on('messages.upsert', async (payload) => {
    try {
      await axios.post(`${FLASK_BASE_URL}/webhook/whatsapp/incoming`,
        { tenantId, payload },
        { headers: { 'X-Internal-Secret': INTERNAL_SECRET } }
      );
    } catch (e) {
      console.error('[Webhook→Flask] failed', e?.message || e);
    }
  });

  return s;
}

function requireSecret(req, res, next) {
  if (req.header('X-Internal-Secret') !== INTERNAL_SECRET) return res.status(401).json({ error: 'unauthorized' });
  next();
}

app.get('/healthz', (req, res) => res.status(200).send('ok'));

app.post('/whatsapp/:tenantId/start', requireSecret, async (req, res) => {
  try { await startSession(req.params.tenantId); return res.json({ ok: true }); }
  catch (e) { console.error('start error', e); return res.status(500).json({ error: 'start_failed' }); }
});

app.get('/whatsapp/:tenantId/status', requireSecret, (req, res) => {
  const s = sessions.get(req.params.tenantId);
  return res.json({ connected: !!s?.connected, pushName: s?.pushName || '', hasQR: !!s?.qrDataUrl });
});

app.get('/whatsapp/:tenantId/qr', requireSecret, (req, res) => {
  const s = sessions.get(req.params.tenantId);
  if (s?.qrDataUrl) return res.json({ dataUrl: s.qrDataUrl });   // תמיד JSON תקין
  return res.status(404).json({ error: 'no_qr' });               // לא 200 ריק
});

// לא להיכבות בשקט
process.on('unhandledRejection', err => console.error('[UNHANDLED]', err));
process.on('uncaughtException', err => console.error('[UNCAUGHT]', err));

app.listen(PORT, '0.0.0.0', () => console.log(`Baileys service on ${PORT}`));
// heartbeat ללוג
setInterval(() => console.log('💓 baileys alive'), 30000);

הסברים למה זה מייצב:
	•	ייצור תיקיות auth מראש (מונע קריסה בשמירת קבצים).
	•	axios במקום fetch (מונע קריסת Node<18).
	•	תמיד מחזירים JSON תקין; כשאין QR → 404 {error:'no_qr'} ולא תגובה ריקה.
	•	מאזינים על 0.0.0.0, כך ש־127.0.0.1 יעבוד.
	•	לוכדי שגיאות גלובליים כדי שלא יקרה exit “שקט”.

אם ה־workflow שלך מפעיל את services/baileys/server.js, שים שם “גשר” בלבד:

// services/baileys/server.js
require('../whatsapp/baileys_service');


⸻

C) Flask – פרוקסי נקי ובלי CSRF לשבור

בקובץ הקנוני (למשל routes_whatsapp.py) — ודא:

import os, requests
from flask import Blueprint, jsonify, request

whatsapp_bp = Blueprint('whatsapp', __name__, url_prefix='/api/whatsapp')
BAILEYS_BASE = os.getenv('BAILEYS_BASE_URL', 'http://127.0.0.1:3300')
INT_SECRET   = os.getenv('INTERNAL_SECRET')

def tenant_id_from_ctx():
    # אם אין ctx, כרגע "1" כדי לא ליפול – תשלים לפי המערכת שלך
    return getattr(request, 'tenant_id', None) or request.headers.get('X-Tenant-Id') or '1'

def _headers():
    return {'X-Internal-Secret': INT_SECRET, 'Content-Type': 'application/json'}

@whatsapp_bp.route('/status', methods=['GET'])
def status():
    t = tenant_id_from_ctx()
    r = requests.get(f"{BAILEYS_BASE}/whatsapp/{t}/status", headers=_headers(), timeout=5)
    return jsonify(r.json()), r.status_code

@whatsapp_bp.route('/qr', methods=['GET'])
def qr():
    t = tenant_id_from_ctx()
    r = requests.get(f"{BAILEYS_BASE}/whatsapp/{t}/qr", headers=_headers(), timeout=5)
    if r.status_code == 404:
        return ('', 204)  # אין QR כרגע – 204 בלי גוף
    return jsonify(r.json()), r.status_code

@whatsapp_bp.route('/start', methods=['POST'])
def start():
    t = tenant_id_from_ctx()
    r = requests.post(f"{BAILEYS_BASE}/whatsapp/{t}/start", headers=_headers(), timeout=10)
    return jsonify(r.json()), r.status_code

	•	אם יש CSRF גלובלי, הוסף @csrf.exempt רק ל־/api/whatsapp/(status|qr|start|logout) כדי שלא תקבל 403 HTML.
	•	ודא שאין כפילויות נתיבים ב־routes.py/api_routes.py/whatsapp_routes.py.

בדיקות מהירות:

curl -sS http://127.0.0.1:3300/healthz
curl -sS -H "X-Internal-Secret: $INTERNAL_SECRET" http://127.0.0.1:3300/whatsapp/1/status
curl -sS -H "X-Internal-Secret: $INTERNAL_SECRET" http://127.0.0.1:3300/whatsapp/1/qr


⸻

D) React – תיקון “Unexpected end of JSON input”

הטעות לרוב מגיעה מכך שהקוד עושה res.json() גם כשהשרת מחזיר 204 או 403/HTML.

בקומפוננטת החיבור (לא משנה ספרייה — דוגמה עם fetch):

async function loadQR() {
  const res = await fetch('/api/whatsapp/qr', { credentials: 'include' });
  if (res.status === 204) {
    setQR('');
    return;                             // ← אל תעשה res.json()
  }
  if (!res.ok) {
    // אפשר לקרוא טקסט כדי להראות למשתמש, אבל אל תעשה JSON.parse בכוח
    const txt = await res.text();
    throw new Error(`QR failed: ${res.status} ${txt.slice(0,120)}`);
  }
  const data = await res.json();        // ← מגיע רק כשיש תוכן JSON תקין
  setQR(data.dataUrl || '');
}

אם אתה עם axios:

const res = await axios.get('/api/whatsapp/qr', { validateStatus: () => true });
if (res.status === 204) { setQR(''); return; }
if (res.status !== 200) throw new Error(`QR failed: ${res.status}`);
setQR(res.data?.dataUrl || '');

זה לבדו ימנע את “Unexpected end of JSON input” גם כשאין QR וגם אם יש נפילת שירות רגעית.

⸻

E) הרצה יציבה (שני תהליכים חיים)

הכי פשוט בריפליט: Honcho.

pip install honcho

Procfile:

web: python -u main.py
whatsapp: node services/baileys/server.js

פקודת Run:

honcho start -f Procfile

Honcho מחזיק את שני התהליכים. אם אחד קורס — תראה מיד בלוג ולא “נשימה ברקע”.

⸻

F) צ’ק־ליסט GO (5 בדיקות קצרות)
	1.	curl http://127.0.0.1:3300/healthz → ok
	2.	POST /api/whatsapp/start → 200
	3.	בתוך ≤3 שניות:
	•	GET /api/whatsapp/status → {connected:false, hasQR:true}
	•	GET /api/whatsapp/qr → 200 {dataUrl:...}
	4.	סורקים ב־WhatsApp → GET /api/whatsapp/status → {connected:true,...}
	5.	GET /api/whatsapp/qr → 204 (אין QR כי התחברנו)

⸻

אם עדיין קרוס:
	•	PID קופץ = התהליך קורס. עכשיו יש לוגים: חפש [UNHANDLED] / [UNCAUGHT] / EACCES / ENOENT.
	•	הכי נפוץ: הרשאות לתיקיות storage/whatsapp/<tenantId>/auth. תוודא שהנתיב נוצר ולא ננעל.
	•	בדיקת פורט תפוס:
lsof -i :3300 → אם יש זומבי, הרוג והפעל מחדש.
	•	IPv6/localhost: נשארים עם 127.0.0.1 + listen('0.0.0.0').

⸻

תיישם לפי הסדר A→F. זה עוצר את הקריסות, מונע JSON שבור בפרונט, ומחזיר לך QR יציב על המסך — בלי שינוי עיצובי ובלי בלגן נוסף.