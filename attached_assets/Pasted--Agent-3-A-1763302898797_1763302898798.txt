סבבה, בוא נעשה לזה הנחיה אחת מסודרת ל-Agent 3, בלי קשקושים.

⸻

🧠 הקשר כללי לפרויקט (שורת פתיחה ל-Agent 3)

אתה עובד על פרויקט AgentLocator / AICallAssistant:
־ Backend: Flask + WebSockets (media_ws_ai.py)
־ Twilio Media Streams לשיחות
־ Google STT/TTS + Whisper כ-fallback
־ AgentKit + tools_calendar/leads/invoices/whatsapp
־ CRM עם BusinessSettings (ימי פעילות, slot_size_min, opening_hours_json וכו’)
־ FAQ Engine + FAQ UI
היעד:
	1.	שיחות טלפון יעברו ל-OpenAI Realtime API (גם STT וגם TTS וגם לוגיקה)
	2.	AgentKit יישאר כרגע בעיקר ל-WhatsApp / אוטומציות ״כבדות״
	3.	לא לשלוח WhatsApp בזמן שיחה – זה תקע קביעת תורים → לבטל.
	4.	להשתמש בהגדרות תורים של כל עסק (BusinessSettings) כדי לייצר חוקים לדיבור וקביעת תור.
	5.	בלי צווארי בקבוק, בלי APP_START באמצע שיחה, שיחות מהירות, ברג’-אין חכם.

⸻

שלב 1 – ניקוי המצב הקיים (לפני שמכניסים Realtime)
	1.	בטל שליחת WhatsApp אוטומטית אחרי קביעת תור בשיחות טלפון
	•	בקובץ server/agents/tools_calendar.py או במקום שבו _calendar_create_appointment_impl קורא ל-whatsapp_send אחרי יצירת Appointment:
	•	הוסף תנאי על הערוץ (channel / source) כך ש:
	•	אם זה phone / twilio → לא קוראים יותר ל-whatsapp_send (הסר לחלוטין או דלג).
	•	אם זה WhatsApp / future flows – אפשר להשאיר (או להשאיר כרעיון עתידי, אבל כרגע לוותר לגמרי אם צריך).
	•	מטרה: קביעת תור לא תלויה ב-WhatsApp → אין latency נוסף / קריסות בגלל WhatsApp.
	2.	השאר AgentKit פעיל רק במקומות הבאים:
	•	WhatsApp Webhook → ממשיך להשתמש ב-generate_response_with_agent(...) עם AgentKit.
	•	API פנימיים (לידים, חשבוניות וכו’) – אפשר להשאיר AgentKit ככלי high-level, אבל לא בשיחות הטלפון בזמן אמת.
	3.	אל תיגע ב-FAQ Engine כרגע
	•	FAQ מה-DB ו-FAQ Fast-Path יישארו לשימוש ב-Web / WhatsApp.
	•	לשיחות טלפון – אחרי מעבר ל-Realtime, אפשר לא להשתמש ב-FAQ Fast-Path בכלל (ה-Realtime יהיה ה-brain).

⸻

שלב 2 – הוספת Client ל-OpenAI Realtime
	1.	צור קובץ חדש:
server/services/openai_realtime_client.py
עם מחלקה בסגנון:

import os
import websockets
import asyncio
import json
from typing import AsyncIterator, Callable

OPENAI_REALTIME_URL = "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview"

class OpenAIRealtimeClient:
    def __init__(self, api_key: str | None = None):
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        assert self.api_key, "OPENAI_API_KEY missing"

    async def connect(self):
        self.ws = await websockets.connect(
            OPENAI_REALTIME_URL,
            extra_headers={"Authorization": f"Bearer {self.api_key}"}
        )
        return self.ws

    async def send_event(self, event: dict):
        await self.ws.send(json.dumps(event))

    async def recv_events(self) -> AsyncIterator[dict]:
        async for raw in self.ws:
            yield json.loads(raw)

	•	לא צריך להשקיע פה יותר מדי – Agent 3 יכול לשפר – העיקר שיש abstraction ברור ל-WebSocket מול OpenAI.

⸻

שלב 3 – בניית System Prompt דינמי לפי עסק
	1.	השתמש במנוע המדיניות + BusinessSettings שכבר בנית
	•	בקובץ server/policy/business_policy.py (או איפה שנמצא ה-Policy Engine):
	•	כבר יש:
	•	slot_size_min
	•	opening_hours_json
	•	allow_24_7
	•	booking_window_days
	•	min_notice_min
	•	צור פונקציה חדשה בסגנון:
build_realtime_system_prompt(business_id: int) -> str
	2.	מימוש build_realtime_system_prompt:
	•	שלבים:
	1.	שלוף Business + BusinessSettings + ה-prompt העסקי מה-DB (ה-prompt שהעסק מגדיר ב-UI).
	2.	השתמש ב-Policy Engine כדי להוציא ניסוח פשוט של:
	•	שעות פעילות (למשל: “פתוח ראשון עד חמישי מ-10:00 עד 20:00”).
	•	גודל סלוט (“קובעים כל 30 דקות” / “רק שעות עגולות”).
	•	ימים סגורים.
	3.	הרכב מחרוזת הוראות בסגנון (בעברית):

אתה נציג טלפוני אנושי של העסק {business_name}.
אתה עונה בעברית, בקול טבעי, במשפטים קצרים וברורים.

חוקים לקביעת תור:
- שעות פעילות: {תיאור שעות פעילות בעברית}
- קובעים תורים במרווחים של {slot_size_min} דקות בלבד.
- אסור לקבוע תור מחוץ לשעות הפעילות או פחות מ-{min_notice_min} דקות מהזמן הנוכחי.
- תמיד תשאל קודם: "לאיזה יום ושעה נוח לך?" ורק אחרי תשובה תבדוק זמינות.
- אסור להקריא רשימת כל השעות הפנויות, רק להציע עד 2 חלופות קרובות.

לגבי טלפון:
- כדי לקבל מספר טלפון תגיד: "תקליד/י את המספר במקלדת ואז הקש/י סולמית (#)."

התנהגות:
- תשובות קצרות, משפט או שניים.
- אם לא הבנת, תבקש בנימוס לחזור על המשפט, אל תגיד "לא הבנתי" מיד, אלא "לא בטוח ששמעתי טוב, אפשר לחזור על זה?".


	4.	בסוף, חבר לזה את ה-prompt העסקי מה-DB (טון, מידע על שירותים, מחירים וכו’).

	3.	שמור את הפונקציה הזו בקובץ שירות חדש
	•	למשל: server/services/realtime_prompt_builder.py
	•	ו-Agent 3 ייקרא אליה מתוך media_ws_ai.py.

⸻

שלב 4 – חיבור Twilio → Realtime במקום Google STT/TTS

ב-server/media_ws_ai.py (או הקובץ שמטפל ב-WebSocket בין Twilio לשרת שלך):
	1.	אל תיגע בפתיח הסטטי
	•	השאר את ה-Greeting הישן שלך (TTS מוכן / הקלטה מוקדמת).
	•	אחרי שהפתיח נגמר → רק אז מתחילים את Session ה-Realtime.
	2.	במקום pipeline של: Twilio → Google STT → ai_service → GCP TTS → Twilio
תעשה:
	•	Twilio Media Stream ←→ OpenAI Realtime WebSocket
	•	אתה רק מתווך AUDIO קדימה ואחורה.
	3.	ברמת הקוד (בקווים כלליים):

# בתוך handler של connection חדש
business = resolve_business_from_to_number(twilio_to_number)
settings = load_business_settings(business.id)
system_prompt = build_realtime_system_prompt(business.id)

rt_client = OpenAIRealtimeClient()
await rt_client.connect()

# הגדרת session:
await rt_client.send_event({
    "type": "session.update",
    "session": {
        "instructions": system_prompt,
        "modalities": ["audio", "text"],
        "input_audio_format": "g711_ulaw",   # תתאים למה ש-Twilio שולח
        "output_audio_format": "g711_ulaw",
        "voice": "alloy", # או מה שתבחר
        "turn_detection": {
            "type": "server_vad",
            "threshold": 0.6,
            "silence_duration_ms": 500
        }
    }
})


	4.	קבלת אודיו מטוויליו → העברה ל-Realtime:
	•	איפה שאתה היום לוקח את ה-PCMU/μ-law frames ל-Google STT:
	•	במקום זה שלח אותם ל-OpenAI כ-input_audio_buffer.append:

await rt_client.send_event({
    "type": "input_audio_buffer.append",
    "audio": base64_audio_chunk
})


	•	כאשר VAD / end-of-utterance (יש לך כבר לוגיקה בסגנון _utterance_end):
	•	שלח input_audio_buffer.commit כדי שה-Realtime יבין שהמשתמש סיים משפט.

await rt_client.send_event({
    "type": "input_audio_buffer.commit"
})


	5.	קבלת אודיו חזרה מה-Realtime → שליחה לטוויליו:
	•	בלולאה שבה אתה מקבל אירועים מ-rt_client.recv_events():
	•	כשהאירוע הוא output audio (לפי spec של Realtime – למשל event מסוג "response.audio.delta" / "response.output_audio.delta"):
	•	קח את ה-audio base64 → המר ל-bytes → העבר לטוויליו כמו שאתה עושה היום ב-TTS.
	•	כשהאירוע הוא טקסט ("response.output_text.delta" / סופי) – שמור לוג, עדיף לשמור במסד (כמו היום) לסיכומי שיחה.
	6.	Barge-in / קטיעות
	•	אל תעשה VAD כפול.
	•	אם אתה משתמש ב-turn_detection של Realtime – תוכל לצמצם את ה-VAD המקומי שהיה לך (VAD_HANGOVER וכו’) כדי לא ״לחנוק״ את השיחה.
	•	כלל ל-Agent 3:
	•	אם detect that user התחיל לדבר באמצע שה-assistant מדבר:
	•	שלח stop/clear ל-Realtime (לפי spec: response.cancel / input_audio_buffer.clear)
	•	חתוך את ה-TTS הנוכחי ותן לו לענות מחדש.
	•	אבל שים threshold גבוה לרעש – אל תעצור על כל קליק/נשימה.
	•	אם יש פילטר רעש בטוויליו – השאר אותו, אל תעשה ניתוח נוסף בצד שלך.

⸻

שלב 5 – איך Realtime קורא לכלים (Calendar/Leads/Invoices) בלי AgentKit בשיחות

כרגע:
	•	AgentKit מגדיר tools (calendar_find_slots_wrapped, calendar_create_appointment_wrapped, leads_upsert_wrapped, whatsapp_send וכו’) דרך Agents SDK.
	•	לשיחות טלפון אנחנו רוצים מינימום מורכבות → לא להכניס עוד שכבת AgentKit בתוך Realtime.

הנחיה ל-Agent 3:
	1.	אל תשתמש ב-AgentKit בתוך Realtime לטלפון.
	•	במקום זה, תעשה Orchestration בצד השרת כמו היום:
	•	כאשר Realtime מחזיר טקסט שיש בו כוונה לקביעת תור (למשל זיהית תבנית "ACTION: CREATE_APPOINTMENT" או פשוט לפי לוגיקה ב-Python):
	•	קרא לפונקציות הקיימות:
	•	calendar_find_slots(...)
	•	calendar_create_appointment(...)
	•	leads_upsert(...) (אם צריך)
	•	את התוצאה הזאת תעבד לטקסט קצר ותזין חזרה ל-Realtime כ-input_text (או במקרה הפשוט – תשלח את זה כ-TTS ללקוח, בלי שה-Realtime ינסח).
	2.	פשטות קודם
	•	בשלב ראשון:
	•	Realtime אחראי רק על דיאלוג חכם, שאלות, הבנת עברית.
	•	ברגע שאתה (השרת) מזהה שהלקוח אמר: “כן, תקבע לי…” ויש כבר שם + טלפון + זמן – אתה עושה calendar_create_appointment ב-Python, ומחזיר תשובה בדיבור (TTS דרך Realtime) בסגנון:
	•	“מעולה, קבעתי לך תור ליום שלישי בשעה 17:00”.
	•	רק אם תרצה, בשלב הבא, אפשר ללמד את Realtime לקרוא tools ישירות (function calling) – אבל זה מיותר כרגע.

⸻

שלב 6 – מה להשאיר מ-AgentKit + FAQ
	1.	AgentKit
	•	השאר אותו:
	•	ל-WhatsApp → ממשיך לעבוד כמו היום (calls ל-tools_calendar, tools_leads וכו’).
	•	ל-backend flows עתידיים (חשבוניות, חוזים, אוטומציה מורכבת).
	•	אל תשתמש בו שהטלפון מחובר ל-Realtime – זה רק יוסיף latency.
	2.	FAQ Fast-Path
	•	Web / WhatsApp → להשאיר כמו היום (יש לך כבר טבלת FAQ, cache + embeddings, וכו’).
	•	לשיחות טלפון אחרי Realtime:
	•	לא חובה – Realtime מספיק חכם עם system prompt טוב.
	•	אם תשאיר FAQ, זה יכול להיות רק בשכבת השרת (לפני Realtime):
	•	אם שאלה מתאימה ל-FAQ → מחזירים תשובה מוכנה כ-TTS (גם דרכו).
	•	אחרת → שולחים את הטקסט ל-Realtime.

⸻

שלב 7 – ביצועים, צווארי בקבוק ו־Multi-tenant
	1.	בלי יצירת Flask app מחדש
	•	ודא שמאז התיקון הקודם, אין יותר create_app() בתוך worker / background / media_ws.
	•	כל השיחות משתמשות ב-current_app או באובייקט app גלובלי.
	2.	אין Warmup כבד בלולאת השיחה
	•	warmup ל-Realtime / Whisper / DB – להריץ בטיימר רקע (כל X דקות), לא בתוך כל שיחה.
	•	כל קריאה כבדה (DB, HTTP) בלולאה מתוזמנת בזהירות.
	3.	Multi-tenant
	•	בכל שיחה:
	•	business_id מזוהה לפי To number של Twilio.
	•	לפי business_id → טוענים:
	•	BusinessSettings
	•	הפרומפט העסקי מה-DB
	•	חישוב מדיניות (Policy Engine)
	•	מזה בונים system_prompt ו־Reatime session.
	4.	מדדים שאתה רוצה לראות בלוגים
	•	לכל utterance:
	•	ASR_LATENCY (Realtime) ~0.3–0.6s
	•	AI_LATENCY (Realtime generation) ~0.7–1.3s
	•	TTS_LATENCY (החזרת אודיו ל-Twilio) ~0.2–0.4s
	•	TOTAL_TURN ~1.5–2.0s

⸻

סיכום קצר ל-Agent 3 (Checklist לביצוע)
	1.	לכבות שליחת WhatsApp מתוך calendar_create_appointment למסלול שיחות טלפון.
	2.	להשאיר AgentKit ו-FAQ ל-WhatsApp/Web בלבד.
	3.	ליצור OpenAIRealtimeClient (WebSocket) בקובץ שירות חדש.
	4.	ליצור builder ל-system prompt דינמי לפי BusinessSettings + prompt מה-DB.
	5.	לעדכן media_ws_ai.py:
	•	אחרי פתיח סטטי → לפתוח session ל-Realtime.
	•	להעביר אודיו Twilio → Realtime, ולהחזיר אודיו Realtime → Twilio.
	•	להשתמש ב-turn_detection של Realtime ולצמצם VAD מקומי.
	6.	להשאיר Orchestration של קביעת תור ב-Python (calendar tools קיימים), בלי AgentKit בתוך השיחה.
	7.	לא ליצור app חדש בתוך Worker, לא לעשות Warmup כבד בתוך השיחה.
	8.	לוודא שכל זה עובד עבור multi-tenant לפי business_id.

אם תרצה אחרי זה, נעשה הנחיה נפרדת רק ל-״איך לכתוב system prompt לעסק אחד״ לטסטינג, ואז נריץ שיחה אמיתית ונתקן לפי הלוגים.