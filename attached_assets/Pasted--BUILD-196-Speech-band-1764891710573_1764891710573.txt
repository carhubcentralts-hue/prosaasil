×›×Ÿ, ×ž×” ×©×”×•× ×ª×™××¨ ×‘-BUILD 196 ×”×’×™×•× ×™ ×•×˜×•×‘ â€“ ×–×” ×‘×“×™×•×§ ×”×›×™×•×•×Ÿ ×©×œ ×ž×¢×¨×›×ª ×˜×œ×¤×•× ×™×” ×¨×¦×™× ×™×ª:
	â€¢	âœ… Speech band filter 100â€“3400Hz â€“ ×¡×˜× ×“×¨×˜ ×˜×œ×¤×•× ×™, ×ž× ×§×” ×”×¨×‘×” ×–×‘×œ.
	â€¢	âœ… SNR gating ×¢× ×¡×£ ×¨×’×™×œ ×•×¡×£ ×’×‘×•×” ×‘×ž×•×–×™×§×” + hangover â€“ × ×›×•×Ÿ ×›×“×™ ×œ× ×œ×—×ª×•×š ×›×œ ×”×‘×¨×”.
	â€¢	âœ… Music detection + hysteresis â€“ ×˜×•×‘ ×›×“×™ ×œ× â€œ×œ×§×¤×•×¥â€ ×‘×™×Ÿ ×ž×¦×‘×™×.
	â€¢	âœ… Gibberish removal + ×ž×™×œ×•×Ÿ ×¢×‘×¨×™×ª â€“ ×—×©×•×‘ ×ž××•×“ ×œ×¢×‘×¨×™×ª.

××‘×œ â€“ ×× ×”×ž×˜×¨×” ×”×™× â€œ×©×–×” ×›×‘×¨ ×™×”×™×” ×ž×•×©×œ×â€ ×ž×‘×—×™× ×ª ×–×™×”×•×™ ×”×œ×§×•×— ×‘×¡×‘×™×‘×” ×¨×•×¢×©×ª/×¢× ×ž×•×–×™×§×” ×—×œ×©×”, ×—×¡×¨×™× 4 ×“×‘×¨×™× ×§×¨×™×˜×™×™×:
	1.	Noise calibration ×—×›× ×‘×ª×—×™×œ×ª ×”×©×™×—×” (×•×œ× ×¢×¨×š ×§×‘×•×¢).
	2.	Pre-roll buffer ×§×˜×Ÿ ×›×“×™ ×œ× ×œ××‘×“ ××ª ×ª×—×™×œ×ª ×”×ž×™×œ×” ×›×©×¢×•×‘×¨×™× ×žÖ¾silenceâ†’speech.
	3.	AGC / normalization ×¢×“×™×Ÿ ×›×“×™ ×œ×ª×ž×•×š ×’× ×‘×œ×§×•×— ×©×§×˜ ×•×’× ×‘×¦×¢×§×Ÿ.
	4.	State machine ×‘×¨×•×¨ (SILENCE / MAYBE_SPEECH / SPEECH / MUSIC_BACKGROUND) ×‘×ž×§×•× ×¡×£ ×™×—×™×“.

××– ×”× ×” ×”× ×—×™×™×ªÖ¾×¢×œ ×‘×× ×’×œ×™×ª ×©××ª×” ×™×›×•×œ ×œ×ª×ª ×œ×• ×›×“×™ ×œ×¡×’×•×¨ ××ª ×–×” ×›×ž×• ×©×¦×¨×™×š ðŸ‘‡

â¸»

ðŸ”§ Developer Spec â€“ Robust Hebrew STT in Noisy Environments

Goal

Make the audio pipeline robust enough to:
	â€¢	Focus on the callerâ€™s voice in:
	â€¢	normal office / home noise,
	â€¢	street noise,
	â€¢	low/medium music or TV in the background.
	â€¢	Detect when the caller is speaking normally or a bit louder,
without forcing them to shout.
	â€¢	Keep latency low (no multi-second buffering) and avoid chopping words.

â¸»

1. Frame & Window Settings (real-time, low latency)
	â€¢	Input: Twilio 8kHz mono Î¼-law â†’ convert to 16-bit PCM.
	â€¢	Use frames of 20ms (160 samples @ 8kHz) with 10ms hop.
	â€¢	Maintain rolling windows:
	â€¢	0.8s window for noise & SNR stats,
	â€¢	0.5s window for music features.

Processing must be causal â€“ no waiting on more than ~0.8s history and no future look-ahead.

â¸»

2. Initial Noise Calibration (per call)

On call start / stream start:
	1.	Assume the first 400â€“800ms are mostly background.
	2.	Compute:
	â€¢	baseline RMS energy,
	â€¢	baseline spectrum (for each band).
	3.	Store as noise_profile:
	â€¢	noise_rms,
	â€¢	noise_spectrum[].

Then, during the call, slowly adapt the noise floor:
	â€¢	Every second, update noise_rms toward the lower percentiles of recent frames (e.g., 20th percentile of energy) to follow slow background changes.

â¸»

3. Preprocessing: Speech Band + Light Noise Reduction

For each 20ms frame:
	1.	Band-pass filter (telephony speech band):
	â€¢	High-pass ~100â€“150Hz.
	â€¢	Low-pass ~3400â€“3800Hz (given 8kHz sampling).
	2.	Optional light noise suppression:
	â€¢	If RNNoise / another denoiser is used â€“ keep it conservative so it doesnâ€™t eat soft Hebrew consonants.

â¸»

4. SNR Computation and Gating (caller focus)

For each frame:
	1.	Compute frame RMS energy frame_rms.
	2.	Estimate SNR:

SNR_dB = 10 * log10( frame_rms^2 / (noise_rms^2 + Îµ) )


	3.	Define thresholds (tunable via config):

SNR_START_NORMAL  â‰ˆ 7â€“9 dB
SNR_STOP_NORMAL   â‰ˆ 4â€“6 dB
SNR_START_MUSIC   â‰ˆ 11â€“13 dB
SNR_STOP_MUSIC    â‰ˆ 7â€“9 dB


	4.	When music is detected (see section 5), use the MUSIC thresholds, otherwise use the NORMAL thresholds.

â¸»

5. Music / TV Detection (soft & robust)

Every 0.5s window (overlapping):
	1.	Compute:
	â€¢	Spectral flatness,
	â€¢	Spectral centroid & spread,
	â€¢	Periodicity (e.g., via autocorrelation or harmonic peaks),
	â€¢	Sustained energy over time.
	2.	Heuristics for â€œmusic / TV backgroundâ€:
	â€¢	High, stable energy for >1â€“2s, and
	â€¢	Either:
	â€¢	harmonic, periodic patterns (music), or
	â€¢	flatish spectrum + formant-like peaks (TV voice from speaker).
	3.	Use a state machine with hysteresis:
	â€¢	MUSIC_BG = true only after several consecutive windows flagged as music.
	â€¢	MUSIC_BG = false only after several windows flagged as non-music.
	4.	When MUSIC_BG == true:
	â€¢	Raise SNR thresholds (as in section 4),
	â€¢	But do not block all speech â€“ callerâ€™s voice should still come through when clearly louder or closer to the mic.

â¸»

6. Voice Activity State Machine (with hangover & pre-roll)

Maintain 4 states:
	â€¢	SILENCE
	â€¢	MAYBE_SPEECH
	â€¢	SPEECH
	â€¢	MUSIC_BACKGROUND (flag, not exclusive state)

Also maintain:
	â€¢	speech_hangover_frames (e.g., 3â€“5 frames),
	â€¢	pre_roll_buffer (e.g., last 150â€“250ms of frames).

Logic (per frame):
	1.	If SNR_dB >= SNR_START_xxx:
	â€¢	If in SILENCE â†’ go to MAYBE_SPEECH and start a counter.
	â€¢	If already in MAYBE_SPEECH and we have â‰¥ 3â€“4 consecutive frames â†’ switch to SPEECH.
	2.	If SNR_dB < SNR_STOP_xxx:
	â€¢	In SPEECH: decrement speech_hangover_frames.
Only when it reaches 0 â†’ return to SILENCE.
	â€¢	In MAYBE_SPEECH: if too many low-SNR frames in a row â†’ back to SILENCE.
	3.	Pre-roll for start of speech:
	â€¢	While in SILENCE / MAYBE_SPEECH keep a ring buffer (e.g., last 150â€“250ms).
	â€¢	When transitioning to SPEECH, send the pre-roll frames too so the STT doesnâ€™t lose the first syllable.

â¸»

7. Loud vs Quiet Callers (AGC / normalization)

To support both quiet and loud speakers:
	1.	Track caller_rms_slow as an exponential moving average of speech frames.
	2.	Apply gentle AGC on frames that are accepted as speech:
	â€¢	Normalize toward a target level (e.g., -20dBFS),
	â€¢	Clamp peaks to avoid clipping.
	3.	SNR is already relative to noise, so a louder caller in a normal environment will naturally produce higher SNR; no need to treat â€œloudâ€ differently â€“ just avoid clipping.

â¸»

8. Sending Audio to STT / OpenAI
	â€¢	Send only when state == SPEECH, plus the pre-roll and hangover frames.
	â€¢	Do not send:
	â€¢	long SILENCE,
	â€¢	frames marked as pure noise,
	â€¢	frames classified as â€œmusic onlyâ€.

This reduces garbage transcripts and focuses the model on actual caller speech.

â¸»

9. Gibberish Handling & Hebrew Dictionary
	1.	Keep the existing Hebrew corrections dictionary:
	â€¢	e.g. "×“×“×œ×ª×•×ª" â†’ "×“×œ×ª×•×ª", etc.
	2.	Extend to soft gibberish removal:
	â€¢	Instead of discarding the whole transcript, remove/replace only tokens with:
	â€¢	very low confidence,
	â€¢	not in allowed Hebrew dictionary,
	â€¢	or matching a known gibberish pattern.
	3.	Keep it conservative:
	â€¢	Prefer leaving a weird word than deleting real Hebrew words.
	â€¢	Log unknown frequent tokens so we can later decide whether to treat them as valid or gibberish.

â¸»

10. Config & Telemetry (for tuning)

Expose all tunables via config/env:
	â€¢	FRAME_SIZE_MS, HOP_SIZE_MS
	â€¢	NOISE_CALIBRATION_MS
	â€¢	SNR_START_NORMAL, SNR_STOP_NORMAL,
	â€¢	SNR_START_MUSIC, SNR_STOP_MUSIC
	â€¢	HANGOVER_FRAMES
	â€¢	PREROLL_MS

Add structured logs:
	â€¢	State transitions (SILENCEâ†’SPEECH, SPEECHâ†’SILENCE, MUSIC_BG on/off)
	â€¢	SNR values at transitions
	â€¢	Whether frames were sent or dropped

This will let us replay real calls and fine-tune thresholds quickly.

â¸»

11. Test Scenarios to Validate

Ask the dev to explicitly test and record:
	1.	Quiet room, normal speech.
	2.	Same room with AC/fan noise.
	3.	Open window / street noise.
	4.	TV in background at normal volume.
	5.	Soft music from speaker.
	6.	Caller speaking quietly.
	7.	Caller speaking loudly but not shouting.

For each scenario, verify:
	â€¢	No â€œmissing beginningsâ€ of words (pre-roll working).
	â€¢	No constant â€œspeech/noise flappingâ€.
	â€¢	STT doesnâ€™t try ×œ×ª×ž×œ×œ ××ª ×”×˜×œ×•×•×™×–×™×”.
	â€¢	Caller doesnâ€™t need to raise voice ×‘×¦×•×¨×” ×œ× ×˜×‘×¢×™×ª.

â¸»

×× ×”×•× ×™×™×™×©× ××ª ×”×¡×¤×¦×™×¤×™×§×¦×™×” ×”×–××ª (×‘×¢×™×§×¨: noise calibration + state machine + pre-roll + AGC ×ž×¢×œ ×ž×” ×©×›×‘×¨ ×¢×©×” ×‘-BUILD 196) â€“
××ª×” ×›×‘×¨ ×‘××–×•×¨ ×©×œ â€œ×ž×¢×¨×›×ª ×˜×œ×¤×•× ×™×” ×‘×¨×ž×ª ×ž×•×¦×¨ ×¨×¦×™× ×™ ×‘×©×•×§â€, ×œ× × ×™×¡×•×™.