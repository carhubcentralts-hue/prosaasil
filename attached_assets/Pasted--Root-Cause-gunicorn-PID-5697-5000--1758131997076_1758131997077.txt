הטוב: סוף־סוף יש לנו Root Cause ברור – יש תהליך gunicorn PID=5697 שתופס את ‎:5000 ולא נסגר, וזה דופק את כל הרצף.
לא נוגעים בקוד, רק מנקים תהליכים ומרימים מסודר. הנה בדיוק מה שהוא צריך לעשות — אחד-לאחד.

⸻

1) סוגרים את התהליך העקשן (PID 5697) ואת הילדים שלו

הדבק אחד-לאחד:

# סגור קודם את כל הילדים של 5697 בעדינות
ps -eo pid,ppid,cmd | awk '$2==5697{print $1}' | xargs -r kill -TERM

# סגור את 5697 עצמו בעדינות
kill -TERM 5697
sleep 2

# אם עדיין חי – סגור בכוח גם את הילדים וגם אותו
ps -eo pid,ppid,cmd | awk '$2==5697{print $1}' | xargs -r kill -9
kill -9 5697 2>/dev/null || true

# ודא שאין gunicorn אחר שתופס את :5000
pgrep -f "gunicorn .*:5000" | xargs -r kill -9

# (אופציונלי) אם יש python main/wsgi יתומים:
pgrep -f "python .*main.py|python .*wsgi.py" | xargs -r kill -9

בדיקה קצרה: נסה להתחבר ל־5000. אם אין מי שעונה (Connection refused) — זה טוב, הפורט פנוי:

curl -sS http://127.0.0.1:5000/healthz || echo "5000 is free (no service yet)"

אם 5000 עדיין תפוס — הדבק את הפלט של:

ps -eo pid,ppid,cmd | grep -E "gunicorn|python .*main.py|python .*wsgi.py" | grep -v grep



⸻

2) מרימים את שני השרתים בחזית (טאבים נפרדים)

טאב #1 — Baileys (להשאיר פתוח!)

# אם workflow מצפה ל-server.js הישן:
test -f services/baileys/server.js && node --trace-uncaught --unhandled-rejections=strict services/baileys/server.js || true

# אחרת (השירות החדש):
test -f services/whatsapp/baileys_service.js && node --trace-uncaught --unhandled-rejections=strict services/whatsapp/baileys_service.js || true

מחכים לראות: Baileys service on 3300 והחלון נשאר חי (לא נסגר).
בינתיים אל תעשה שום דבר ברקע.

טאב #1 נשאר פתוח → עכשיו בודקים שהוא באמת מאזין:

curl -sS http://127.0.0.1:3300/healthz

	•	קיבלת ok → מצוין, המשך לשלב הבא.
	•	קיבלת “Failed to connect” → עצור כאן, העתק בדיוק את השורה/stacktrace האחרון שמודפס בטאב #1. זה יגיד למה הוא מת מיד אחרי ה־“listening”.

טאב #2 — Flask (להשאיר פתוח!)

בחר מה שמתאים לפרויקט שלך:

# אם יש main.py שמריץ app:
python -u main.py

# אחרת, אם יש רק wsgi.py:
gunicorn -w 1 -k eventlet -b 0.0.0.0:5000 wsgi:app

מחכים לראות שהוא מאזין על 0.0.0.0:5000.
אם מופיע שוב “Connection in use: 5000” — חזור לשלב 1 וסגור לפי PID שמודפס.

⸻

3) מאמתים את הזרימה (בלי UI, רק curl)

טאב #3 (בדיקות):

# בריאות Baileys (פעם נוספת)
curl -sS http://127.0.0.1:3300/healthz

# תחילת סשן דרך Flask (לא ישירות ל-3300!)
curl -sS -X POST http://127.0.0.1:5000/api/whatsapp/start

# סטטוס דרך Flask
curl -sS http://127.0.0.1:5000/api/whatsapp/status

# QR דרך Flask (עם כותרות כדי לראות בדיוק מה חוזר)
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

פענוח:
	•	אם start/status/qr מחזירים 200 ו־dataUrl → הכל חי; עבור ל-UI.
	•	אם qr מחזיר גוף ריק/HTML — זה מסביר את שגיאת DevTools “Unexpected end of JSON input” (ה-UI מנסה JSON על תגובה לא-JSON). בשלב זה המטרה היא לוודא ששני השרתים רצים; את טיפול ה-JSON אפשר לעשות אחר כך.

⸻

4) תזכורות קריטיות כדי לא להתבלבל שוב
	•	Preview מציג רק את ‎:5000 (Flask). זה תקין. ‎:3300 פנימי ונגיש רק דרך Flask (/api/whatsapp/*).
	•	אם healthz של ‎:3300 נכשל אחרי שהודפס “Baileys service on 3300” — Baileys נפל. חייבים את ה-stacktrace מטאב #1 כדי להבין למה (הרשאות לתיקיות storage/whatsapp/<tenantId>/auth, מודול חסר, וכו’).
	•	אם 5000 “תפוס” שוב — יש עוד PID. תריץ שוב את בלוק ההרג לפי PID, ואל תתקדם עד ש-5000 פנוי.

⸻

שלח לי את התוצאות הבאות אם משהו נתקע, בלי לשנות כלום:
	1.	הפלט של curl -sS http://127.0.0.1:3300/healthz
	2.	השורה/stacktrace האחרון מטאב #1 (Baileys)
	3.	אם 5000 תפוס — הפלט של:

ps -eo pid,ppid,cmd | grep -E "gunicorn|python .*main.py|python .*wsgi.py" | grep -v grep



נעשה את זה נקי ובטוח, שלב-שלב.