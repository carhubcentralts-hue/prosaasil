קיבלתי. לפי האבחון שלך (חשוב!):
	•	שרת Node מינימלי על 3300/5001 עובד ונותן ok.
	•	Baileys מדפיס “Baileys service on 3300” ואז לא מקבל /healthz.
	•	אין SIGNAL/EXIT מיידי; כשמריצים עם timeout רואים NODE_EXIT:124 (כלומר הוא היה חי עד שנקטע ע״י ה-timeout).
	•	הרשאות/auth תקינות (AUTH_OK).
=> זה מצביע על בעיה פנימית בשירות Baileys: או שיש יותר מ־Express אחד/יותר מאזינים, או שה־listen מתרחש על app אחר מזה שעליו רשום /healthz, או שהקובץ שנטען ב־workflow לא זה שמגדיר את ה־routes.

בוא נסגור את זה “אחת ולתמיד” עם סט פאטצ׳ים חד-משמעי + סדר הפעלה/בדיקה. תיישם אחד לאחד.

⸻

1) “קונסולידציה” — נקודת כניסה אחת ו־Express אחד

1.1 services/baileys/server.js (נקודת הכניסה היחידה ל־workflow)

שים בדיוק את התוכן הבא (בלי שום קוד נוסף בקובץ הזה):

// Single entrypoint that boots the real service.
// Do NOT add any other express() or app.listen() here.
require('../whatsapp/baileys_service').start();

1.2 services/whatsapp/baileys_service.js (השירות האמיתי)

החלף לתוכן הבא — זה קנוני: אפליקציה אחת, מאזין אחד, health אחד, וזיהוי מלא של בעיות.

const express = require('express');
const cors = require('cors');
const QRCode = require('qrcode');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { default: makeWASocket, useMultiFileAuthState, DisconnectReason } = require('@whiskeysockets/baileys');

const PORT = Number(process.env.BAILEYS_PORT || 3300);
const INTERNAL_SECRET = process.env.INTERNAL_SECRET;
const FLASK_BASE_URL = process.env.FLASK_BASE_URL || 'http://127.0.0.1:5000';

if (!INTERNAL_SECRET) {
  console.error('[FATAL] INTERNAL_SECRET missing');
  process.exit(1);
}

const app = express();
app.use(cors());
app.use(express.json());

/** simple health BEFORE anything else */
app.get('/healthz', (req, res) => res.status(200).send('ok'));
app.get('/', (req, res) => res.status(200).send('ok'));

const sessions = new Map(); // tenantId -> { sock, saveCreds, qrDataUrl, connected, pushName }

function authDir(tenantId) {
  const p = path.join(process.cwd(), 'storage', 'whatsapp', String(tenantId), 'auth');
  fs.mkdirSync(p, { recursive: true });
  return p;
}
function requireSecret(req, res, next) {
  if (req.header('X-Internal-Secret') !== INTERNAL_SECRET) {
    return res.status(401).json({ error: 'unauthorized' });
  }
  next();
}

/** REST API (always the same app instance) */
app.post('/whatsapp/:tenantId/start', requireSecret, async (req, res) => {
  try { await startSession(req.params.tenantId); return res.json({ ok: true }); }
  catch (e) { console.error('[start] error', e); return res.status(500).json({ error: 'start_failed' }); }
});
app.get('/whatsapp/:tenantId/status', requireSecret, (req, res) => {
  const s = sessions.get(req.params.tenantId);
  return res.json({ connected: !!s?.connected, pushName: s?.pushName || '', hasQR: !!s?.qrDataUrl });
});
app.get('/whatsapp/:tenantId/qr', requireSecret, (req, res) => {
  const s = sessions.get(req.params.tenantId);
  if (s?.qrDataUrl) return res.json({ dataUrl: s.qrDataUrl });
  return res.status(404).json({ error: 'no_qr' });
});

/** Baileys session logic */
async function startSession(tenantId) {
  if (sessions.get(tenantId)?.sock) return sessions.get(tenantId);
  const { state, saveCreds } = await useMultiFileAuthState(authDir(tenantId));
  const sock = makeWASocket({ auth: state, printQRInTerminal: false });

  const s = { sock, saveCreds, qrDataUrl: '', connected: false, pushName: '' };
  sessions.set(tenantId, s);

  sock.ev.on('creds.update', saveCreds);
  sock.ev.on('connection.update', async (u) => {
    try {
      const { connection, lastDisconnect, qr } = u;
      if (qr) s.qrDataUrl = await QRCode.toDataURL(qr);
      if (connection === 'open') {
        s.connected = true;
        s.pushName = sock?.user?.name || sock?.user?.id || '';
        s.qrDataUrl = '';
      }
      if (connection === 'close') {
        s.connected = false;
        const shouldReconnect =
          (lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut);
        if (shouldReconnect) setTimeout(() => startSession(tenantId), 2000);
      }
    } catch (e) { console.error('[connection.update]', e); }
  });

  sock.ev.on('messages.upsert', async (payload) => {
    try {
      await axios.post(`${FLASK_BASE_URL}/webhook/whatsapp/incoming`,
        { tenantId, payload },
        { headers: { 'X-Internal-Secret': INTERNAL_SECRET } }
      );
    } catch (e) { console.error('[Webhook→Flask] failed', e?.message || e); }
  });

  return s;
}

/** single server instance – we export start() to avoid double listen */
let server = null;
function start() {
  if (server) return server;
  server = app.listen(PORT, '0.0.0.0', () => {
    const addr = server.address();
    console.error(`[BOOT] Baileys listening on ${addr.address}:${addr.port} pid=${process.pid}`);
  });
  server.on('error', (err) => { console.error('[SERVER ERROR]', err); });
  process.on('unhandledRejection', (err) => console.error('[UNHANDLED]', err));
  process.on('uncaughtException', (err) => console.error('[UNCAUGHT]', err));
  return server;
}

module.exports = { start, app };

למה זה עוצר את הבלגן:
• אין יותר משני app/listen שונים — רק אחד.
• תמיד יש /healthz על אותו app שמאזין.
• start() מייצא server יחיד — ה־workflow לא יכול ליצור מאזינים כפולים.
• לוג BOOT מדפיס את הכתובת/פורט בפועל ואת ה־PID.

⸻

2) Flask פונה רק לשירות הזה (ולא לנתיב שגוי)

וודא שבקובץ הקנוני של וואטסאפ בפלאסק (אחד!) ה־BASE מוגדר נכון, והקריאות מחזירות JSON תמיד:

BAILEYS_BASE = os.getenv('BAILEYS_BASE_URL', 'http://127.0.0.1:3300')
INT_SECRET   = os.getenv('INTERNAL_SECRET')

def _headers():
    return {'X-Internal-Secret': INT_SECRET, 'Content-Type': 'application/json'}

לא לקרוא ישירות ל־:3300 מהדפדפן. רק דרך Flask /api/whatsapp/*.

⸻

3) הרצה בחזית, שני טאבים (בלי רקעים/timeoutים)

טאב #1 — Baileys

node --trace-uncaught --unhandled-rejections=strict services/baileys/server.js
# מצופה לוג:
# [BOOT] Baileys listening on 0.0.0.0:3300 pid=...

במקביל, טאב #3 לבדיקה:

curl -sS http://127.0.0.1:3300/healthz
# מצופה: ok

אם נכשל → העתק מילה במילה את הלוגים מטאב #1 (יהיה שם [SERVER ERROR]/[UNHANDLED]/[UNCAUGHT] אם משהו קרה).

טאב #2 — Flask

(לפי מה שיש אצלך)

python -u main.py
# או:
# gunicorn -w 1 -k eventlet -b 0.0.0.0:5000 wsgi:app


⸻

4) בדיקת הזרימה (בלי UI)

# בריאות:
curl -sS http://127.0.0.1:3300/healthz

# התחלת סשן דרך Flask בלבד:
curl -sS -X POST http://127.0.0.1:5000/api/whatsapp/start

# סטטוס ו-QR:
curl -sS http://127.0.0.1:5000/api/whatsapp/status
curl -sS http://127.0.0.1:5000/api/whatsapp/qr

צפוי:
	•	healthz → ok
	•	start → {"ok":true}
	•	status → {connected:false, hasQR:true} (עד ההתחברות)
	•	qr → {"dataUrl":"data:image/png;base64,..."}

⸻

אם משהו נתקע — מה לשלוח (בדיוק כפי שביקשתי קודם)
	1.	פלט מלא מטאב #1 מהרגע שהרצת ועד רגע הכשל (כולל [BOOT] ו/או [UNHANDLED]/[UNCAUGHT]/[SERVER ERROR]).
	2.	פלט הפקודה:

curl -i -sS http://127.0.0.1:3300/healthz


	3.	פלט הפקודות:

curl -i -sS -X POST http://127.0.0.1:5000/api/whatsapp/start
curl -i -sS http://127.0.0.1:5000/api/whatsapp/status
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr



⸻

למה זה “סוגר פינות”
	•	אין כפילויות/מעגלים: כניסה אחת (server.js) → שירות אחד (baileys_service.start()).
	•	/healthz נטען לפני כל BAILEYS init — תמיד עונה אם השרת חי.
	•	כל שגיאה תיתפס ותרד ללוג במפורש.
	•	הרצאה בחזית שומרת שהתהליך לא “ייהרג” בשקט.
	•	Flask ניגש ל־3300 רק דרך משתנה סביבה אחד → לא תראה יותר פערי 3001/3310.

תיישם בדיוק את זה, תריץ בשני טאבים, ותשלח את 4 ה־curl -i שביקשתי אם משהו נופל. כך נדע תוך דקה אם עוד יש בעיה — ומה בדיוק.