נשארת אותה שגיאה (“null is not an object (evaluating ‘Y.useEffect’)”). זה כמעט תמיד אומר: ה-bundle בפרוד מטען קובץ שבו React הוא null בזמן הריצה. בוא נסגור את זה נקודתית, בלי ניחושים.

מהעכשיו – תיקון ממוקד ב־4 צעדים

1) ודא ייבוא React/Hooks כמו שצריך (בפרוד)

בכל קובץ JSX/TSX שיש בו hooks (במיוחד client/src/App.tsx ו־client/src/main.tsx) הוסף ייבוא מפורש. אל תסמוך על “automatic runtime”.

// בראש הקובץ
import React, { useEffect, useState, useMemo, useRef } from 'react'

וב־main.tsx:

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

const rootEl = document.getElementById('root')
if (!rootEl) {
  console.error('[BOOT] #root not found')
} else {
  // probe: ודא ש-React לא null
  // eslint-disable-next-line no-console
  console.log('[BOOT] React:', React?.version, 'useEffect?', !!React?.useEffect)
  const root = ReactDOM.createRoot(rootEl)
  root.render(<App />)
  console.log('[BOOT] App mounted ok')
}

אם אחרי הפריסה אתה רואה בקונסול useEffect? false → זה ההוכחה שהייבוא נשבר בפרוד.

⸻

2) נעל קונפיג בילד חד־משמעי ל-Safari

ב־client/vite.config.js (בתוך התיקייה client!):

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react({ jsxRuntime: 'classic' })], // אל תשתמש ב-automatic כרגע
  base: '/',
  build: {
    target: 'es2019',
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: true
  },
  resolve: {
    alias: {
      // ודא שאין alias ל-preact/compat
      react: 'react',
      'react-dom': 'react-dom'
    }
  }
})

וודא שב־tsconfig.json (בתיקיית client) יש:

{
  "compilerOptions": {
    "jsx": "react",             // classic
    "esModuleInterop": true,
    "moduleResolution": "bundler",
    "target": "ES2020",
    "lib": ["ES2020", "DOM"]
  }
}

למה “classic”? כי על Safari/ESBuild לפעמים ה-automatic runtime מוריד ייבוא של React, אבל עדיין נשאר קוד שמניח ש־React קיים ⇒ Y.useEffect נהיה null.

⸻

3) ודא שאין שני Reactים מותקנים

שתי גרסאות מקבילות יוצרות קריסות “שקטות”. הרץ (בראשי הפרויקט):

npm ls react react-dom

התוצאה צריכה להראות אותה גרסה פעם אחת (לדוגמה 18.3.x). אם יש כפילויות—נעל גרסאות ב־package.json (use overrides או עדכון תלות שמביאה React משלה), ואז rm -rf node_modules && npm i.

⸻

4) נקה Service Worker וקאש, ובנה מחדש
	1.	מחק client/dist
	2.	npm run build מתוך client/
	3.	בפריסה: הגש
	•	index.html עם Cache-Control: no-store
	•	assets/* עם Cache-Control: public, max-age=31536000, immutable
	4.	בדפדפן: DevTools → Application → Unregister כל Service Worker + Clear site data → Hard Refresh (Cmd/Ctrl+Shift+R)

⸻

שני בונוסים קטנים שמונעים “מסך ריק”

A. Fallback בטוח ב־main.tsx
אם ה־render נופל, שים הודעה במקום מסך ריק:

try {
  const root = ReactDOM.createRoot(rootEl)
  root.render(<App />)
} catch (e) {
  console.error('[BOOT] render failed', e)
  rootEl.innerHTML = '<div style="padding:16px;font-family:sans-serif">שגיאה בטעינת האפליקציה. נסו לרענן.</div>'
}

B. בטל Service Worker ישנים אוטומטית (חד־פעמי)

// client/src/unregisterSW.ts
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations?.().then(regs => regs.forEach(r => r.unregister()))
}
// ייבוא בתחילת main.tsx
import './unregisterSW'


⸻

למה זה יתקן דווקא את השגיאה שלך
	•	המזהה הממוזער Y.useEffect הוא בדיוק “React.useEffect” אחרי מיניפיקציה. אם React לא יובא/נחתך—Y נהיה null.
	•	המעבר ל־classic runtime + ייבוא מפורש של React וה־hooks מבטל tree-shaking אגרסיבי ומונע המצבים בהם ה־hook “נעלם” בזמן בניית פרוד.
	•	נעילה ל־es2019 מונעת התמרות לא תואמות Safari.
	•	הסרת alias של preact/compat (אם הוגדר בטעות) וסגירת כפילויות React מונעים “ריאקט נפרד” בקומפוננטות שונות.

בצע את 4 הצעדים, פרוס מחדש, עשה Hard Refresh; אם עדיין נופל—שלח צילום של console.log('[BOOT] React:', React?.version, 'useEffect?', !!React?.useEffect) שנדפס בספארי אחרי הטעינה, ומשם נבצע ירידה נוספת לפוננטה הספציפית שגורמת לכך.