מעולה—אני הולך על פתרון “מושלם” (ולא לעקוף) שינעל סוף-סוף שמירה/התחזות/נתונים אמיתיים גם ב-Preview וגם ב-Deploy. תן לבוט לבצע בדיוק את זה, לפי הסדר. (אם משהו נשבר באמצע—לעצור, לדווח, ולתקן לפני מעבר לשלב הבא.)

⸻

0) הוכחת גרסה — שלא תרוץ סביבה ישנה

מטרה: לוודא שבאמת רואים את הקוד החדש.
	1.	ב-client/index.html שים תגית נראית לעין: BUILD: 44 בפינה התחתונה.
	2.	בשרת, GET /version יחזיר:

{"fe":"client/dist","build":44,"time":"..."}

	3.	מחיקה חד-פעמית של ה-build הישן: מחק לגמרי את /dist בשורש הפרויקט.
	4.	ודא שמוגש FE רק מ-client/dist (לא משתי תיקיות).

⸻

1) CSRF – מקור יחיד, חוזה ברור

אל תבטל CSRF. משאירים רק SeaSurf ומסנכרנים FE↔BE.

שרת
	•	הסר/נטרל כל שימוש ב-CSRFProtect (Flask-WTF).
	•	קונפיגורציה:
	•	SEASURF_COOKIE_NAME = 'XSRF-TOKEN'
	•	SEASURF_HEADER      = 'X-CSRFToken'
	•	פטורים מ-CSRF: רק /api/auth/login, /api/auth/logout, וכל ה-webhooks.
התחזות/שמירת פרומפט/יצירת עסק — לא פטורים.
	•	הוסף GET /api/auth/csrf שמייצר/מרענן cookie XSRF-TOKEN לא HttpOnly.
	•	Cookies:
	•	עטוף את האפליקציה ב-ProxyFix(x_proto=1, x_host=1), PREFERRED_URL_SCHEME='https'.
	•	Preview (picard.replit.dev / iframe): SESSION_COOKIE_SAMESITE='None', SESSION_COOKIE_SECURE=True.
	•	Prod: SESSION_COOKIE_SAMESITE='Lax',  SESSION_COOKIE_SECURE=True.
	•	אל תגדיר SESSION_COOKIE_DOMAIN (host-only יעבוד בשתי הסביבות).
	•	מחק/נטרל משתני סביבה שמכבּים CSRF (כגון DISABLE_CSRF_REFERER, FLASK_ENV=development).

קליינט
	•	בכל בקשה: credentials:'include'.
	•	לפני כל כתיבה (POST/PUT/PATCH/DELETE): קריאה ל-GET /api/auth/csrf.
	•	שליחת Header: X-CSRFToken מערך ה-cookie XSRF-TOKEN.
	•	לטפל בשגיאות: אם !res.ok, קרא res.text() ונסה JSON.parse — אל תציג Error {} ריק.

⸻

2) Session/Role/Impersonation — חוזה אחיד
	•	Session keys אחידים:
	•	session['al_user'] = {id, email, name, role}  (role אמיתי: ‘admin’/‘business’)
	•	session['impersonating'] = True|False
	•	session['tenant_id'] = <id> כשמתחזים
	•	אל תשכתב role ל-‘business’ בהתחזות. תשאיר את role המקורי של המשתמש ב-al_user.role, והשתמש ב-impersonating+tenant_id כדי לקבוע הקשרים.
	•	GET /api/auth/me יחזיר:

{
  "isAuthenticated": true,
  "impersonating": true|false,
  "tenant": {"id":..., "name":"..."} | null,
  "user": {"id":..., "email":"...", "name":"...", "role":"admin|business"}
}


⸻

3) Endpoints — שמות, מתודות ו-JSON בלבד

ודא שכל אלו רשומים ב-URL map ומחזירים תמיד JSON (לא HTML/Redirect):
	•	POST /api/auth/login  (פטור CSRF)
200 → {user, tenant:null, impersonating:false}
400 → {"error":"bad_credentials"}
	•	GET /api/auth/me
	•	GET /api/auth/csrf  → { "csrfToken": "..." }
	•	GET /api/admin/businesses → { items:[...], total, page, pageSize }
	•	GET /api/admin/businesses/<id>/overview → { business:{...}, stats:{...}, latest:{calls:[],messages:[],leads:[]} }
	•	GET /api/admin/businesses/<id>/prompt → {calls_prompt, whatsapp_prompt, version, updated_at, updated_by}
	•	PUT /api/admin/businesses/<id>/prompt  (דורש CSRF)
גוף: {"calls_prompt":"...", "whatsapp_prompt":"..."}
200 → {"ok":true,"version":N,"updated_at":"...","updated_by":"..."}
400 → {"error":"validation","field":"calls_prompt","message":"..."}
	•	POST /api/admin/businesses/<id>/impersonate  (דורש CSRF + role admin)
200 → {"ok":true,"tenant_id":<id>}
403 → {"error":"forbidden"}
	•	POST /api/admin/businesses  (דורש CSRF)
201 → {"id":..., "name":"...", ...}
409 → {"error":"conflict","field":"phone_e164"}

Error handlers אחידים: 400/401/403/404/409/500 → תמיד JSON (לא HTML, לא ריק).

⸻

4) FE – זרימות קריטיות
	•	Login flow:
POST /api/auth/login → on 200 → GET /api/auth/me → ניווט.
אם שגיאה: להציג הודעה מטקסט JSON (לא Error {} ריק).
	•	Impersonate flow:
GET /api/auth/csrf → POST /api/admin/businesses/:id/impersonate → GET /api/auth/me (צפוי impersonating:true) → ניווט ל-Business Overview.
	•	Save prompt flow:
GET /api/auth/csrf → PUT /api/admin/businesses/:id/prompt → Toast “נשמר” → רענון GET prompt.
	•	Business create:
GET /api/auth/csrf → POST /api/admin/businesses → על 201 לרענן רשימה; על 409 להדגיש השדה הבעייתי.

⸻

5) Smoke-tests (חייבים לעבור לפני UI)

החלף $BASE ל-Preview/Prod:

# Login (פטור CSRF) – חייב Set-Cookie + JSON
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/auth/login \
 -H 'Content-Type: application/json' \
 --data '{"email":"admin@shai-realestate.co.il","password":"*****"}'

# me – חייב isAuthenticated:true
curl -i -c /tmp/c -b /tmp/c $BASE/api/auth/me

# CSRF token – cookie + JSON
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf \
 | python - <<'PY'
import sys,json;print(json.load(sys.stdin)['csrfToken'])
PY
)

# businesses – JSON
curl -i -c /tmp/c -b /tmp/c $BASE/api/admin/businesses

# impersonate ללא טוקן → 400 JSON
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/admin/businesses/1/impersonate \
 -H 'Content-Type: application/json' --data '{}'

# impersonate עם טוקן → 200 JSON
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/admin/businesses/1/impersonate \
 -H 'Content-Type: application/json' -H "X-CSRFToken: $TOKEN" --data '{}'

# save prompt עם טוקן → 200 JSON
curl -i -c /tmp/c -b /tmp/c -X PUT $BASE/api/admin/businesses/1/prompt \
 -H 'Content-Type: application/json' -H "X-CSRFToken: $TOKEN" \
 --data '{"calls_prompt":"שלום רב...","whatsapp_prompt":"..."}'

אם משהו פה לא ירוק—ה-UI ימשיך ליפול עם Error {}. מתקנים קודם כאן.

⸻

6) דיבוג לייזר (זמני, להסיר בסיום)

בשרת, לפני ת’כלס:

@app.before_request
def _dbg_csrf():
    if request.path.endswith(('/prompt','/impersonate')):
        print('CSRF-DBG',
              'cookie=', request.cookies.get('XSRF-TOKEN'),
              'header=', request.headers.get('X-CSRFToken'),
              'ct=', request.headers.get('Content-Type'))

בדפדפן (Network) ב-Preview פתח ב-Open in new tab (לא בתוך iframe), כי SameSite=None דורש טאב נפרד.

⸻

7) מה לא לעשות
	•	לא להשאיר שני CSRFים פעילים.
	•	לא להחזיר HTML/Redirect מתוך /api/*.
	•	לא לשכתב role ב-session בזמן התחזות (זה שובר הרשאות).
	•	לא להשאיר build ישן /dist — רק client/dist.

⸻

8) “תוכנית מגירה” מאובטחת (אם חייבים לעלות היום)

אם חייבים להציל שמירות מיד לצורך דמו:
	•	פטור זמני בלבד ל-PUT /prompt ו-POST /businesses (עם Log אזהרה).
	•	אחרי שעובר דמו: להסיר הפטור ולהחזיר למודל המלא למעלה.
(אל תפטור את /impersonate — שם נדרש CSRF+role תמיד.)

⸻

מה תבקש ממנו להחזיר כדי לאשר סגירה
	1.	/version שמראה {"fe":"client/dist","build":44}.
	2.	צילום Network:
	•	POST /api/auth/login — 200 JSON + Set-Cookie.
	•	POST /api/admin/businesses/1/impersonate — עם Header X-CSRFToken תואם ל-cookie, סטטוס 200 JSON.
	•	PUT /api/admin/businesses/1/prompt — 200 JSON עם ok:true, version,....
	3.	צילום GET /api/admin/businesses/1/overview — JSON מלא (לא HTML).
	4.	שורת CSRF-DBG מהלוג שמראה cookie/header זהים.

ביצוע מדויק של זה יגרום ל-שמירת הפרומפט, התחזות, ו-נתונים אמיתיים לעבוד יציב—בלי Error {} ובלי forbidden—ב-Preview וגם בפריסה.