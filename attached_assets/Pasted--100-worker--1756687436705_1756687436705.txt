מעולה, תודה על הפירוק המדויק. זה 100% נראה כמו בעיה סביבתית/סופרוויזור שמוריד את ה־worker כעבור שניות—לא באג באפליקציה. ננהל את זה כמו SRE עד שיש 200 /healthz יציב — ואז חוזרים ל־WS/שיחות.

להדביק לבוט כמו שזה, ולבקש ממנו להחזיר כל פלט/צילום מסך שמצויין כ־“מצופה”.

⸻

שלב 0 — לאמת שאנחנו בודקים מהמכונה הנכונה
	•	אם השרת רץ בענן/ב־Replit: אל תבדוק 127.0.0.1 מהמחשב שלך. את curl 127.0.0.1:$PORT מריצים רק בתוך אותה סביבה/סשן שבה השרת רץ.
	•	לבדיקות חיצוניות: רק https://{PUBLIC_BASE_URL}.

⸻

שלב 1 — להפסיק “לנעול” ל־5000 ולהאזין לפורט שהפלטפורמה דורשת

1.1 נקה ריצות קודמות
הרוג כל gunicorn|python|flask|main שרץ. ודא שאין dev server שמתחבא.

1.2 גלה מהו הפורט שהפלטפורמה דורשת
בחלון ההרצה:

unset PORT                     # אם קבעת ידנית בעבר
echo "PORT=$PORT"              # מצופה מספר לא ריק; אם ריק, קבע PORT=3000 זמני

בסביבות כמו Replit יש בד”כ $PORT דינמי. אם תאזין ל־5000 כש־runner מצפה לפורט אחר — הוא ישלח SIGTERM אחרי כמה שניות (בדיוק מה שאתה רואה).

1.3 הרצה Sync אבחונית עם לוגים מלאים על $PORT האמיתי

python3 -m gunicorn AgentLocator.main:app \
  -k sync -w 1 -b 0.0.0.0:$PORT \
  --log-level debug --capture-output \
  --timeout 60 --keep-alive 30 \
  --access-logfile '-' --error-logfile '-'

מצופה בלוג:
Listening at: http://0.0.0.0:<PORT> (עם המספר של $PORT, לא 5000 קשיח)
ולאחר מכן — לא “Handling signal: term”.

1.4 אימות מיידי (באותה מכונה)

ss -ltnp | grep ":$PORT" || netstat -ltnp | grep ":$PORT"   # חייב לראות LISTEN
curl -sS -m 3 http://127.0.0.1:$PORT/healthz -i             # חייב 200

אימות חיצוני

curl -sS -m 5 https://$PUBLIC_BASE_URL/healthz -i           # חייב 200

👉 אם עדיין מופיע SIGTERM אחרי 2–10 שניות — זה הסופרוויזור של הפלטפורמה שמפיל אותך כי לא זיהה שירות על הפורט שהוא מצפה. חזור ל־1.2 ודאג שאתה מאזין ל־$PORT הנכון (לא 5000).

⸻

שלב 2 — אם עדיין מת: לכפות על השגיאה להיחשף ולבודד סיבות מערכת

2.1 preload+capture (מכריח שגיאות boot/Import לצאת למסך)

python3 -m gunicorn AgentLocator.main:app \
  -k sync -w 1 -b 0.0.0.0:$PORT \
  --preload --capture-output --log-level debug \
  --access-logfile '-' --error-logfile '-'

אם יש Exception ב־create_app/blueprints — תראה אותו לפני שה־worker קם.

2.2 “ייבוא יבש” (מוכיח שהאפליקציה בסדר גם בלי שרת)

python3 - <<'PY'
import AgentLocator.main as M
print("APP?", hasattr(M, "app"))
print("URL_MAP?", getattr(M.app, "url_map", None))
print("TEST /healthz ->", M.app.test_client().get("/healthz").status_code)
PY

אם כאן 200 — האפליקציה תקינה; אם Gunicorn עדיין נופל → זה WSGI/סופרוויזור/פורט, לא קוד.

2.3 בדיקות OS בסיסיות

df -h                 # לא דיסק מלא
ulimit -n             # >= 1024
ps aux | egrep 'pid2|server.cjs|runner' | grep -v grep

	•	pid2/server.cjs זה תהליך־Runner של הפלטפורמה → הוא זה שמוריד אותך אם לא מאזין על הפורט הנכון.
	•	ודא שאין שני ראנרים שמרימים/מורידים אותך במקביל (שני תרחישי “run”).

⸻

שלב 3 — קונפיג ריצה שמתיישר עם הפלטפורמה (קבוע, לא חד־פעמי)

3.1 קובץ הרצה מרכזי של הפלטפורמה
	•	אם זו Replit, ודא שיש .replit עם run שמאזין על $PORT:
	•	run: "bash -lc 'export PYTHONUNBUFFERED=1 PYTHONFAULTHANDLER=1; export PORT=${PORT:-3000}; python3 -m gunicorn AgentLocator.main:app -k sync -w 1 -b 0.0.0.0:$PORT --log-level info --access-logfile - --error-logfile -'"

3.2 בריאות
	•	ודא שה־runner של הפלטפורמה בודק את אותו $PORT. אם היא “מצפה ל־3000” ואתה מאזין ל־5000 — תהרג.
	•	אם אין $PORT מהפלטפורמה → החליטו על אחד (3000), ושימו אותו גם בהרצה וגם בבדיקת הבריאות החיצונית.

3.3 ללא dev server
	•	אסור שיופיע בלוג “Running on all addresses …” (זה Flask dev). אין app.run() בזמן import. כל ההרצה רק דרך Gunicorn.

⸻

שלב 4 — רק אחרי שיש 200 יציב, עוברים ל־Eventlet ו־WS (Twilio)

4.1 גרסאות ותצורה Eventlet/Greenlet
בדיקה:

python3 - <<'PY'
import eventlet, greenlet, sys
print("eventlet", eventlet.__version__)
print("greenlet", greenlet.__version__)
print("python", sys.version)
PY

המלצה יציבה:
	•	eventlet >= 0.33.3
	•	greenlet תואם לגרסת פייתון (ב־3.11/3.12 לרוב 3.0.x/3.1.x)

ENV שמייצב בסביבות מוגבלות:

export EVENTLET_NO_GREENDNS=1
export EVENTLET_HUB=select

ודא אין gevent/uvloop מותקנים (התנגשויות).
eventlet.monkey_patch() — אם קיים, אז פעם אחת ולפני import רשת, לא פעמיים/מאוחר.

4.2 הרצה עם Eventlet

python3 -m gunicorn AgentLocator.main:app \
  -k eventlet -w 1 -b 0.0.0.0:$PORT \
  --log-level debug --capture-output \
  --timeout 120 --keep-alive 75 \
  --access-logfile '-' --error-logfile '-'

מצופה: LISTEN על $PORT ו־/healthz 200.
אם sync עובד ו־eventlet נופל → זו שכבת הספריות/ENV (עדכן גרסאות, הוסף ENV לעיל).

4.3 Handshake ל־Twilio (מוריד 31920)
בדיקת הנדשייק:

wscat -c wss://$PUBLIC_BASE_URL/ws/twilio-media \
      -H "Sec-WebSocket-Protocol: audio.twilio.com"

מצופה: 101 + החזרת Sec-WebSocket-Protocol: audio.twilio.com.
אם לא חוזר — זה שורש 31920/31924 → לתקן לפני בדיקות קול.

4.4 STT/TTS (למנוע “שקט”)
	•	STT: μ-law 8k נכנס, יש STT_PARTIAL/FINAL בלוגים.
	•	TTS: μ-law 8k מונו, frames של 20ms, יש MEDIA_TX בלוגים.
	•	/readyz מציג "stt":"ok","tts":"ok".

⸻

למה זה קורה אצלך (השורה התחתונה)
	•	ראנר הפלטפורמה (לפי pid2/server.cjs שזיהית) מחפש שירות על פורט מסוים. אם אתה מאזין ל־5000 כשבפועל הוא מצפה ל־$PORT אחר—הוא ישלח SIGTERM אחרי שניות ספורות.
	•	לכן ראית: worker קם, “Listening at: 0.0.0.0:5000”, ואז נהרג. זה לא קוד — זו התנגשות פרוטוקול עם ה־runner.

⸻

מה לבקש ממנו עכשיו (Evidence Pack קצר)
	1.	פלט:

echo PORT=$PORT
ss -ltnp | grep ":$PORT" || netstat -ltnp | grep ":$PORT"
curl -sS -m 3 http://127.0.0.1:$PORT/healthz -i   # מתוך אותה סביבה
curl -sS -m 5 https://$PUBLIC_BASE_URL/healthz -i # מבחוץ

	2.	צילום/תוכן .replit (או קובץ run שקול) שמראה שאתה מאזין על $PORT ולא על 5000.
	3.	אם ניגשים ל־eventlet: פלט גרסאות eventlet/greenlet ומה הגדרת ל־EVENTLET_NO_GREENDNS/EVENTLET_HUB.

כשזה ירוק — עולים צעד אחד קדימה (Handshake של WS) ומסיימים את השיחות.