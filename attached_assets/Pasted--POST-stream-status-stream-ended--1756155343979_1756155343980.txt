חד וחלק: אם יישמת את שלושת התיקונים האחרונים (פתיחת POST ל-/stream_status ו־/stream_ended, ביטול ה־// הכפול ב-URLs, והחזרת תת-פרוטוקול audio.twilio.com בהנד־שייק של ה-WS) — זה אמור לעבוד. כדי להפוך את זה ל-100% ודאות, צירפתי למטה הנחיה אחת, סופית ומלאה (כולל Baileys) + בדיקות עשן שמוכיחות מיד בשטח.

⸻

הנחיה אחת — AgentLocator: ריצה מושלמת (Twilio + Baileys)

עקרונות: Idempotent, בלי כפילויות, לא לשבור כלום. אם חסר — מוסיפים. אם קיים — לא נוגעים.

0) הגדרות סביבה (ENV)
	•	PUBLIC_BASE_URL=https://ai-crmd.replit.app (ללא / בסוף)
	•	PORT (מוגדר ע״י הפלטפורמה)
	•	WHATSAPP_PROVIDER=twilio (ברירת מחדל; ניתן לעקוף פר-בקשה)
	•	BAILEYS_PORT=4001
	•	BAILEYS_WEBHOOK=http://127.0.0.1:5000/webhook/whatsapp/baileys
	•	(אופציונלי לאבטחה) BAILEYS_SECRET=...

⸻

1) Twilio — Webhooks & TwiML (Python)

קובץ: AgentLocator/server/routes_twilio.py
	•	ודאו שה־Blueprint נרשם: twilio_bp = Blueprint("twilio_bp", __name__) בלי url_prefix="/webhook" פעמיים.
	•	פונקציית עזר ל־URLs מוחלטים (מונע // כפול):

def abs_url(path: str) -> str:
    base = current_app.config.get("PUBLIC_BASE_URL", "").rstrip("/")
    return f"{base}/{path.lstrip('/')}"

	•	/webhook/stream_status — ללא חתימה, POST בלבד, מחזיר 204 מהר:

@twilio_bp.post("/webhook/stream_status")
def stream_status():
    form = request.form.to_dict(flat=True)
    print(f"STREAM_STATUS call={form.get('CallSid')} stream={form.get('StreamSid')} event={form.get('Status')}")
    return ("", 204)

	•	/webhook/stream_ended — POST; אפשר בלי חתימה (מומלץ ליציבות) ומחזיר 204:

@twilio_bp.post("/webhook/stream_ended")
def stream_ended():
    form = request.form.to_dict(flat=True)
    print(f"STREAM_ENDED call={form.get('CallSid')} stream={form.get('StreamSid')} status={form.get('Status')}")
    return ("", 204)

	•	/webhook/incoming_call — POST + חתימה (אבטחה), TwiML ללא <Play>:

@twilio_bp.route("/webhook/incoming_call", methods=["POST"])
@require_twilio_signature  # השאירו חתימה כאן
def incoming_call():
    call_sid = request.values.get("CallSid","")
    wss_host = current_app.config.get("PUBLIC_BASE_URL","").replace("https://","").replace("http://","").rstrip("/")
    twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Connect action="{abs_url('/webhook/stream_ended')}">
    <Stream url="wss://{wss_host}/ws/twilio-media"
            statusCallback="{abs_url('/webhook/stream_status')}">
      <Parameter name="call_sid" value="{call_sid}"/>
    </Stream>
  </Connect>
</Response>"""
    return Response(twiml, mimetype="text/xml")

	•	תצוגה ידנית (אופציונלי לבדיקה) — GET, בלי חתימה:

@twilio_bp.get("/webhook/incoming_call_preview")
def incoming_call_preview():
    return incoming_call()  # נוח ל-GET ידני


⸻

2) WebSocket למדיה — simple-websocket + תת-פרוטוקול

קובץ: AgentLocator/server/media_ws.py (או לפי הקובץ אצלך)

from simple_websocket import Server, ConnectionClosed
from flask import Blueprint, request

ws_bp = Blueprint("ws_bp", __name__)

@ws_bp.route("/ws/twilio-media", methods=["GET"])
def ws_twilio_media():
    # קריטי: החזירו את תת-הפרוטוקול שטוויליו דורשת
    offered = request.headers.get("Sec-WebSocket-Protocol","")
    headers = []
    if "audio.twilio.com" in offered:
        headers = [("Sec-WebSocket-Protocol", "audio.twilio.com")]
    ws = Server(request.environ, headers=headers)  # או protocols=["audio.twilio.com"] אם נתמך
    try:
        print("WS_CONNECTED")
        # (אופציונלי) keepalive: שלחו ping כל ~25s
        while True:
            msg = ws.receive()  # כאן מקבלים פריימי אודיו/בקרה
            if msg is None:
                break
            # עבדו עם הפריימים (תמלול/RTT וכו')
    except ConnectionClosed:
        print("WS_END")
    finally:
        try: ws.close()
        except: pass
    return ("", 204)

# לאחד גם עם סלאש בסוף, למניעת 404/Handshake מוזרים
@ws_bp.route("/ws/twilio-media/", methods=["GET"])
def ws_twilio_media_slash():
    return ws_twilio_media()

הערה: אם אתם מייבאים current_app.logger מתוך thread WS — החליפו ל־print() או logging.getLogger(__name__) בלי extra=.

⸻

3) WhatsApp — Twilio (Inbound/Outbound) + CRM
	•	Inbound (קיים): /webhook/whatsapp/twilio — החזירו 204 ושמרו in/received ל-CRM.
	•	Outbound (שדרוג קטן): לאפשר גם text וגם בחירת ספק פר-בקשה:

@whatsapp_unified_bp.route("/api/whatsapp/send", methods=["POST"])
def send_message():
    data = request.get_json() or {}
    to = data.get("to")
    text = data.get("message") or data.get("text")
    provider = (data.get("provider") or os.getenv("WHATSAPP_PROVIDER","twilio")).lower()
    if not to or not text:
        return jsonify({"success":False,"error":"Missing to/text"}), 400

    if provider == "twilio":
        sid = send_via_twilio_and_get_sid(to, text)  # הפונקציה שכבר קיימת אצלך
    elif provider == "baileys":
        sid = send_via_baileys_local(to, text)       # ראה סעיף 4
    else:
        return jsonify({"success":False,"error":"Unsupported provider"}), 400

    dao_crm.upsert_thread(to, provider=provider)
    dao_crm.insert_message(to, direction="out", text=text, provider=provider, status="sent", external_id=sid)
    return jsonify({"success":True,"sid":sid})


⸻

4) Baileys — גשר Node מקומי (אופציונלי אך מומלץ)

תיקייה: AgentLocator/baileys/

package.json (מינימום):

{
  "type": "module",
  "dependencies": {
    "@whiskeysockets/baileys": "^6.7.8",
    "express": "^4.19.2",
    "pino": "^9.1.0",
    "qrcode-terminal": "^0.12.0"
  }
}

baileys-server.js:

import express from "express";
import makeWASocket, { useMultiFileAuthState } from "@whiskeysockets/baileys";
import Pino from "pino";

const app = express();
app.use(express.json({limit:"1mb"}));
const PORT = process.env.BAILEYS_PORT || 4001;
const WEBHOOK = process.env.BAILEYS_WEBHOOK || "";
const SECRET  = process.env.BAILEYS_SECRET || "";

const logger = Pino({ level: "info" });
const { state, saveCreds } = await useMultiFileAuthState("./auth");
const sock = makeWASocket({ auth: state, printQRInTerminal: true, logger });

sock.ev.on("creds.update", saveCreds);
sock.ev.on("messages.upsert", async (m) => {
  try {
    const msg = m.messages?.[0];
    if (!msg || !WEBHOOK) return;
    const from = msg.key.remoteJid;
    const text = msg.message?.conversation
              || msg.message?.extendedTextMessage?.text
              || "";
    await fetch(WEBHOOK, {
      method: "POST",
      headers: { "Content-Type": "application/json", "X-BAILEYS-SECRET": SECRET },
      body: JSON.stringify({ from, text, provider: "baileys" })
    });
  } catch(e){ console.error("WB_INBOUND_ERR", e); }
});

app.post("/sendMessage", async (req, res) => {
  try {
    const { to, text } = req.body || {};
    if (!to || !text) return res.status(400).json({ ok:false, error:"Missing to/text" });
    const jid = to.replace(/^whatsapp:/,"");
    const resp = await sock.sendMessage(jid, { text });
    return res.json({ ok:true, result: resp });
  } catch(e){ console.error("WB_SEND_ERR", e); res.status(500).json({ ok:false, error:String(e) }); }
});

app.listen(PORT, () => console.log(`Baileys bridge on :${PORT}`));

Python — אינבאונד מהגשר:

@whatsapp_bp.post("/webhook/whatsapp/baileys")
def webhook_baileys():
    if os.getenv("BAILEYS_SECRET") and request.headers.get("X-BAILEYS-SECRET") != os.getenv("BAILEYS_SECRET"):
        return ("", 403)
    data = request.get_json() or {}
    frm, txt = data.get("from"), data.get("text","")
    if not frm: return ("", 204)
    dao_crm.upsert_thread(frm, provider="baileys")
    dao_crm.insert_message(frm, direction="in", text=txt, provider="baileys", status="received")
    return ("", 204)

Python — שליחה דרך הגשר (הפונקציה שהוזכרה בסעיף 3):

def send_via_baileys_local(to: str, text: str) -> str:
    url = f"http://127.0.0.1:{int(os.getenv('BAILEYS_PORT',4001))}/sendMessage"
    r = requests.post(url, json={"to": to, "text": text}, timeout=10)
    r.raise_for_status()
    return (r.json().get("result") or {}).get("key",{}).get("id","")

הרצה משותפת (אותו דיפלוי):
AgentLocator/start_all.sh

#!/bin/bash
set -e
export BAILEYS_PORT=${BAILEYS_PORT:-4001}
( cd AgentLocator/baileys && npm ci --omit=dev && node baileys-server.js ) &
python3 -m gunicorn -k eventlet -w 1 -b 0.0.0.0:$PORT AgentLocator.main:app

או Procfile:

web: bash start_all.sh


⸻

5) תשלומים — קודי שגיאה נכונים

קובץ: AgentLocator/server/api_crm_unified.py (ב־/api/crm/payments/create), לפני create_payment_link(...):

from server.providers.payments import sys_enabled

if not sys_enabled():
    return jsonify({"error":"Payments system disabled"}), 501
if not getattr(biz, "payments_enabled", False):
    return jsonify({"error":"Payments disabled for this business"}), 403

eff = (provider or biz.default_provider or "paypal").lower()
if eff == "paypal" and not (gw and gw.paypal_client_id and gw.paypal_secret):
    return jsonify({"error":"PayPal not configured"}), 501
if eff == "tranzila" and not (gw and gw.tranzila_terminal):
    return jsonify({"error":"Tranzila not configured"}), 501
# Stripe הישן:
# /payments/create-intent -> החזר 410, בלי import stripe


⸻

6) דיפלוי (חסין נתיב) + בריאות
	•	Procfile / start_all.sh:
AgentLocator.main:app (אל תסתמך על cwd).
	•	נקודות בריאות: /, /healthz, /readyz, /version → 200; /version מחזיר DEPLOY_ID/COMMIT.

⸻

בדיקות עשן (להעתקה מיידית)

A. Twilio callbacks (צפוי 204):

curl -i -X POST "$PUBLIC_BASE_URL/webhook/stream_status" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data "CallSid=CA_TEST&StreamSid=MZ_TEST&Status=connected"

curl -i -X POST "$PUBLIC_BASE_URL/webhook/stream_ended" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data "CallSid=CA_TEST&StreamSid=MZ_TEST&Status=completed"

B. TwiML (תצוגה ידנית):

GET $PUBLIC_BASE_URL/webhook/incoming_call_preview
# מצופה: Connect+Stream עם action/statusCallback מוחלטים, בלי //

C. WS Handshake (קריטי ל-31920):
התחבר לכלי WS אל: wss://{HOST}/ws/twilio-media
בדוק ב-response headers שמוחזר:

Sec-WebSocket-Protocol: audio.twilio.com

D. שיחה חיה (Twilio Request Inspector):
	•	POST /webhook/stream_status = 204 (אין 15003)
	•	POST /webhook/stream_ended = 204
	•	אין 31920; ה-AI מדבר מיד (אין <Play>)

E. WhatsApp outbound (Twilio):

curl -s -X POST "$PUBLIC_BASE_URL/api/whatsapp/send" \
  -H "Content-Type: application/json" \
  -d '{"to":"whatsapp:+9725XXXXXXX","text":"בדיקה","provider":"twilio"}'
# מצופה: success=true ונרשם ב-CRM כ-out/sent

F. WhatsApp outbound (Baileys):

curl -s -X POST "$PUBLIC_BASE_URL/api/whatsapp/send" \
  -H "Content-Type: application/json" \
  -d '{"to":"whatsapp:+9725XXXXXXX","text":"בדיקה","provider":"baileys"}'
# מצופה: success=true ונרשם ב-CRM כ-out/sent

G. תשלומים ללא מפתחות:
	•	PayPal/Tranzila לא מוגדרים → 501
	•	עסק חסום → 403
	•	Stripe ישן → 410

⸻

תשובה ישירה
	•	האם עכשיו הכל עובד? אם שלושת התיקונים שהדגשנו נעשו (POST פתוח ל-callbacks, URLs נקיים, והחזרת audio.twilio.com ב-WS), אז כן — זה אמור לעבוד.
	•	איך אני בטוח? הרץ את בדיקות העשן למעלה; אם כולן ירוקות + ב-Twilio Request Inspector אתה רואה stream_status=204 ואין 31920 — זה GO סופי.

אם תרצה, אכין לך גרסת patch אחת מאוחדת (.patch) + סקריפט smoke.sh שמבצע את כל הבדיקות בלחיצה אחת.