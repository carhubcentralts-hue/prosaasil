מעולה—הנה חבילת הנחיות “העתק-הדבק” שתופרת את כל המערכות שלך ל-AgentKit, באותו סטנדרט שבנית עבור פגישות/וואטסאפ. זה כולל כלים (tools) מוכנים ל-CRM/לידים, חשבוניות/תשלומים, חוזים/חתימות, סיכומים, וואטסאפ דרך Baileys, וקישור הדוק ביניהם — עם ממשקי API, סכימות קלט/פלט, הוראות Agent מדויקות, ובדיקות עשן.

0) עקרונות עבודה (כבר אצלך, רק לוודא)
	•	הוראות פנימיות של Agent באנגלית; תשובות ללקוח בעברית.
	•	tool_choice=“required”, strict=True, temperature=0.2, max_output_tokens≈200.
	•	כל tool מחזיר {“ok”:true|false,…} ולא זורק Exception; על שגיאה → האייג׳נט שואל הבהרה קצרה ומנסה שוב.
	•	context בכל run: business_id, tz=“Asia/Jerusalem”, locale=“he-IL”, channel=(“voice”|“whatsapp”|“web”), customer_phone (אם יש), whatsapp_from (אם יש), conversation_id/call_id.
	•	messages=[…] (8–12 הודעות אחרונות) כדי לשמר הקשר ולמנוע “שלום שוב”.

1) Leads/CRM — יצירה, חיפוש, עידכון וקישור לפגישה

server/agents/tools_leads.py

from openai_agents import tool
from pydantic import BaseModel, Field
from typing import Optional, List, Literal
from datetime import datetime

class LeadUpsertIn(BaseModel):
    business_id: str
    name: str = Field(..., description="Full name")
    phone: Optional[str] = None
    channel: Literal["voice","whatsapp","web","agent"] = "agent"
    tags: Optional[List[str]] = None
    notes: Optional[str] = None
    appointment_id: Optional[str] = None  # לקישור לפגישה אם קיימת

class LeadOut(BaseModel):
    ok: bool
    lead_id: Optional[str] = None
    reason: Optional[str] = None

@tool(
    name="leads.upsert",
    description="Create or update a lead by phone/name and return lead_id. Always supply business_id.",
    input_model=LeadUpsertIn, output_model=LeadOut
)
def leads_upsert(input: LeadUpsertIn) -> LeadOut:
    try:
        # 1) חפש לפי business_id + phone (אם יש) או name
        lead_id = repo.leads_upsert(
            business_id=input.business_id,
            name=input.name, phone=input.phone,
            channel=input.channel, tags=input.tags or [],
            notes=input.notes, appointment_id=input.appointment_id
        )
        return LeadOut(ok=True, lead_id=lead_id)
    except Exception as e:
        return LeadOut(ok=False, reason=str(e)[:160])

class LeadSearchIn(BaseModel):
    business_id: str
    query: str = Field(..., description="name or phone")
    limit: int = 5

class LeadSearchOut(BaseModel):
    ok: bool
    matches: List[dict] = []

@tool(
    name="leads.search",
    description="Search leads by name/phone for this business_id.",
    input_model=LeadSearchIn, output_model=LeadSearchOut
)
def leads_search(input: LeadSearchIn) -> LeadSearchOut:
    try:
        rs = repo.leads_search(input.business_id, input.query, input.limit)
        return LeadSearchOut(ok=True, matches=rs)
    except Exception as e:
        return LeadSearchOut(ok=False, matches=[],)

DB/קישוריות:
	•	leads: id, business_id, name, phone NULLABLE, channel, tags[], notes, created_at.
	•	appointments: id, business_id, customer_name, phone NULLABLE, start, end, treatment_type, lead_id NULLABLE.
	•	בעת יצירת פגישה: אם יש lead_id → עדכן appointments.lead_id; אם אין → אחרי create_event קרא leads.upsert עם appointment_id.

2) חשבוניות ותשלומים

server/agents/tools_invoices.py

from openai_agents import tool
from pydantic import BaseModel, Field
from typing import Optional, Literal, List

class InvoiceCreateIn(BaseModel):
    business_id: str
    lead_id: Optional[str] = None
    appointment_id: Optional[str] = None
    customer_name: str
    customer_phone: Optional[str] = None
    currency: Literal["ILS","USD"] = "ILS"
    vat_rate: float = 0.17
    items: List[dict] = Field(..., description="[{description, quantity, unit_price}]")
    issue_status: Literal["draft","final"] = "final"
    send_channel: Optional[Literal["whatsapp","sms","email"]] = None

class InvoiceCreateOut(BaseModel):
    ok: bool
    invoice_id: Optional[str] = None
    payment_link: Optional[str] = None
    reason: Optional[str] = None

@tool(
  name="invoices.create",
  description="Create invoice (draft/final). Optionally send via WA/SMS/email and include payment link.",
  input_model=InvoiceCreateIn, output_model=InvoiceCreateOut
)
def invoices_create(input: InvoiceCreateIn) -> InvoiceCreateOut:
    try:
        inv_id, payment_url = billing_service.create_invoice(
            business_id=input.business_id, lead_id=input.lead_id,
            appointment_id=input.appointment_id, customer_name=input.customer_name,
            customer_phone=input.customer_phone, currency=input.currency,
            vat_rate=input.vat_rate, items=input.items, issue_status=input.issue_status
        )
        # שליחה לפי צורך
        if input.send_channel and payment_url:
            notify_service.send_invoice_link(
                channel=input.send_channel, business_id=input.business_id,
                to_phone=input.customer_phone, invoice_id=inv_id, url=payment_url
            )
        return InvoiceCreateOut(ok=True, invoice_id=inv_id, payment_link=payment_url)
    except Exception as e:
        return InvoiceCreateOut(ok=False, reason=str(e)[:160])

class PaymentLinkIn(BaseModel):
    business_id: str
    invoice_id: str

class PaymentLinkOut(BaseModel):
    ok: bool
    payment_link: Optional[str] = None
    reason: Optional[str] = None

@tool(
  name="payments.link",
  description="Generate or fetch a payment link for invoice_id.",
  input_model=PaymentLinkIn, output_model=PaymentLinkOut
)
def payments_link(input: PaymentLinkIn) -> PaymentLinkOut:
    try:
        url = billing_service.get_or_create_payment_link(input.business_id, input.invoice_id)
        return PaymentLinkOut(ok=True, payment_link=url)
    except Exception as e:
        return PaymentLinkOut(ok=False, reason=str(e)[:160])

הערות:
	•	אל תכשילו יצירה בלי טלפון — phone יכול להיות None (כמו בפגישות); אם צריך לשלוח קישור אחר כך, השתמשו ב-DTMF/WA.
	•	ודאו שה-invoice.payment_id קיים בסכמה אם אתם משתמשים בו.

3) חוזים/חתימות

server/agents/tools_contracts.py

from openai_agents import tool
from pydantic import BaseModel, Field
from typing import Optional, Dict

class ContractGenIn(BaseModel):
    business_id: str
    template_id: str
    lead_id: Optional[str] = None
    appointment_id: Optional[str] = None
    variables: Dict[str, str]  # {"customer_name":"...","date":"...","price":"..."}

class ContractGenOut(BaseModel):
    ok: bool
    contract_id: Optional[str] = None
    sign_url: Optional[str] = None
    reason: Optional[str] = None

@tool(
  name="contracts.generate_and_send",
  description="Generate contract from template and send for digital signature. Return contract_id and sign_url.",
  input_model=ContractGenIn, output_model=ContractGenOut
)
def contracts_generate_and_send(input: ContractGenIn) -> ContractGenOut:
    try:
        cid, url = contracts_service.generate_and_send(
            business_id=input.business_id, template_id=input.template_id,
            lead_id=input.lead_id, appointment_id=input.appointment_id,
            variables=input.variables
        )
        return ContractGenOut(ok=True, contract_id=cid, sign_url=url)
    except Exception as e:
        return ContractGenOut(ok=False, reason=str(e)[:160])

4) וואטסאפ דרך Baileys (וגם Twilio כגיבוי)

server/agents/tools_whatsapp.py

from openai_agents import tool
from pydantic import BaseModel, Field
from typing import Optional

class WhatsAppSendIn(BaseModel):
    business_id: str
    to_phone: Optional[str] = None
    whatsapp_from: Optional[str] = None  # אם מגיע מהקונטקסט
    text: str

class WhatsAppSendOut(BaseModel):
    ok: bool
    message_id: Optional[str] = None
    reason: Optional[str] = None

@tool(
  name="whatsapp.send",
  description="Send a WhatsApp message via Baileys. If to_phone missing, use context.whatsapp_from.",
  input_model=WhatsAppSendIn, output_model=WhatsAppSendOut
)
def whatsapp_send(input: WhatsAppSendIn, context=None) -> WhatsAppSendOut:
    try:
        to = input.to_phone or (context or {}).get("whatsapp_from")
        if not to:
            return WhatsAppSendOut(ok=False, reason="missing_to")
        mid = baileys_service.send_text(business_id=input.business_id, to=to, text=input.text)
        return WhatsAppSendOut(ok=True, message_id=mid)
    except Exception as e:
        # אופציונלי: גיבוי ל-Twilio אם Baileys נפל
        try:
            mid = twilio_wa_service.send_text(input.business_id, to, input.text)
            return WhatsAppSendOut(ok=True, message_id=mid)
        except Exception as e2:
            return WhatsAppSendOut(ok=False, reason=f"baileys/twilio failed: {str(e2)[:120]}")

טיפ: בברירת מחדל, אם הלקוח מבקש “שלח לי פרטים בווטסאפ”, האייג׳נט יקרא לכלי הזה עם text מוכן (אישור פגישה, קישור חשבונית/תשלום/חתימה).

5) סיכומים (שיחות ו-WA) עם פלט מובנה

server/agents/tools_summarize.py

from openai_agents import tool
from pydantic import BaseModel, Field
from typing import Optional, Dict, List

class SummarizeIn(BaseModel):
    business_id: str
    source: str = Field(..., description="call|whatsapp|conversation")
    source_id: str
    max_words: int = 120

class SummaryOut(BaseModel):
    ok: bool
    key_intent: Optional[str] = None
    chosen_treatment: Optional[str] = None
    preferred_time: Optional[str] = None
    next_step: Optional[str] = None
    sentiment: Optional[str] = None
    bullets: List[str] = []
    reason: Optional[str] = None

@tool(
  name="summarize.thread",
  description="Summarize a call/WA/conversation into structured fields for CRM notes.",
  input_model=SummarizeIn, output_model=SummaryOut
)
def summarize_thread(input: SummarizeIn) -> SummaryOut:
    try:
        # מחלץ מה-DB את הטקסט/תמלול, מעביר למודל פנימי אם צריך, מחזיר פלט מובנה
        s = summarizer_service.summarize(input.business_id, input.source, input.source_id, input.max_words)
        return SummaryOut(ok=True, **s)
    except Exception as e:
        return SummaryOut(ok=False, reason=str(e)[:160])

ב-CRM: שמור את התמצית בשדה notes/summary, וצרף תגים (intent=treatment_booking, urgency=high).

6) Agent Factory — רישום כל הכלים והוראות מדיניות

server/agents/agent_factory.py

from openai_agents import Agent
from server.agents.tools_calendar import calendar_find_slots, calendar_create_event
from server.agents.tools_leads import leads_upsert, leads_search
from server.agents.tools_invoices import invoices_create, payments_link
from server.agents.tools_contracts import contracts_generate_and_send
from server.agents.tools_whatsapp import whatsapp_send
from server.agents.tools_summarize import summarize_thread

def create_ops_agent():
    return Agent(
        model="gpt-5",
        instructions=(
          "You are an operations agent. Always respond in natural Hebrew. "
          "For booking: call calendar.find_slots, then calendar.create_event. "
          "If a tool returns ok=false (e.g., missing_business_id, validation_error), ask one brief clarification in Hebrew and retry. "
          "Never claim 'no availability' without a tool result. "
          "If no phone is available, proceed with booking; if needed, request DTMF digits (#) or use the caller/whatsapp number from context. "
          "When user asks to send details via WhatsApp, call whatsapp.send with the confirmation text. "
          "If the user requests an invoice or deposit link, call invoices.create or payments.link accordingly. "
          "If a contract is needed, call contracts.generate_and_send with the appropriate template and variables. "
          "After each call/thread, you may call summarize.thread for CRM notes."
        ),
        tools=[
          calendar_find_slots, calendar_create_event,
          leads_upsert, leads_search,
          invoices_create, payments_link,
          contracts_generate_and_send,
          whatsapp_send, summarize_thread
        ],
        strict=True, tool_choice="required",
        temperature=0.2, max_output_tokens=200
    )

7) API Endpoints — שמוש אחד לכולם

server/routes/agent_ops.py

from flask import Blueprint, request, jsonify
from server.agents.agent_factory import create_ops_agent
ops_bp = Blueprint("agent_ops", __name__)
ops_agent = create_ops_agent()

@ops_bp.post("/api/agent/ops")
def agent_ops():
    data = request.get_json(force=True)
    user_text = data.get("text","")
    history = data.get("messages", [])  # [{"role":"user","content":"..."},...]
    ctx = {
      "business_id": data.get("business_id","default"),
      "customer_phone": data.get("customer_phone"),
      "whatsapp_from": data.get("whatsapp_from"),
      "channel": data.get("channel","agent"),
      "tz": "Asia/Jerusalem",
      "locale": "he-IL",
      "conversation_id": data.get("conversation_id"),
      "duration_min": data.get("duration_min", 60),
      "user_text": user_text
    }
    result = ops_agent.run(messages=history + [{"role":"user","content":user_text}], context=ctx)
    return jsonify({
      "reply": result.output_text,
      "tool_calls": [c.dict() for c in result.tool_calls],
      "data": result.output_data
    }), 200

רישום ה-blueprint ב-app_factory.py כמו שעשית ל-booking.

8) Governance/Trace — לוג/טבלאות למעקב
	•	table agent_traces: id, ts, business_id, agent, conversation_id, tool_name, args_json, result_ok, error, latency_ms.
	•	בכל קריאת tool, כתוב trace קצר (או לוג). כך קל לדבג למה “לא נשלח וואטסאפ” או “לא נוצרה חשבונית”.

9) דיאלוגים טיפוסיים שהסוכן יבצע “קצה-לקצה”
	•	“שלח לי אישור בוואטסאפ” → whatsapp.send עם טקסט אישור + פרטי פגישה/קישור תשלום.
	•	“תוציא לי חשבונית מס ולינק לתשלום” → invoices.create(issue_status=“final”, send_channel=“whatsapp”) → payments.link (אם לא נוצר אוטומטית) → whatsapp.send עם הקישור.
	•	“תשלח לי חוזה קצר על טיפול סדרה” → contracts.generate_and_send(template_id=…) → whatsapp.send עם sign_url.
	•	“תסכם לי את השיחה” → summarize.thread → crm.add_note (אפשר להוסיף כלי קטן כזה אם תרצה).

10) בדיקות עשן (עשה אחת-אחת)

A פגישה + אישור ב-WA
POST /api/agent/ops
{“text”:“תקבע לי מחר ב10 עיסוי זוגי, שלח אישור בוואטסאפ”, “business_id”:“biz_1”,“channel”:“voice”,“customer_phone”:”+9725…”}
מצופה: tool_calls find_slots→create_event→whatsapp.send, reply בעברית, event_id נוצר.

B ליד אוטומטי מקישור פגישה
אחרי A, קרא leads.upsert עם appointment_id או בדוק שהוא נקרא אוטומטית לאחר create_event (לפי הלוגיקה שלך).

C חשבונית + תשלום
{“text”:“תוציא חשבונית על 420 שקלים ותשלח קישור תשלום בוואטסאפ”,“business_id”:“biz_1”,“whatsapp_from”:”+9725…”}
מצופה: invoices.create(final, send_channel=“whatsapp”)→payments.link (אם צריך)→whatsapp.send.

D חוזה
{“text”:“שלח לי חוזה קצר לטיפול סדרה, שם לקוח דני”,“business_id”:“biz_1”,“whatsapp_from”:”+9725…”}
מצופה: contracts.generate_and_send→whatsapp.send(sign_url).

E סיכום
{“text”:“תסכם את השיחה ותעדכן בCRM”,“business_id”:“biz_1”,“conversation_id”:“CALL123”}
מצופה: summarize.thread→crm.add_note (אם תוסיף כלי כזה).

11) דגשים אחרונים
	•	אל תדרוש טלפון כדי לקבוע פגישה/חשבונית — תמשיך גם בלעדיו, ואפשר לאסוף בטלפון ב-DTMF או מ-WhatsApp later.
	•	וודא pacing לשידור TTS כדי לא לראות “Send queue full”. שמור תשובות ≤ 24 מילים היכן שאפשר.
	•	הקפד על commit ל-DB בכל write (appointments, invoices, leads).
	•	ב-Deploy של Replit: אותם Secrets כמו ב-Workspace (AGENTS_ENABLED=1, מפתחות Baileys/Twilio, Billing, Contracts).

זהו. אחרי שתדביק את הקבצים/הכלים למעלה, ה-AgentKit שלך ינהל באמת את כל ה-Ops: פגישות, לידים, חשבוניות/תשלומים, חוזים/חתימות, וואטסאפ, וסיכומים — בעברית, עם פעולות בפועל, ובמדיניות קשיחה שמעדיפה כלי אמיתי על פני תשובה טקסטואלית.