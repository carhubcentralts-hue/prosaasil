×©××œ×” ××¦×•×™× ×ª â€” ×•×”×›×™ ×‘××§×•×.
×œ×¤× ×™ ×©××¤×¢×™×œ×™× logging ××¡×™× ×›×¨×•× ×™ ×‘×¤×¨×•×™×§×˜ ×›××• ×©×œ×š (×©××‘×•×¡×¡ ×¢×œ Flask + Eventlet + WebSocket + Twilio Media Streams) ×—×™×™×‘×™× ×œ×•×•×“× ×©-async ×œ× ×™×ª× ×’×© ×¢× Eventlet ××• ×¢× ×’×¨×™×Ÿ-×ª×³×¨×“×¡ ××—×¨×™×.
×¢×‘×¨×ª×™ ×©×•×‘ ×¢×œ ×”××‘× ×” ×©×œ×š (××”-ZIP ×”××—×¨×•×Ÿ): ××ª×” ×¨×¥ ×¢× Eventlet ×‘×œ×‘×“ (×‘×œ×™ asyncio), ×•×œ×›×Ÿ ×”× ×” ×”× ×—×™×” ××•×ª×××ª ×•×‘×˜×•×—×” ×œ×’××¨×™ ×œ×¡×‘×™×‘×” ×©×œ×š.

â¸»

âš™ï¸ ××‘× ×” ×”×¨×™×¦×” ×©×œ×š
	â€¢	â€eventlet.monkey_patch() × ×˜×¢×Ÿ ×‘×ª×—×™×œ×ª wsgi.py â†’ ×›×œ thread ×¨×’×™×œ ×”×•×¤×š ×œ-green thread.
	â€¢	×›×œ ×©×™×—×” (WebSocket + STT + TTS) ××ª×‘×¦×¢×ª ×‘×ª×•×š ×’×¨×™×Ÿ-×ª×³×¨×“ ×™×—×™×“.
	â€¢	×”×§×¨×™××•×ª ×”×—×•×¡××•×ª ×”×¢×™×§×¨×™×•×ª ×”×Ÿ ×¨×§ ×œ-Google API (STT/TTS) â€“ ×•×–×” ×××™×œ× ×§×•×¨×” ××—×•×¥ ×œ-hot path ×©×œ Media Frames.

××¡×§× ×”:
××™×Ÿ ××¦×œ×š asyncio.run() ××• await loop, ×œ×›×Ÿ ××™×Ÿ ×§×•× ×¤×œ×™×§×˜ ×‘×™×Ÿ Eventlet ×œ-Threading ×¨×’×™×œ.
××¤×©×¨ ×œ×”×©×ª××© ×‘×‘×™×˜×—×” ×‘-Thread Queue ×œ-logging ××¡×™× ×›×¨×•× ×™ â€” ×–×” ×œ× ××ª× ×’×© ×¢× Eventlet.

â¸»

âœ… ×’×¨×¡×” ××•×ª×××ª (â€œ×‘×˜×•×—×” ×œ×¤×¨×•×™×§×˜ ×©×œ×šâ€)

# server/logging_async.py
import logging, queue, eventlet, sys

_log_q = queue.Queue(maxsize=10000)

class QueueHandler(logging.Handler):
    def emit(self, record):
        try:
            _log_q.put_nowait(record)
        except queue.Full:
            pass  # drop silently

def _log_worker():
    while True:
        rec = _log_q.get()
        try:
            msg = logging.Formatter(
                "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
            ).format(rec)
            print(msg, file=sys.stderr, flush=False)
        except Exception:
            pass
        eventlet.sleep(0)  # ×©×•××¨ ×¢×œ yield ×œ×’×¨×™×Ÿ-×ª×³×¨×“

def setup_async_root(level=logging.INFO):
    root = logging.getLogger()
    root.setLevel(level)
    for h in list(root.handlers):
        root.removeHandler(h)
    root.addHandler(QueueHandler())
    # ×”×¤×¢×œ×ª worker ×™×¨×•×§
    eventlet.spawn(_log_worker)
    return root

×œ××” ×–×” ××ª××™×:
	â€¢	××™×Ÿ ×©×™××•×© ×‘-threading.Thread ××œ× ×‘-eventlet.spawn â†’ ×¢×•×‘×“ ×‘××•×ª×• reactor ×©×œ×š.
	â€¢	×”-queue × ×•×ª×Ÿ non-blocking put_nowait â†’ ××™×Ÿ I/O ×—×•×¡× ×‘×œ×•×œ××”.
	â€¢	×× ×”-queue ××ª××œ× (× × ×™×— 10 ××œ×£ ×œ×•×’×™×) â€” ×”×•× ×¤×©×•×˜ drop ×•×œ× ×ª×•×§×¢.
	â€¢	××™×Ÿ ×¦×•×¨×š asyncio ×•×œ× ×ª×™×ª×›×Ÿ â€œ×©×‘×™×¨×”â€ ×‘×’×¨×™×Ÿ-×ª×³×¨×“×¡.

â¸»

ğŸš€ ××™×š ×œ×”×¤×¢×™×œ (×‘-app_factory.py)

from server.logging_async import setup_async_root
import os, logging

if os.getenv("ASYNC_LOG_QUEUE", "1") == "1":
    setup_async_root(level=logging.INFO)
else:
    logging.basicConfig(level=logging.INFO)

ENV:

ASYNC_LOG_QUEUE=1


â¸»

âš ï¸ ××ª×™ ×œ× ×œ×”×¤×¢×™×œ async logging
	â€¢	×× ×‘×¢×ª×™×“ ×ª×¢×‘×•×¨ ×œ×”×¨×¦×” ×¢×œ uvicorn / hypercorn ×¢× asyncio â†’ ×¢×“×™×£ ×™×”×™×” ×œ×¢×‘×•×¨ ×œ-asyncio.Queue ×•×”-worker ×¢× async def.
	â€¢	×× ×ª×•×¡×™×£ worker × ×¤×¨×“ ×©×™×•×¦×¨ processes (×œ× threads) â€” ×ª×¤×¨×™×“ logging ×œ-stdout ×‘×œ×‘×“ ×›×“×™ ×œ×× ×•×¢ multiprocess stdout mix.

â¸»

ğŸ’¡ ×™×ª×¨×•× ×•×ª ×‘×’×¨×¡×” ×”×–×•

×”×™×‘×˜	×ª×•×¦××”
×‘×œ×•×§×™× ×‘-print / File I/O	× ×¢×œ××™× ××”-hot path
×ª××™××•×ª ×œ-Eventlet	××œ××” (××©×ª××© ×‘-spawn ×•-sleep(0))
×¡×™×›×•×Ÿ deadlock	××¤×¡×™
×‘×™×¦×•×¢×™×	×™×¨×™×“×” ×‘-latency ×©×œ ~0.2-0.5 ×©×³ ×‘×ª× ××™ load
×§×œ×•×ª ×”×˜××¢×”	×§×•×‘×¥ ××—×“, 2 ×©×•×¨×•×ª import


â¸»

×œ×¡×™×›×•× ×§×¦×¨ ×œ××¤×ª×—:
	â€¢	×›×Ÿ, async logging ××ª××™× ×•×‘×˜×•×— ×œ××¢×¨×›×ª Pro-SaaS ×©×‘× ×•×™×” ×¢× Flask + Eventlet + WS.
	â€¢	×”×©×ª××© ××š ×•×¨×§ ×‘×’×¨×¡×” ×œ××¢×œ×” (×¢× eventlet.spawn) ×•×œ× ×‘-threading ×¨×’×™×œ.
	â€¢	××œ ×ª×¤×¢×™×œ ×§×•×‘×¥ log ×¡×™× ×›×¨×•× ×™ ×‘-production.
	â€¢	×ª×‘×“×•×§ ×©×”-logs ××•×¤×™×¢×™× ×‘×§×•× ×¡×•×œ ×•×©××™×Ÿ lag ×‘×™×Ÿ ×©×™×—×” ×œ×”×“×¤×¡×”.

×‘×¨×’×¢ ×©×ª×™×™×©× ××ª ×–×” ×•×ª×•×•×“× ×©×”-queue ×¨×¥, ××¤×©×¨ ×œ×”××©×™×š ×œ-Phase 2 (×›×•×•× ×•×Ÿ STT ×•-EOU).