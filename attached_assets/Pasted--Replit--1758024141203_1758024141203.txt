להדבקה לבוט ב-Replit (באנגלית). זו ההנחיה המסכמת שתסיים את המערכת מקצה לקצה. אל תשנה בקאנד קיים מעבר למה שמצוין. לעבוד Single-Origin, SeaSurf אחד, RTL ומובייל.

⸻

Finish the product: WhatsApp, Calls, CRM, Payments & Contracts, Users, System Settings

0) Ground rules (must follow)
	•	Single-origin: Flask serves client/dist and all API routes under /api/*. No second dev server.
	•	CSRF (SeaSurf only): GET /api/auth/csrf after login sets XSRF-TOKEN cookie. All write calls send credentials:'include' + header X-CSRFToken.
	•	Exempt only: /api/auth/login, /api/auth/logout, /api/webhooks/*, /healthz. Nothing else.
	•	If a write returns 403 → auto refresh CSRF once and retry once.
	•	Auth & Impersonation: Never override session.user.role. Use session.impersonating=true and session.impersonated_tenant_id. Guards check role and tenant scope.
	•	Mobile + RTL: dir="rtl", min-h-dvh on body, sticky top bar and bottom nav, no clipped content.
	•	Error shape: every API error returns JSON {error, message, hint?}; UI toasts that, not Error {}.

⸻

1) WhatsApp Page (two-way chat + automations)

Route: /app/whatsapp
Files:
	•	client/src/pages/wa/WhatsAppPage.tsx (list left, chat right; single-column on mobile)
	•	client/src/components/wa/ThreadList.tsx, MessageBubble.tsx, Composer.tsx, ProviderSwitch.tsx
	•	client/src/services/wa.ts (API calls)

API (use/backfill if missing, JSON only):
	•	GET /api/wa/threads?tenant=&q=&page=&pageSize= → {items:[{id, lead_id, phone_e164, last_msg, unread, provider}], total}
	•	GET /api/wa/threads/:id → {thread, messages:[{id, from, to, text, mediaUrl?, at}], lead}
	•	POST /api/wa/threads/:id/message (CSRF) {text?, mediaUrl?, provider} → {ok:true, message}
	•	POST /api/wa/broadcast (CSRF, admin/business) {lead_ids[], text}
	•	Inbound webhook(s) unify to internal event → upsert message + thread, emit WS event.

Behavior:
	•	Provider selector (Baileys|Twilio) per thread; default from BusinessSettings.
	•	WebSocket subscribe to /ws/wa → append incoming messages live.
	•	Clicking a thread opens Lead Page (Conversation tab) via /app/leads/:leadId?tab=conversation.
	•	Mark read on focus; unread count badge in header.

⸻

2) Calls Page (logs, recordings, transcripts)

Route: /app/calls
Files: client/src/pages/calls/CallsPage.tsx, client/src/services/calls.ts, RecordingPlayer.tsx

API:
	•	GET /api/calls?tenant=&q=&from=&to=&page=&pageSize= → {items:[{sid, lead_id, from_e164, to_e164, duration, status, at}], total}
	•	GET /api/calls/:sid → {call, transcript?, recordingUrl?}
	•	POST /api/calls/:sid/callback (CSRF) → start outbound call
	•	Twilio webhook(s) already exist → ensure they create/attach Lead + Activity.

UI:
	•	Filters, clickable row → drawer with details, play recording, copy transcript, “Create reminder”, “Open lead”.

⸻

3) CRM Page (accounts/contacts/tasks mini-hub)

Route: /app/crm
Files: client/src/pages/crm/CrmPage.tsx, client/src/components/crm/TasksBoard.tsx, client/src/services/crm.ts

API:
	•	GET /api/crm/tasks?tenant=&status=&owner=&q=
	•	POST /api/crm/tasks (CSRF), PATCH /api/crm/tasks/:id (CSRF)
	•	GET /api/crm/contacts?tenant=&q=, POST /api/crm/contacts (CSRF)

UI:
	•	Kanban for tasks (To-Do / Doing / Done), quick add, assign to user, link to lead.

⸻

4) Payments & Contracts (Docs & Billing)

Route: /app/billing and inside Lead Page (Docs & Billing tab)
Files: client/src/pages/billing/BillingPage.tsx, client/src/services/billing.ts, DocSendModal.tsx

API (stubs are fine, must return usable links/status):
	•	POST /api/billing/contract (CSRF) {lead_id, template_id?, vars} → {link,status:'sent'}
	•	POST /api/billing/invoice (CSRF) {lead_id, amount, currency} → {link,status}
	•	POST /api/billing/payment-link (CSRF) {lead_id, amount} → {link, expires_at}
	•	GET /api/billing/history?lead_id= → {items:[{type, link, status, at}]}

UI:
	•	From Lead Page, buttons “Send contract / invoice / payment link” → DocSendModal → toast + Activity entry.

⸻

5) Users Management

Route: /app/admin/users (admin only)
Files: client/src/pages/admin/UsersPage.tsx, client/src/services/users.ts

API:
	•	GET /api/admin/users?tenant=&q=, POST /api/admin/users (CSRF, invite)
	•	PATCH /api/admin/users/:id (CSRF, role/status/reset)
	•	POST /api/admin/businesses/:id/impersonate (CSRF) / POST /api/admin/impersonate/exit (CSRF)
	•	Guard: admin only; do not change session.user.role; set session.impersonating*.

UI:
	•	Table with role chips, actions: edit, disable, impersonate (with confirm), reset password (sends email/webhook stub).

⸻

6) System Settings

Route: /app/admin/settings
Files: client/src/pages/admin/SettingsPage.tsx, client/src/services/settings.ts

Sections:
	•	Business Settings (name, tz, phone_e164, whatsapp_jid, default provider)
	•	AI Prompts (calls_prompt, whatsapp_prompt) – edit & save works (we already load them).
	•	Integrations (Twilio SID/Auth, Baileys status display read-only), Feature flags.

API:
	•	GET/PUT /api/admin/settings/business (CSRF)
	•	GET/PUT /api/admin/settings/prompts (CSRF)
	•	GET /api/admin/integrations/status

⸻

7) FE service layer (shared)
	•	client/src/services/http.ts: ensure once after login we call /api/auth/csrf, store cookie, and for every write add X-CSRFToken. On 403 → refresh CSRF and retry once. Always credentials:'include'.
	•	client/src/store/auth.ts: keep {user, impersonating, impersonated_tenant_id, tenant} from /api/auth/me.
	•	All list views: show skeletons/spinners, never show Error {}—render {error,message}.

⸻

8) Acceptance checklist (do not mark done without all green)

Server (curl) – with cookie jar /tmp/c:

# Login
curl -i -c /tmp/c -b /tmp/c -H 'Content-Type: application/json' \
  -X POST $BASE/api/auth/login --data '{"email":"admin@...","password":"..."}'

# CSRF
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf | python - <<'PY'
import sys,json; print(json.load(sys.stdin)["csrfToken"])
PY
)

# Create lead
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X POST $BASE/api/leads --data '{"first_name":"דנה","phone_e164":"+9725...","source":"form"}'

# Send WA message (choose provider)
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X POST $BASE/api/wa/threads/1/message --data '{"text":"היי!","provider":"baileys"}'

# Impersonate
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -X POST $BASE/api/admin/businesses/1/impersonate
curl -i -c /tmp/c -b /tmp/c $BASE/api/auth/me

UI manual
	•	WhatsApp: open thread, send & receive (WS live) + provider switch persists for the session/lead.
	•	Calls: see log, open call, play recording/transcript, create callback, create reminder.
	•	CRM: create/edit tasks & contacts; drag tasks across statuses.
	•	Billing: send contract/invoice/payment link (get usable link), history lists items.
	•	Users: invite, change role, impersonate, exit impersonation.
	•	Settings: edit prompts → new calls/wa use them; edit business default provider affects WA composer.
	•	Mobile/RTL: no clipped sections; header/bottom nav sticky; long pages scroll smoothly.

⸻

9) Preview & Deploy
	•	Preview and Deploy must run the same start command (Vite build, Flask serves). No vite-dev in Preview.
	•	Cache busting: bump window.__BUILD__ and set Cache-Control: no-store on index.html. Verify badge updates.

⸻

10) Definition of Done
	•	No Error {} in console; all errors surfaced as JSON toast.
	•	All listed routes return real data; all write ops succeed with CSRF on.
	•	Impersonation works without losing admin capabilities.
	•	Mobile/RTL polished.
	•	Ready for commercial use: single click deploy works; smoke tests pass.

If anything fails (403/401/500/undefined render/visual glitch), stop, print the exact request+response (URL, status, JSON), fix locally, and re-run the acceptance checklist before proceeding.