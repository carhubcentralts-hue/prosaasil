עברתי על ה־zip החדש (AgentLocator). סרקתי את כל הפרויקט ובדקתי נקודה־נקודה מול מה שהגדרנו. הנה סטטוס אמיתי + תיקונים קונקרטיים להדבקה.

סיכום מהיר (מה ירוק ומה עוד חסר)

רכיב	מצב
DB (SQLAlchemy + מודלים)	✅ קיים ומוגדר (app.py + models.py)
Twilio Voice – מסלולים	✅ קיימים: /twilio/incoming_call, /handle_recording, /twilio/call_status
אימות חתימת Twilio	❌ חסר ב־Voice; ב־WhatsApp יש קוד אימות אבל הוא מנוטרל/מוחלש
WhatsApp דרך Twilio	⚠️ יש שליחה וקבלת inbound (/whatsapp/webhook), אבל אין וובהוק סטטוסים (delivered/read/failed)
WhatsApp דרך Baileys	✅ קיים baileys_client.js + תור baileys_auth_info/message_queue.json
מתג ספק (Baileys/Twilio)	❌ אין; הקוד נפרד ואינו מתעדף לפי ENV
מספר WhatsApp של Twilio	❌ hardcoded ב־whatsapp_service.py; חייב ENV אחיד
TTS (Google Cloud)	✅ קיים (hebrew_tts.py)
PUBLIC_HOST להשמעת MP3	❌ לא בשימוש כרגע
בדיקות smoke/pytest	⚠️ יש קבצי טסט, לא בטוח שכולם רצים end-to-end


⸻

מה לתקן עכשיו (קופי־פייסט)

1) אימות חתימת Twilio לכל הוובהוקים (Voice + WhatsApp)

צור קובץ twilio_security.py (שורש הפרויקט, ליד routes_twilio.py / routes_whatsapp.py):

# twilio_security.py
import os
from functools import wraps
from flask import request, abort, current_app
from twilio.request_validator import RequestValidator

def require_twilio_signature(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        # אפשר לדלג ב־TESTING
        if current_app.config.get("TESTING"):
            return f(*args, **kwargs)

        token = os.environ.get("TWILIO_AUTH_TOKEN")
        if not token:
            return abort(401)

        validator = RequestValidator(token)
        signature = request.headers.get("X-Twilio-Signature", "")
        # טיפול ב־Proxy/HTTPS
        url = request.url
        if request.environ.get('HTTP_X_FORWARDED_PROTO') == 'https':
            url = url.replace('http://', 'https://', 1)
        params = request.form.to_dict() if request.method == "POST" else request.args.to_dict()

        if not validator.validate(url, params, signature):
            return abort(403)

        return f(*args, **kwargs)
    return wrapper

החלת הדקורטור:

routes_twilio.py – הוסף בראש:

from twilio_security import require_twilio_signature

וסמן על כל המסלולים:

@app.route("/twilio/incoming_call", methods=["POST"])
@require_twilio_signature
def incoming_call(): ...

@app.route("/handle_recording", methods=["POST"])
@require_twilio_signature
def handle_recording(): ...

@app.route("/twilio/call_status", methods=["POST"])
@require_twilio_signature
def call_status(): ...

routes_whatsapp.py – בטל את ההערות (uncomment) בקוד האימות שכבר כתבת, או פשוט החלף ל:

from twilio_security import require_twilio_signature

@app.route("/whatsapp/webhook", methods=["POST", "GET"])
@require_twilio_signature
def whatsapp_webhook():
    ...

הערה: במצב פיתוח אפשר להשאיר TESTING=True ב־config כדי לעקוף אימות.

⸻

2) וובהוק סטטוסים ל־Twilio WhatsApp (delivered/read/failed)

הוסף מסלול חדש ב־routes_whatsapp.py:

from datetime import datetime
from models import WhatsAppMessage
from app import db
from twilio_security import require_twilio_signature

@app.route("/whatsapp/status", methods=["POST"])
@require_twilio_signature
def whatsapp_status():
    sid = request.form.get("MessageSid")
    status = request.form.get("MessageStatus")  # queued|sent|delivered|read|failed|undelivered
    now = datetime.utcnow()
    if not sid or not status:
        return jsonify({"error":"missing sid/status"}), 400

    msg = WhatsAppMessage.query.filter_by(provider_message_id=sid).first()
    if msg:
        msg.status = status
        if status == "delivered":
            msg.delivered_at = now
        if status == "read":
            msg.read_at = now
        db.session.commit()

    return ("", 204)

ב־Twilio Console/בשליחה – הגדר Status Callback ל־POST https://<PUBLIC_HOST>/whatsapp/status.

⸻

3) ביטול hardcode למספר WhatsApp של Twilio

ב־whatsapp_service.py החלף את ה־init כך:

class WhatsAppService:
    def __init__(self):
        from twilio.rest import Client
        self.account_sid = os.environ.get('TWILIO_ACCOUNT_SID')
        self.auth_token  = os.environ.get('TWILIO_AUTH_TOKEN')
        self.from_whatsapp = os.environ.get('TWILIO_WHATSAPP_NUMBER')  # בפורמט whatsapp:+1415...
        if not all([self.account_sid, self.auth_token, self.from_whatsapp]):
            raise RuntimeError("Missing Twilio WhatsApp ENV (TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_WHATSAPP_NUMBER)")
        self.client = Client(self.account_sid, self.auth_token)

ובשליחה:

msg = self.client.messages.create(
    body=message_text,
    from_=self.from_whatsapp,            # כבר כולל whatsapp:
    to=f"whatsapp:{to_number}" if not str(to_number).startswith("whatsapp:") else to_number
)

.env (או Secrets):

TWILIO_WHATSAPP_NUMBER=whatsapp:+14155238886   # או המספר המאושר שלך


⸻

4) מתג ספק (Baileys/Twilio) לשליחה אחודה

צור whatsapp_provider.py (פשוט וקצר, מעל הקוד הקיים):

# whatsapp_provider.py
import os, json, time, pathlib

class Provider:
    def send_text(self, to, text) -> dict: raise NotImplementedError

class BaileysProvider(Provider):
    def __init__(self, base="baileys_auth_info"):
        self.queue = pathlib.Path(base) / "message_queue.json"
        self.queue.parent.mkdir(parents=True, exist_ok=True)
        if not self.queue.exists(): self.queue.write_text("[]", encoding="utf-8")
    def send_text(self, to, text):
        data = json.loads(self.queue.read_text("utf-8"))
        data.append({"to": to, "message": text, "ts": int(time.time())})
        self.queue.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        return {"provider":"baileys","status":"queued"}

class TwilioProvider(Provider):
    def __init__(self):
        from twilio.rest import Client
        self.sid = os.getenv("TWILIO_ACCOUNT_SID")
        self.token = os.getenv("TWILIO_AUTH_TOKEN")
        self.from_ = os.getenv("TWILIO_WHATSAPP_NUMBER")
        self.client = Client(self.sid, self.token)
    def send_text(self, to, text):
        msg = self.client.messages.create(
            body=text,
            from_=self.from_,
            to=f"whatsapp:{to}" if not str(to).startswith("whatsapp:") else to
        )
        return {"provider":"twilio","status":msg.status,"sid":msg.sid}

def get_provider():
    return TwilioProvider() if os.getenv("WHATSAPP_PROVIDER","baileys").lower()=="twilio" else BaileysProvider()

ב־routes_whatsapp.py (ב־send_whatsapp_message) החלף שליחה ל:

from whatsapp_provider import get_provider
...
res = get_provider().send_text(to_number, message)
# שמירת ההודעה ל־DB עם provider/status/SID אם קיים
msg = WhatsAppMessage(
    business_id=business.id,
    to_number=to_number,
    direction="out",
    body=message,
    status=res.get("status","queued"),
    provider=res.get("provider","unknown"),
    provider_message_id=res.get("sid")
)
db.session.add(msg); db.session.commit()
return jsonify({"ok":True, **res})

.env:

WHATSAPP_PROVIDER=baileys   # או twilio


⸻

5) Baileys – ודא צריכת תור ושמירת סטטוס

ב־baileys_client.js כבר יש עיבוד תור ו־status.json. ודא ש־start_baileys.sh מריץ:

#!/usr/bin/env bash
npm i
node baileys_client.js

ופועל ברקע בפרודקשן (pm2/Procfile).

⸻

6) PUBLIC_HOST להשמעת MP3 (קריטי לשיחות)

במקום שבו אתה מחזיר TwiML להשמעה/Play, קח דומיין מ־ENV:

PUBLIC_HOST = os.environ.get("PUBLIC_HOST")
if not PUBLIC_HOST:
    app.logger.warning("PUBLIC_HOST missing – using Say fallback")
    # <Say> במקום <Play>
else:
    # url = f"{PUBLIC_HOST}/static/voice_responses/response_{call_sid}.mp3"
    # החזר <Play>{url}</Play>

.env:

PUBLIC_HOST=https://your-domain-or-tunnel


⸻

7) בריאות/בדיקות מהירות (Smoke)

הוסף/וודא @app.route("/health") שמחזיר 200.
בדיקות ידניות:

# Voice
curl -X POST https://<HOST>/twilio/incoming_call
curl -X POST https://<HOST>/handle_recording -d RecordingUrl=https://api.twilio.com/.../RExxx -d CallSid=CA_TEST_1
curl -X POST https://<HOST>/twilio/call_status -d CallSid=CA_TEST_1 -d CallStatus=completed

# WhatsApp (provider = baileys)
curl https://<HOST>/whatsapp/baileys -X POST -H "Content-Type: application/json" -d '{"event":"ping"}'  # אם יש
curl https://<HOST>/whatsapp/send -X POST -H "Content-Type: application/json" -d '{"to":"+9725XXXXXXX","message":"בדיקה","business_id":1}'

# Twilio WhatsApp inbound (בבדיקות מותר בלי חתימה אם TESTING=True)
curl -X POST https://<HOST>/whatsapp/webhook -d 'From=whatsapp:+9725....' -d 'To=whatsapp:+1415...' -d 'Body=שלום'

# Twilio WhatsApp status
curl -X POST https://<HOST>/whatsapp/status -d 'MessageSid=SMxxxx' -d 'MessageStatus=delivered'


⸻

צ’ק־ליסט “ירוק לפרודקשן”
	•	כל הוובהוקים עם @require_twilio_signature
	•	Twilio WhatsApp: וובהוק סטטוסים פעיל ומעדכן DB
	•	WHATSAPP_PROVIDER פועל (baileys↔twilio)
	•	TWILIO_WHATSAPP_NUMBER נלקח מ־ENV (אין hardcode)
	•	PUBLIC_HOST בשימוש להשמעת MP3 או Fallback בטוח
	•	DB נשמר לכל האירועים (CallLog/WhatsAppMessage)
	•	baileys_client.js רץ ברקע ושותה תור
	•	/health מחזיר 200; smoke עובר

⸻

מה השתפר בקובץ שהעלית
	•	✅ ORM מלא ומודלים עשירים (כולל WhatsAppConversation/Message)
	•	✅ Baileys קיים עם ניהול תור ו־status
	•	✅ Voice/WhatsApp קיימים פונקציונלית
	•	❗ נותרו “החוטים האחרונים” שציינתי למעלה כדי להפוך את זה למוכן לפרודקשן באמת.

אם תרצה, אכתוב לך Diffs ספציפיים לפי קובץ על בסיס הטקסטים למעלה (patch-style), אבל עם הקטעים שנתתי כאן תוכל להדביק מיידית.
תגיד “ביצעתי”, ואני אריץ אותך על צ’ק־ליסט אימות נוסף ואז נתקדם לשכבת UI מלאה (RTL, פונט Assistant, היררכיית כפתורים ותצוגות לפי הרשאות/תפקיד).