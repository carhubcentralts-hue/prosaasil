מעולה. הנה “מפת־דרך לבן-אדם” — הנחיות וקוד הדבקה מדויקים, מותאמים למבנה של AgentLocator (הגרסאות האחרות ששלחת: `routes_twilio.py`, `media_ws_ai.py`, `app_factory.py`, `start_all.sh`, `gcp_tts_live.py`, `stream_state/stream_registry`). זה סוגר שקט, לופים, “אני מתמחה…” שחוזר, וגורם לניהול שיחה דו־כיוונית אמיתי: תמלול → הבנה → תשובה אחת, עם barge-in וקצב אנושי.

---

# 0) קונפיג נכון לשרת האמיתי

ב־**Twilio Console** (מס’ הטלפון):

* Voice → A CALL COMES IN → **POST** ל-`https://ai-crmd.replit.app/webhook/incoming_call`

ב־**.env/start\_all.sh**:

```bash
export PUBLIC_BASE_URL=https://ai-crmd.replit.app
# אין להשתמש ב-PUBLIC_HOST, ואם יש – למחוק/להתעלם
```

---

# 1) TwiML — לא לעכב את ה־Stream

**routes\_twilio.py**

* בלי `<Play>` כברירת מחדל; ברכה דרך TTS אחרי `start`, ורק אם יש שקט.

```diff
- parts.append(f'  <Play>{base}/static/greeting_he.mp3</Play>')
+ # ברכה אופציונלית דרך ENV בלבד:
+ if os.getenv("TWIML_PLAY_GREETING","false").lower()=="true":
+     parts.append(f'  <Play>{base}/static/greeting_he.mp3</Play>')
```

---

# 2) Handshake ל־WS של Twilio (תת-פרוטוקול)

**app\_factory.py** (או היכן שנפתח ה־WS):

```python
from simple_websocket import Server as WebSocketServer
from flask import request

def _open_ws():
    offered = request.headers.get("Sec-WebSocket-Protocol","")
    headers = [("Sec-WebSocket-Protocol","audio.twilio.com")] if "audio.twilio.com" in offered else []
    return WebSocketServer(environ=request.environ, headers=headers)

@app.get("/ws/twilio-media")
def ws_media():
    ws = _open_ws()
    return run_media_stream(ws)

@app.get("/ws/twilio-media/")
def ws_media_slash():
    ws = _open_ws()
    return run_media_stream(ws)
```

בדיקת יד:
`wscat -c "wss://ai-crmd.replit.app/ws/twilio-media" -s "audio.twilio.com"`

---

# 3) חיבור ל־watchdog (מונע “רפיטיציה” וניתוקים)

**media\_ws\_ai.py**

```diff
+from server.stream_state import stream_registry

 class MediaStreamHandler:
     def __init__(...):
         ...
-        self.stream_sid=None
+        self.stream_sid=None
+        self.call_sid=None
         ...

     def run(...):
         ...
         if et=="start":
             self.stream_sid = evt["start"]["streamSid"]
+            self.call_sid = (evt["start"].get("callSid") or
+                             (evt["start"].get("customParameters") or {}).get("call_sid"))
+            if self.call_sid:
+                stream_registry.mark_start(self.call_sid)
             ...

         if et=="media":
             ...
+            if self.call_sid:
+                stream_registry.touch_media(self.call_sid)
```

---

# 4) “היא לא נותנת לדבר” — ברכה חכמה + Barge-in יציב + קירור

**media\_ws\_ai.py**

### A. ברכה רק אם אין קול ב־0.8s הראשונות

```diff
 if et=="start":
     ...
-    self._speak_simple(os.getenv("AI_GREETING_HE","שלום! איך אפשר לעזור?"))
+    self.greeting_sent=False
+    def _maybe_greet():
+        time.sleep(0.8)
+        if (time.time()-self.last_rx_ts)>=0.8 and self.state=="LISTENING" and not self.speaking:
+            greet=os.getenv("AI_GREETING_HE","")
+            if greet.strip():
+                self._speak_simple(greet)
+                self.greeting_sent=True
+    threading.Thread(target=_maybe_greet,daemon=True).start()
```

### B. Barge-in: עצירת דיבור רק אם יש **3 פריימי קול רצופים**

```diff
 rms = audioop.rms(pcm16,2); is_voice = rms>VAD_RMS
-self.voice_in_row = (self.voice_in_row+1) if is_voice else 0
+self.voice_in_row = (self.voice_in_row+1) if is_voice else 0

-if self.speaking and is_voice and BARGE_IN:
+if self.speaking and BARGE_IN and self.voice_in_row >= int(os.getenv("BARGE_IN_VOICE_FRAMES","3")):
     self._interrupt_speaking()
     self.buf.clear()
     self.processing=False
     self.state="LISTENING"
     return
```

### C. קירור אחרי דיבור (לא ללכוד נשימות/רחש)

```diff
-if (time.time()-self.last_tts_end_ts) < (REPLY_REFRACTORY_MS/1000.0):
+if (time.time()-self.last_tts_end_ts) < (int(os.getenv("REPLY_REFRACTORY_MS","750"))/1000.0):
     return
```

---

# 5) “אין תמלול” — סוף־מבע אדפטיבי ומהיר

**media\_ws\_ai.py** — סף קצר + hangover:

```diff
 self.buf.extend(pcm16)
 dur = len(self.buf)/(2*SR)
- silent = (time.time()-self.last_rx_ts) >= MIN_UTT_SEC
+ min_sil = MIN_UTT_SEC if dur>1.2 else max(0.35, MIN_UTT_SEC-0.12)
+ silent = ((time.time()-self.last_rx_ts) >= min_sil) and \
+          ((time.time()-self.last_rx_ts) >= (VAD_HANGOVER_MS/1000.0))
- if (silent or too_long) and dur > 0.5 and not self.processing:
+ if (silent or too_long) and dur > 0.28 and not self.processing:
     self.processing=True
     self.state="THINKING"
     utt = bytes(self.buf); self.buf.clear()
     current_turn = self.turn_id = self.turn_id+1
     threading.Thread(target=self._process_turn,args=(utt,current_turn),daemon=True).start()
```

---

# 6) “רק מתמחה ממקסימוס נדל״ן…” — אנטי-לופים והצגה עצמית פעם אחת

**media\_ws\_ai.py**

```diff
 # בתחילת המחלקה:
 self.last_user_hash=None; self.last_user_hash_ts=0.0
 self.last_reply_hash=None
+self.introduced=False

 # בתוך _process_turn:
 import zlib
 ...
 # אנטי-דופליקציה טקסט משתמש
 uh = zlib.crc32(text.strip().encode("utf-8"))
 if self.last_user_hash == uh and (time.time()-self.last_user_hash_ts) <= int(os.getenv("DEDUP_WINDOW_SEC","14")):
     print("DEDUP user → ignore"); self.processing=False; self.state="LISTENING"; return
 self.last_user_hash, self.last_user_hash_ts = uh, time.time()

 # LLM “טלפוני”:
 reply = generate_hebrew_response(
     text,
     target_style=os.getenv("LLM_TARGET_STYLE","warm_helpful"),
     min_chars=int(os.getenv("LLM_MIN_CHARS","160")),
     max_chars=int(os.getenv("LLM_MAX_CHARS","420")),
) or "בסדר, איך אוכל לסייע?"

-# לא לחזור על אותה תשובה
+# לא לחזור על אותה תשובה / לא להציג את עצמך שוב
 rh = zlib.crc32(reply.strip().encode("utf-8"))
 if self.last_reply_hash == rh:
     reply = "הבנתי. תרצה שאפרט או להתקדם?"
     rh = zlib.crc32(reply.encode("utf-8"))
 self.last_reply_hash = rh

+# הצגה עצמית — פעם אחת בלבד לשיחה
+if not self.introduced:
+    self.introduced=True
+else:
+    # מחק הצגה עצמית אם המודל החזיר שוב:
+    for bad in ("אני מתמחה", "שמי", "מקסימוס נדל"):
+        if bad in reply:
+            reply = "בסדר. איך אוכל לקדם את זה עבורך?"
+            break
```

---

# 7) TTS תמיד משדר (או Beep) + “נשימה” קצרה

**media\_ws\_ai.py — \_speak\_simple**

```diff
 # נשימה אנושית קצרה
 import random
 try: time.sleep(random.uniform(RESP_MIN_DELAY_MS/1000.0, RESP_MAX_DELAY_MS/1000.0))
 except: pass

 pcm=None
 try: pcm = synth_hebrew_tts_pcm16_8k(text)
 except Exception as e: print("TTS_ERR:", e)
 if not pcm or len(pcm)<400:
     pcm = self._beep_pcm16_8k(300)

 # clear + 20ms µ-law (160 bytes)
 if self.stream_sid: self.tx_q.put_nowait({"type":"clear"})
 ...
 self.last_tts_end_ts = time.time()
```

---

# 8) GCP TTS נכון (בלי ffmpeg)

**gcp\_tts\_live.py**

```python
self.audio_config_pcm16_8k = texttospeech.AudioConfig(
    audio_encoding=texttospeech.AudioEncoding.LINEAR16,
    sample_rate_hertz=8000,
    speaking_rate=0.96,
    effects_profile_id=["telephony-class-application"],
)
# synth_hebrew_tts_pcm16_8k(text) → מחזיר bytes PCM16 8kHz
```

---

# 9) ENV לכיוונון (ב־start\_all.sh)

```bash
# VAD / סיום מבע
export MIN_UTT_SEC=${MIN_UTT_SEC:-0.48}
export VAD_HANGOVER_MS=${VAD_HANGOVER_MS:-140}
export VAD_RMS=${VAD_RMS:-210}
export MAX_UTT_SEC=${MAX_UTT_SEC:-7.0}

# קצב
export RESP_MIN_DELAY_MS=${RESP_MIN_DELAY_MS:-220}
export RESP_MAX_DELAY_MS=${RESP_MAX_DELAY_MS:-360}
export REPLY_REFRACTORY_MS=${REPLY_REFRACTORY_MS:-750}

# Barge-in + דה-דופליקציה
export BARGE_IN=${BARGE_IN:-true}
export BARGE_IN_VOICE_FRAMES=${BARGE_IN_VOICE_FRAMES:-3}
export DEDUP_WINDOW_SEC=${DEDUP_WINDOW_SEC:-14}

# פתיח כבוי בבדיקות
export TWIML_PLAY_GREETING=${TWIML_PLAY_GREETING:-false}
export AI_GREETING_HE=${AI_GREETING_HE:-""}

# LLM סגנון/אורך
export LLM_TARGET_STYLE=${LLM_TARGET_STYLE:-"warm_helpful"}
export LLM_MIN_CHARS=${LLM_MIN_CHARS:-160}
export LLM_MAX_CHARS=${LLM_MAX_CHARS:-420}
```

---

# 10) לוגים שחייבים להופיע (כדי לדעת שזה באמת “חי”)

* בתחילת שיחה: `WS_START sid=…`
* תוך ≤2 שנ’: `WS_MEDIA sid=… rx=50` (כלומר המדיה זורמת)
* אחרי שאתה מדבר: `ASR_TEXT: …`
* ואז: `tts_done`/`WS_TX …`
* בסוף: `WS_DONE sid=… rx>0 tx>0`

אם **rx=0** → הבעיה ב־Handshake/נתיב; אם **tx=0** → TTS/שליחה; אם **ASR\_TEXT** ריק תמיד → בעיית ASR (בפאץ’ דואגים שלא יישאר ריק, אלא ישאל שאלה קצרה).

---

## בדיקת GO מהירה (טסט חי)

1. התקשר, דבר מיד — אין ברכה, רואים `WS_MEDIA rx` עולה → תשובה אחת (2–4 משפטים).
2. דבר מעליה בזמן שהיא עונה — `BARGE_IN: interrupt`, היא נקטעת וחוזרת להאזנה.
3. אל תדבר בהתחלה — אחרי \~0.8s תשמע ברכה קצרה (אם `AI_GREETING_HE` לא ריק).
4. אין “אני מתמחה…” בלופים (הוצאנו הצגה עצמית חוזרת).

---

זהו. ההנחיות והפאצ’ים כאן תואמים למבנה של הפרויקט שלך ומכסים את הסיבות לשקט/לופים/חוסר תמלול. תדביק ותרים. אם משהו עדיין מקרטע, הדבק 8–10 שורות לוג (WS\_START / WS\_MEDIA / ASR\_TEXT / WS\_TX / WS\_DONE) ואני אצביע בדיוק על נקודת התקיעה בקוד.
