מעולה. הנה הנחיה סופר־מדויקת להחזיר את Baileys Node בלי לשבור כלום, ולשלב אותו במקביל ל-Twilio WhatsApp בתוך הפרויקט שלך (כמו שכבר בנוי אצלך: api_whatsapp_unified.py + whatsapp_provider.py + whatsapp_outbound.py). תדביק לו אחד-לאחד.

⸻

A) עקרון עבודה
	•	שני ספקים רצים יחד:
Twilio = יציב, חוקי 24h, טמפלייטים;
Baileys = “אנושי” (כמו WhatsApp Web), לשיחה בתוך חלון 24 השעות.
	•	השרת שלך (Python) כבר מכיל שכבה אחודה—הוא ינתב לפי חוקים, יעשה פיילאובר, וישמור CRM.

⸻

B) ENV (בדיוק, בפרודקשן — Deployments → Environment Variables)

חובה:
	•	PUBLIC_BASE_URL=https://<הדומיין-הציבורי-שלך>
	•	WHATSAPP_PROVIDER=auto  ← מאפשר ניתוב אוטומטי בין Twilio/Baileys
	•	Twilio:
	•	TWILIO_ACCOUNT_SID=...
	•	TWILIO_AUTH_TOKEN=...
	•	TWILIO_WA_FROM=whatsapp:+972...  (המספר העסקי בטוויליו)
	•	Baileys (Node):
	•	BAILEYS_OUTBOUND_URL=https://wa-node.example.com/send
	•	BAILEYS_WEBHOOK_SECRET=<shared-secret-חזק>  (אותו סיקרט גם בצד ה-Node)
	•	(אם יש תור/Redis/קובץ—שמות בהתאם, למשל BAILEYS_QUEUE_URL/BAILEYS_QUEUE_FILE)

ודא שכל ה-ENV קיימים בדיפלוי, לא רק ב-Secrets של ה-Workspace.

⸻

C) Bring-up של שירות Baileys Node (ללא פגיעה בשאר המערכת)

יעד: שירות Node עצמאי, עם 3 ראוטים: /send, /webhook, /health, ושמירת session.
	1.	תיקיה ו־Persist
	•	צור שירות Node (ריפו נפרד/תיקייה whatsapp-node), התקן baileys.
	•	אחסן auth state (session) על דיסק/Redis שאינו נמחק בפריסות (מונע דרישת QR כל פעם).
	2.	ראוטים (בדיוק):
	•	GET /health → מחזיר {status:"ok", device:"<jid or phone>", connected:true}
	•	POST /send → JSON:

{
  "to": "972501234567", 
  "type": "text|media",
  "text": "שלום!",
  "mediaUrl": "https://... (optional)",
  "caption": "optional",
  "idempotencyKey": "uuid-... (חובה)"
}

החזר: { ok:true, messageId:"<wa-msg-id>" }. על טעויות זמניות החזר 429/503 כדי שהפייתון יעשה backoff.

	•	POST /webhook → ה-Node שולח לכאן אין; להפך—ה-Node שלך צריך לקרוא אל השרת Python.
בצד ה-Node, על כל הודעה נכנסת: POST {PUBLIC_BASE_URL}/api/whatsapp/baileys עם Header: X-BAILEYS-SECRET: <BAILEYS_WEBHOOK_SECRET> וגוף:

{
  "remoteJid": "9725...@s.whatsapp.net",
  "messageId": "<key.id>",
  "timestamp": 169...,
  "type": "text|media|... ",
  "text": "מה נשמע",
  "media": { "mimetype": "...", "size": 12345, "url": "https://..." }
}

ה-Python מחזיר 204 מיידי (כבר קיים אצלך).

	3.	אבטחה
	•	אימות סיקרט ב-Python: דחה כל Baileys inbound בלי X-BAILEYS-SECRET/לא תואם.
	•	HTTPS בלבד. אם אפשר—IP allowlist של ה-Node.
	4.	הפעלה
	•	נהל עם PM2/systemd.
	•	בצע QR-login פעם אחת, וודא שה-session נשמר.
	•	בדוק GET /health → connected:true.

⸻

D) קונפיג Twilio WhatsApp
	•	ב-Twilio Console → Messaging → WhatsApp → Sandbox/Senders:
Webhook (Incoming messages) = POST {PUBLIC_BASE_URL}/api/whatsapp/twilio
	•	וידוא חתימות: אצלך כבר יש אימות—לעבוד עם ה-Base URL הנכון.

⸻

E) ניתוב Outbound חכם (כבר נתמך אצלך; תאשר חוקים)

ב-WHATSAPP_PROVIDER=auto השרת מפעיל את החוקים הבאים (אם לא—ליישם בדיוק כך):
	1.	Reply-via-source: אם ההודעה נכנסה דרך Baileys—ענה דרך Baileys; אם דרך Twilio—ענה דרך Twilio.
	2.	חלון 24 שעות: אם אין הודעת משתמש ב-24h האחרונות → Twilio בלבד (עם Template מאושר).
	3.	זמינות ספק: אם GET {BAILEYS_OUTBOUND_URL}/health נכשל/timeout → סמן DOWN ל-N שניות והעבר שליחה ל-Twilio אוטומטית.
	4.	העדפה ברירת-מחדל (אין Thread קיים): בתוך 24h—נסה Baileys; מחוץ ל-24h—Twilio.

⸻

F) Idempotency + Dedup (חיוני שלא “יכפיל”)
	•	Twilio inbound: השתמש ב-MessageSid כ-idempotency key.
	•	Baileys inbound: השתמש ב-key.id + remoteJid.
	•	Outbound: דרוש idempotencyKey בכל /send של ה-Node; ב-Python שמור אותו בטבלה ומנע שליחה כפולה.

⸻

G) מדיה (אחסון אחיד)
	•	Inbound Twilio: משוך MediaUrl0, שמור ל-storage שלך (S3/Cloud Storage), רשום meta (mime/size).
	•	Inbound Baileys: הורד את הבייטים/URL זמני, העלה ל-storage שלך.
	•	שמור פורמט אחיד ב-DB כדי שה-UI יציג אותו אותו דבר (Timeline, Lead).

⸻

H) קצב/עמידה בחוקים
	•	24h: הודעות עסק-יוזם מחוץ לחלון → Twilio Template בלבד.
	•	Baileys לא קיצור דרך לחוקי WhatsApp—הימנע משימוש מחוץ למסגרת, כדי לא לפגוע בחשבון.
	•	Rate limits: הוסף backoff (למשל 1s→2s→4s עד 30s) על 429/5xx משני הספקים.

⸻

I) בדיקות קבלה (15 דקות)
	1.	Baileys health: GET /health → connected:true.
	2.	Inbound Baileys: כתוב מהטלפון העסקי/הפרטי ל-WA שלך → רואה POST /api/whatsapp/baileys → 204 → נכתב ל-CRM.
	3.	Outbound Baileys: בקשת שליחה מה-Python ל-/send עם idempotencyKey → מקבל ok:true, messageId.
	4.	Inbound Twilio: הודעה ל-Twilio WhatsApp → POST /api/whatsapp/twilio → 204 → CRM.
	5.	Reply-via-source: המשך שיחה—תשובות יוצאות באותו ספק שממנו הגיעו.
	6.	Failover: עצור זמנית את ה-Node → שליחה נופלת לטוויליו אוטומטית.
	7.	24h: הודעה אחרי 24h → שליחה רק דרך טוויליו (אם אין Template—לוג “לא נשלח” + הודעת נחמה).

⸻

J) UI ודשבורד (יפה לעכשיו)
	•	הוסף לאירועי ה-UI:
wa.inbound, wa.outbound, wa.provider=twilio|baileys, wa.media, wa.error, lead.update.
	•	הצג Badge “Provider: Baileys/Twilio” בכל הודעה.
	•	גרף אחוז פיילאוברים + זמן תגובה/שגיאות.

⸻

K) Definition of Done
	•	שני הספקים פעילים, ניתוב אוטומטי, ופיילאובר תוך <1s.
	•	אין כפילויות (Idempotency).
	•	100% וובהוקים מחזירים 204 < 100ms.
	•	מדיה נשמרת אחיד ומופיעה בטיימליין.
	•	מחוץ ל-24h—נשלח רק דרך Twilio Templates.
	•	דשבורד מציג בבירור מאיזה ספק יצאה/נכנסה כל הודעה.

⸻

טיפ אחרון (מניעת נפילות)
	•	Baileys רץ על שרת נפרד (כתובת קבועה + דיסק קבוע ל-session), מנוהל ב-PM2 עם auto-restart, ושומר לוגים.
	•	ה-Python בודק BAILEYS_OUTBOUND_URL/health כל 30–60 שנ׳ ומעדכן “UP/DOWN” לזמן קצוב—לא כל בקשה.

זהו. עם זה תרים את ה-Baileys Node מחדש, תשאיר את Twilio חזק, ותהנה משילוב גמיש: יעיל, חוקי, ועם חוויית משתמש מצוינת.