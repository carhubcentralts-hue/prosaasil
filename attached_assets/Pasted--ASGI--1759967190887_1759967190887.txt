קלטתי בדיוק מה קרה פה – ויש פתרון חד:

הבעיה האמיתית (לפי מה שאתה מתאר + מה שקורה ב־ASGI)

כשאתה עושה curl https://.../ws/twilio-media וקבל HTML (index), זה לא אומר ש־Cloud Run לא תומך ב-WebSocket. זה אומר שהבקשה לא הייתה WebSocket (לא היה Upgrade header), ואז ה־router שלך העביר אותה ל־Flask/SPA שהוגדר כ־fallback.

ולמה זה מגיע ל־Flask בכלל? כי בסדר הרוטים שלך:

asgi_app = Starlette(routes=[
    Mount("/", app=asgi_flask),                  # תופס הכל (כולל /ws/…)
    WebSocketRoute("/ws/twilio-media", ws_fn),   # מגיע מאוחר מדי
])

ה־Mount("/") בולע גם את /ws/twilio-media, ולכן הבקשה (כולל ה־Upgrade) בכלל לא מגיעה ל־Starlette WebSocketRoute → התוצאה: HTML במקום WS → Twilio ניתק מיד (stream-started → stream-ended).

התיקון (שורה אחת משנה את המשחק)

שנה את הסדר כך שה־WS ייבדק לפני ה־Mount של Flask:

# asgi.py — סדר נכון של ראוטים
asgi_app = Starlette(routes=[
    WebSocketRoute("/ws/twilio-media", ws_twilio_media),  # קודם ה-WS!
    Mount("/", app=asgi_flask),                           # אחר כך ה-HTTP של Flask
])

ב-Starlette הסדר חשוב. אם ה־Mount(”/”) ראשון – הוא תופס הכל, כולל ה־WS.

בדיקות נכונות (לא עם curl רגיל)
	1.	בדיקת WS אמיתית (כולל Upgrade):

# עם websocat או wscat
websocat wss://<PUBLIC_HOST>/ws/twilio-media
# החיבור צריך להישאר פתוח; בלוגים שלך תראה start/media/stop כשיש שיחה

curl בלי כותרות Upgrade יחזיר HTML – זה תקין ולא בדיקה ל-WS.
	2.	TwiML עדיין תקין (בלי 12100):

curl -sS -i -X POST https://<PUBLIC_HOST>/webhook/incoming_call | sed -n '1,200p'
# מצופה: 200 + Content-Type: text/xml + <Stream url="wss://<PUBLIC_HOST>/ws/twilio-media" .../>

	3.	הקלטות/Callbacks:
וודא שנתיב ה־recording callback מחזיר 200 מהר (למנוע 11200):

curl -sS -i -X POST https://<PUBLIC_HOST>/webhook/recording_done \
  -d "CallSid=CA_test&RecordingUrl=https://example.com/rec.mp3" | sed -n '1,60p'
# מצופה: HTTP/1.1 200 OK

עוד שני דיוקים קטנים כדי שלא תראה “stream_ended מיד”
	•	ב־ws_twilio_media:
	•	קבל עם await websocket.accept(subprotocol="audio.twilio.com").
	•	קרא פריימים בלולאה await websocket.receive_json() ותפוס חריגות (try/except) כדי לא לסגור את החיבור בטעות.
	•	אל תעשה עיבוד כבד בלולאה; אם חייבים – שלח ל־thread (asyncio.to_thread) או ל־worker.
	•	ב־TwiML:
	•	תמיד wss://<PUBLIC_HOST>/ws/twilio-media (שלא יופיע https:// בתוך ה־host).
	•	@csrf.exempt על כל ה־webhooks.

פקודות פריסה מהירה (לפי Procfile שלך)

הקפד שההרצה היא Uvicon/ASGI בלבד:

web: uvicorn asgi:asgi_app --host 0.0.0.0 --port ${PORT:-5000} --ws websockets --lifespan off --timeout-keep-alive 75

אין gunicorn/eventlet בשום workflow/runner בפרודקשן.

⸻

שורה תחתונה
	•	ה־WS נתפס ע״י ה־Mount("/") → צריך שה־WebSocketRoute יופיע לפני ה־Mount.
	•	אל תבדוק WS עם curl רגיל – תבדוק עם websocat/wscat או בשיחה אמיתית.
	•	אחרי שינוי הסדר, ה־WS יקבל את ה־Upgrade, Twilio תראה media רציף (לא stream-ended מייד), והקול ירוץ חלק.

אם אחרי ההחלפה עדיין יש בעיה—זרוק לי:
	•	את שתי השורות האחרונות מלוגים סביב ws_twilio_media,
	•	פלט curl -i של /incoming_call ו־/webhook/recording_done,
ואגיד לך בדיוק מה עוד חסר (בדרך כלל זה ENV של PUBLIC_HOST או CSRF/חתימה).