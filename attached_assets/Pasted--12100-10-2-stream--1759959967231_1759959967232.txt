קיבלתי. לפי מה שאתה מתאר עכשיו (12100 נפתר, השיחה נמשכת ~10 שנ׳, יש 2 הקלטות, אבל: stream נסגר מיד, ו־11200/502 על ה-recording callback), יש שתי תקלות ממוקדות:
	1.	WebSocket נסגר מיד → ה-WS ב־asgi.py קורא את המסרים אבל לא מעבד/שומר יציב, או זורק חריגה ויוצא.
	2.	Callback של ההקלטה מחזיר 502 → הנתיב מחזיר שגיאה/CSRF/כבד מדי במקום 200 מהיר.

בוא נסגור את שתיהן, אחד-לאחד, לפי הקובץ שיש עכשיו:

⸻

A) לייצב את WebSocket של Twilio Media (למנוע “stream_ended מיד”)

מה הבעיה על הקוד הנוכחי

ב־asgi.py יש await websocket.accept(subprotocol="audio.twilio.com") ולולאת receive_json() — אבל:
	•	אין שכבת handler שסולקת את האירועים (start/media/stop) כמו שצריך;
	•	אם מתקבלת הודעה “חריגה” (למשל frame של mark או שדה חסר) → קורה exception והפונקציה יוצאת → ה־WS נסגר.

תיקון מדויק (שגר ואל תיגע בנשמה)

ב־asgi.py, עדכן את ws_twilio_media כך:

# asgi.py — גרסת handler יציבה
import asyncio, json, logging
from asgiref.wsgi import WsgiToAsgi
from starlette.applications import Starlette
from starlette.routing import Mount, WebSocketRoute
from app_factory import create_app

log = logging.getLogger("twilio_ws")

flask_app = create_app()
asgi_flask = WsgiToAsgi(flask_app)

# אם יש לך MediaStreamHandler סינכרוני קיים:
try:
    from server.media_stream_handler import MediaStreamHandler
    MEDIA_HANDLER = MediaStreamHandler()
except Exception:
    MEDIA_HANDLER = None

async def ws_twilio_media(websocket):
    # Twilio מצפה ל-subprotocol הזה
    await websocket.accept(subprotocol="audio.twilio.com")
    call_sid = None
    try:
        while True:
            try:
                msg = await websocket.receive_json()
            except Exception as e:
                # אם הגיע טקסט לא JSON — נסה decode פשוט
                data = await websocket.receive_text()
                try:
                    msg = json.loads(data)
                except Exception:
                    log.warning("Non-JSON WS frame ignored")
                    continue

            event = msg.get("event")
            if event == "start":
                call_sid = msg.get("start", {}).get("callSid")
                log.info(f"[WS] start call={call_sid}")
                # אם יש handler סינכרוני — הרץ ב-thread:
                if MEDIA_HANDLER:
                    asyncio.create_task(asyncio.to_thread(MEDIA_HANDLER.on_start, msg))

            elif event == "media":
                # frame audio Base64 ב-msg["media"]["payload"]
                if MEDIA_HANDLER:
                    # עיבוד סינכרוני ברקע (לא לחסום את WS)
                    asyncio.create_task(asyncio.to_thread(MEDIA_HANDLER.on_media, msg))
                # אחרת: פשוט “לצרוך” כדי להשאיר את הקו חי
                # (אין צורך לשלוח בחזרה כלום)

            elif event == "stop":
                log.info(f"[WS] stop call={call_sid}")
                if MEDIA_HANDLER:
                    asyncio.create_task(asyncio.to_thread(MEDIA_HANDLER.on_stop, msg))
                break

            else:
                # events כמו "mark", "closed" וכו' — להתעלם בבטחה
                pass

    except Exception as e:
        log.exception(f"[WS] error: {e}")
    finally:
        try:
            await websocket.close()
        except Exception:
            pass
        log.info(f"[WS] closed call={call_sid}")

asgi_app = Starlette(routes=[
    Mount("/", app=asgi_flask),
    WebSocketRoute("/ws/twilio-media", ws_twilio_media),
])

נקודות מפתח:
	•	אין עיבוד כבד בתוך הלולאה; אם יש MediaStreamHandler סינכרוני ישן — מריצים אותו ב־asyncio.to_thread(...).
	•	לעולם לא זורקים חריגה החוצה; עוטפים receive_* ו־handler ב־try/except.
	•	לא חייבים לשלוח כלום ל-Twilio; צריך רק לקרוא את הפריימים באופן עקבי כדי שהחיבור יישאר פתוח.

בדיקת GO/NO-GO
	•	שיחה אמיתית → Twilio Debugger צריך להראות stream-started ואז אירועי media (לא closed_by_server מייד).
	•	לוג שרת: [WS] start..., קצב media..., ואז stop/closed.

⸻

B) לתקן את Error 11200/502 ב־recording callback

מה זה 11200? Twilio קראה ל־Webhook שלך (URL של Recording Status) וקיבלה 502. זה כמעט תמיד:
	•	חסר @csrf.exempt/חתימה וחתכת לה 403/500;
	•	יש קוד כבד/שגיאה ב־DB/AI;
	•	URL לא נכון/ללא https.

תבנית Route נכונה (מינימלית, לא חוסם)

ב־server/routes_twilio.py (או קובץ ה־blueprint הרלוונטי):

from flask import request
from .blueprints import twilio_bp
from .csrf import csrf
from .auth import require_twilio_signature  # אם אתם מאמתים חתימה
from server.tasks import enqueue_transcribe_job  # תור ברקע

@twilio_bp.post("/webhook/recording_done")
@csrf.exempt
@require_twilio_signature
def recording_done():
    # Twilio שולחת: CallSid, RecordingUrl, RecordingSid, RecordingStatus...
    call_sid = request.form.get("CallSid")
    rec_url  = request.form.get("RecordingUrl")  # בד"כ צריך להוסיף .mp3 מאוחר יותר

    # אל תעשה פה כלום כבד. רק תור.
    try:
        enqueue_transcribe_job(call_sid=call_sid, recording_url=rec_url)
    except Exception:
        # גם אם קרה משהו — תחזיר 200 כדי לא להפיל את Twilio
        pass

    return ("", 200)

חשוב:
	•	חובה @csrf.exempt על ה-callback.
	•	לחזור 200 תוך ≤300ms. כל עיבוד (הורדה/תמלול/DB) — ב־Worker.

בדיקת GO/NO-GO

curl -sS -i -X POST https://<PUBLIC>/webhook/recording_done \
  -d "CallSid=CA_test&RecordingUrl=https://api.twilio.com/recordings/abc123" | sed -n '1,80p'

מצופה: HTTP/200 ובלי גוף. אם לא — זו הסיבה ל־11200.

⸻

C) אימות ה-TwiML של /incoming_call (רק לוודא שלא חזרנו ל-12100)

הרצה “יבשה”:

curl -sS -i -X POST https://<PUBLIC>/webhook/incoming_call | sed -n '1,200p'

מצופה: 200 + Content-Type: text/xml + <Response>...<Connect><Stream url="wss://<PUBLIC>/ws/twilio-media" .../></Connect>...</Response>

⸻

D) סדר פעולות קצר כדי שתראה תוצאה מהר
	1.	עדכן את ws_twilio_media ל־handler המוצע למעלה.
	2.	ודא שה־Procfile מריץ Uvicorn בלבד (כבר בסדר אצלך).
	3.	תקן את /webhook/recording_done כך שיחזיר 200 מיידי.
	4.	הפעל/פרוס.
	5.	בדיקות:
	•	curl ל־/incoming_call → רואה TwiML תקין.
	•	curl ל־/webhook/recording_done → 200 OK.
	•	התקשר → ב-Debugger רואה stream-started ואז media (לא סגירה מיד), וב־logs רואה [WS] start ואז רצף media.
	•	בסיום — Twilio לא תדווח עוד 11200.

⸻

אם אתה רוצה – תדביק לי כאן:
	•	את שתי השורות האחרונות מהלוג סביב ws_twilio_media,
	•	את פלט ה־curl -i לשני ה־endpoints,
ואני אגיד לך אם נשארה חריגה/מיפוי אירועים שגורם לסגירה מוקדמת.