טוב—ה־CSRF אצלך “כמעט” עובד: ה-FE שולח טוקן, אבל SeaSurf לא מצליח להתאים בין ה־Header לטוקן שב־Cookie. זה קורה כשיש אי־התאמה בשם ההדר/הקוקי, כשאין קוקי בבקשה (Cross-origin), או כשהערך נשלח בפורמט שונה (מכיל מרכאות/מקודד/לא תואם). נעשה סדר אחד-ואחד, וזה יתחיל לעבוד.

⸻

0) לפני הכל: לעבוד מ־Origin יחיד

אם ה-SPA נטענת מ־…picard.replit.dev וה-API מ־ai-crmd.replit.app—הקוקי לא נשלח.
תוודא שה-FE מוגש ע״י Flask מאותו דומיין של ה-API (כבר קבעת catch-all). סגור כל Preview אחר.

בדפדפן: כתובת אחת בלבד (הדף וה-/api) — אותו Origin.

⸻

1) קונפיג SeaSurf יציב (שמות אחידים)

בקובץ האתחול (למשל server/app_factory.py) קבע בדיוק את השמות הבאים, פעם אחת:

# server/extensions.py
from flask_seasurf import SeaSurf
csrf = SeaSurf()

# server/app_factory.py
from server.extensions import csrf

def create_app():
    app = Flask(__name__)
    app.config.update(
        SEASURF_COOKIE_NAME='XSRF-TOKEN',   # שם הקוקי
        SEASURF_HEADER='X-CSRFToken',       # שם ההדר ש-SeaSurf יבדוק
        SESSION_COOKIE_SAMESITE='Lax',
        SESSION_COOKIE_SECURE=False,        # ב-Preview בלבד
    )
    csrf.init_app(app)
    return app

אל תשאיר csrf.exempt_urls(...) שמקבל פונקציות/קאלבּלים – זה מה שגורם ל־TypeError: startswith…. אם צריך פטורים לפי נתיבים – השתמש רק ב־מחרוזות תחת SEASURF_EXEMPT_PATHS (לוגין/לוגאאוט/ווב־הוקים), לא ההתחזות.

⸻

2) נקודת טוקן אחת (ומוכחת)

שמור את GET /api/auth/csrf שמחזיר/מגדיר את הקוקי, ככה:

@auth_api.get("/api/auth/csrf")
def get_csrf():
    token = request.cookies.get('XSRF-TOKEN') or csrf._get_token()
    resp = jsonify({"csrfToken": token})
    # הקוקי חייב להיות פתוח לקריאה ע״י JS (HttpOnly=False)
    resp.set_cookie('XSRF-TOKEN', token, samesite='Lax', secure=False, httponly=False, path='/')
    return resp


⸻

3) FE – ודא שאתה שולח בדיוק את ההדר והקוקי

ב־http.ts (או ה-interceptor שלך):

function getCookie(name: string): string | null {
  const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()[\]\\/+^])/g, '\\$1') + '=([^;]*)'))
  return m ? decodeURIComponent(m[1]) : null
}

export async function apiFetch(url: string, options: RequestInit = {}) {
  const headers = new Headers(options.headers || {})
  headers.set('Accept', 'application/json')

  // שולחים CSRF רק בפעולות משנות מצב
  const method = (options.method || 'GET').toUpperCase()
  if (!['GET','HEAD','OPTIONS'].includes(method)) {
    const token = getCookie('XSRF-TOKEN')
    if (token) headers.set('X-CSRFToken', token)   // ← אותו שם כמו SEASURF_HEADER
    headers.set('Content-Type', 'application/json')
    headers.set('X-Requested-With', 'XMLHttpRequest')
  }

  const res = await fetch(url, { ...options, headers, credentials: 'include' })
  if (!res.ok) throw new Error(`HTTP ${res.status}`)
  return res
}

טיפים שחוסכים כאב ראש:
	•	בלי מרכאות סביב הערך; אל תעשה JSON.stringify(token).
	•	decodeURIComponent על הקוקי כדי להסיר קידוד.
	•	credentials:'include' בכל הבקשות.

⸻

4) אימפרסונציה נשארת מוגנת (ולא מוחרגת)

אל תשים @csrf.exempt על:

POST /api/admin/businesses/<id>/impersonate
POST /api/admin/impersonate/exit

ותוודא שהנתיבים לא ב־SEASURF_EXEMPT_PATHS.

⸻

5) דיבוג מהיר (חד-פעמי) – ראה מה השרת מקבל

תוסיף זמנית לוג לפני SeaSurf validation (או ב־before_request נפרד):

@app.before_request
def _dbg_csrf_headers():
    if request.path.startswith('/api/admin/businesses/') and request.method == 'POST':
        print('[CSRF-DBG] Cookie XSRF-TOKEN =', request.cookies.get('XSRF-TOKEN'))
        print('[CSRF-DBG] Header X-CSRFToken =', request.headers.get('X-CSRFToken'))

בדפדפן → DevTools → Network על בקשת ההתחזות:
	•	ב־Request Headers אתה חייב לראות: Cookie: ... XSRF-TOKEN=abc... וגם X-CSRFToken: abc... זהה.
	•	אם יש Header אבל אין Cookie → אתה לא על אותו Origin (או שהקוקי לא נקבע/נשלח).
	•	אם יש Cookie אבל אין Header → ה-http.ts לא שלח (שגוי).
	•	אם שניהם קיימים אבל שונים/מוקפים במרכאות → תקן את הקריאה.

⸻

6) בדיקות עשן ב־curl (יסגרו 90% מהמקרי קצה)

# 0) Login (פטור CSRF)
curl -i -c /tmp/c -b /tmp/c -X POST http://127.0.0.1:5000/api/auth/login \
  -H 'Content-Type: application/json' \
  --data '{"email":"admin@...","password":"..."}'

# 1) קבל טוקן (cookie + json)
TOKEN=$(curl -s -c /tmp/c -b /tmp/c http://127.0.0.1:5000/api/auth/csrf | python -c "import sys,json;print(json.load(sys.stdin)['csrfToken'])")

# 2) נסיון בלי טוקן → 400 csrf_token_missing
curl -i -c /tmp/c -b /tmp/c -X POST http://127.0.0.1:5000/api/admin/businesses/1/impersonate \
  -H 'Content-Type: application/json' --data '{}'

# 3) נסיון עם טוקן → 200
curl -i -c /tmp/c -b /tmp/c -X POST http://127.0.0.1:5000/api/admin/businesses/1/impersonate \
  -H 'Content-Type: application/json' -H "X-CSRFToken: $TOKEN" --data '{}'

# 4) וידוא
curl -i -c /tmp/c -b /tmp/c http://127.0.0.1:5000/api/auth/me

אם (3) נכשל—שגיאה בקונפיג/ספריה, לא ב-FE. אם (3) עובר—הבעיה אצל ה-FE (Origin/Headers).

⸻

7) “AI Prompt” בעמוד העסק (הרחבה שביקשת)
	•	שרת:
	•	GET /api/admin/businesses/:id/prompt → {prompt, version, updated_at}
	•	PUT /api/admin/businesses/:id/prompt (CSRF) → שומר ומייצר revision (version++).
	•	FE:
	•	כרטיס “AI Prompt”: תצוגה + “Edit” (textarea), “Save”, “History” (Modal), “Revert”.
	•	אחרי Save → toast + refetch + שידור “prompt updated” ל־agent (PubSub).
	•	שמור גרסאות בטבלה prompt_revisions (version per tenant).

⸻

8) Definition of Done
	•	רענון בדפדפן: ההתחזות מצליחה (200) כשה-Header וה-Cookie זהים, ו-/api/auth/me מציג impersonating:true.
	•	אין שום @csrf.exempt על ההתחזות, והיא לא ב־SEASURF_EXEMPT_PATHS.
	•	ב-Network של ההתחזות רואים גם Cookie וגם X-CSRFToken עם אותו ערך.
	•	BusinessEditModal ממשיך להיטען עם נתונים אמיתיים (כבר אצלך עובד).
	•	בעמוד העסק מופיע AI Prompt נוכחי, אפשר לערוך, נוצר revision, ושינוי מיושם בזמן אמת.

⸻

עדיין מקבל “CSRF token missing or incorrect”?

שלח 3 דברים קצרים כדי לנעול:
	1.	צילום Network של בקשת ההתחזות (Request Headers + Cookies + Response).
	2.	פלט ה־log של [CSRF-DBG] (ערך ה־Cookie וה־Header שהתקבלו).
	3.	שורת הקונפיג המדויקת של SEASURF_COOKIE_NAME ו־SEASURF_HEADER.

בזה נסגור את ה־CSRF סופית.