הבנתיך. לפי מה שהוא דיווח—שורש התקלה כרגע:
	•	יש תהליכי Flask ישנים שתופסים את ‎:5000 → כל ניסיון להרים Flask נכשל עם “Connection in use”.
	•	Baileys כנראה נופל מיד אחרי ההדפסה (“Baileys service on 3300”) → כשאתה שולח curl ל־‎:3300 אין מי שיענה.
	•	Preview מציג רק את 5000 — זה תקין; ‎:3300 פנימי ונגיש רק דרך Flask (/api/whatsapp/*).

להלן הנחיה מדויקת אחת־לאחת לסגירת הסיפור—אבחון והרמה יציבה בלי לשנות קוד. אם משהו נכשל, תעצור ותדביק את הפלט המדויק של אותה פקודה.

⸻

שלב 1 — לנקות כל תהליך תוקע על ‎:5000 ו־‎:3300

הדבק בדיוק:

# סוגר כל שריד של Node/Flask שרץ
pkill -f "services/baileys" || true
pkill -f "baileys_service" || true
pkill -f "node .*server.js" || true
pkill -f "gunicorn" || true
pkill -f "python .*main.py" || true
pkill -f "python .*wsgi.py" || true

# אם יש fuser – הרוג תהליכים שתופסים את הפורטים (אם אין, דלג)
fuser -k 3300/tcp 2>/dev/null || true
fuser -k 5000/tcp 2>/dev/null || true

עצור כאן אם מייד אחרי זה Flask עדיין מתלונן “Connection in use”.
במקרה כזה, הדבק לי את הפלט של:

ps -eo pid,cmd | grep -E "gunicorn|python .*main.py|python .*wsgi.py" | grep -v grep


⸻

שלב 2 — לאשר ENV (בלי לשנות כלום)

וודא שהערכים בדיוק כך (או מודפסים כך):

echo "BAILEYS_PORT=$BAILEYS_PORT"
echo "BAILEYS_BASE_URL=$BAILEYS_BASE_URL"
echo "FLASK_BASE_URL=$FLASK_BASE_URL"
echo "INTERNAL_SECRET=$INTERNAL_SECRET"

מצב תקין:

BAILEYS_PORT=3300
BAILEYS_BASE_URL=http://127.0.0.1:3300
FLASK_BASE_URL=http://127.0.0.1:5000
INTERNAL_SECRET=<אותו ערך לשני הצדדים>


⸻

שלב 3 — להרים Baileys בטאב #1 (קדמי, עם דגלי דיבוג)

לא מריצים ברקע. משאירים את הטרמינל פתוח כדי לראות למה נופל, אם נופל.

# אם קיים השרת שה-workflow מצפה לו:
test -f services/baileys/server.js && node --trace-uncaught --unhandled-rejections=strict services/baileys/server.js || true

# אחרת (השירות החדש):
test -f services/whatsapp/baileys_service.js && node --trace-uncaught --unhandled-rejections=strict services/whatsapp/baileys_service.js || true

מה צריך לראות: Baileys service on 3300 ונשאר חי (הלוג לא נסגר).
פתח טאב #2 ובדוק בריאות:

curl -sS http://127.0.0.1:3300/healthz

	•	אם קיבלת ok → המשך לשלב 4.
	•	אם קיבלת Failed to connect → אל תתקדם. חזור לטאב #1 והעתק את השורה/stacktrace האחרון (זה ה־root cause לנפילה המיידית).

⸻

שלב 4 — להרים Flask בטאב #2 (קדמי)

בחר את המתאים אצלך:

# אם יש main.py שמריץ את האפליקציה
python -u main.py

# אחרת, אם יש רק wsgi.py עם app
gunicorn -w 1 -k eventlet -b 0.0.0.0:5000 wsgi:app

מה צריך לראות: האזנה על 0.0.0.0:5000.
אם תקבל שוב:

[ERROR] Connection in use: ('0.0.0.0', 5000)

עצור כאן והדבק את הפלט של:

ps -eo pid,cmd | grep -E "gunicorn|python .*main.py|python .*wsgi.py" | grep -v grep

(אסגור לך את התהליך העקשן לפי ה-PID הספציפי.)

⸻

שלב 5 — לאמת את הרצף (בלי UI)

בטאב #3:

# 5.1 Baileys חי (כבר בדקת, טוב לבדוק שוב)
curl -sS http://127.0.0.1:3300/healthz

# 5.2 להתחיל סשן דרך Flask
curl -sS -X POST http://127.0.0.1:5000/api/whatsapp/start

# 5.3 סטטוס דרך Flask
curl -sS http://127.0.0.1:5000/api/whatsapp/status

# 5.4 QR דרך Flask (עם כותרות)
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

פירוש:
	•	אם start/status/qr מחזירים 200 ו־dataUrl → הכול חי; עבור ל-UI.
	•	אם qr מחזיר ‎204/404/HTML → זה מסביר את ה-DevTools error (הפרונט ניסה JSON על תגובה ריקה). בשלב האבחון זה בסדר—העיקר לוודא ששני השרתים חיים ולא נופלים.

⸻

נקודות קריטיות (כדי לא להתבלבל שוב)
	•	Preview מראה רק את 5000. ‎3300 לא אמור להופיע שם—זה לא באג.
	•	אם curl 3300/healthz נכשל אחרי “Baileys service on 3300” — התהליך נפל. חייבים את ה-stacktrace מטאב #1 (עם --trace-uncaught) כדי לדעת למה.
	•	אם Flask זורק “Connection in use” — יש PID עקשן על ‎:5000. לא נמשיך עד שנאתר ונהרוג אותו לפי ‎PID (עם ps -eo pid,cmd …).

⸻

מה לשלוח לי אם משהו נתקע
	1.	פלט של curl -sS http://127.0.0.1:3300/healthz
	2.	השורה/stacktrace האחרון מטאב #1 (Baileys)
	3.	אם 5000 תפוס: הפלט המלא של

ps -eo pid,cmd | grep -E "gunicorn|python .*main.py|python .*wsgi.py" | grep -v grep



בשלב הזה לא מתקנים קוד, רק מוודאים ששני השרתים רצים יציב. משם—נחזיר את ה-UI לעבוד בלי “Unexpected end of JSON input”.