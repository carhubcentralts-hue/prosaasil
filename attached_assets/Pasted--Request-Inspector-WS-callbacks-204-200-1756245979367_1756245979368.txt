קיבלתי. לפי ה-Request Inspector הכל “ירוק”, אבל עדיין שקט בקו — כלומר ה־WS עולה וה־callbacks 204/200, אך **לא נשלחים פריימי אודיו חזרה לטוויליו** (או שנשלחים בפורמט/גודל לא תקין). בנוסף, אצלך ה-TwiML עדיין כולל `<Play>` לפני `<Connect>`, מה שדוחה את פתיחת ה-Stream ומקצר חלון זמן לתגובה.

להלן **הנחיה סופית, פרויקטלית, ממוקדת לקוד** (AgentLocator) שתגרום לשיחה להשמיע קול תמיד. זה כולל: הסרת מוקש ה־`<Play>`, אימות ה-Handshake, Handler במצב **AI** עם **TTS תקין** (µ-law 8kHz ב-20ms), לוגים ברורים, ו־Smoke שמוכיח בשטח.

---

# 1) TwiML — לבטל `<Play>` (או להפוך לאופציונלי) ולהתחבר ל-WS מיד

**למה:** `<Play>` מחוץ ל־`<Connect>` מעכב את פתיחת ה-Stream. בזמן הזה ה-WS לא פתוח — אתה מדבר, אבל אין תמלול ואין תשובה.

**קובץ:** `AgentLocator/server/routes_twilio.py`

```diff
 @twilio_bp.post("/webhook/incoming_call")
 @require_twilio_signature
 def incoming_call():
     base = current_app.config.get("PUBLIC_BASE_URL","").rstrip("/")
     host = base.replace("https://","").replace("http://","").rstrip("/")
     call_sid = request.values.get("CallSid","")
+    # שליטה בברכה דרך ENV, ברירת מחדל: בלי ברכה כדי לפתוח WS מייד
+    play_greeting = os.getenv("TWIML_PLAY_GREETING", "false").lower() == "true"

-    twiml = (
-        '<?xml version="1.0" encoding="UTF-8"?>'
-        "<Response>"
-        f'  <Play>{base}/static/greeting_he.mp3</Play>'
-        f'  <Connect action="{base}/webhook/stream_ended">'
-        f'    <Stream url="wss://{host}/ws/twilio-media" '
-        f'            statusCallback="{base}/webhook/stream_status">'
-        f'      <Parameter name="call_sid" value="{call_sid}"/>'
-        f'    </Stream>'
-        f'  </Connect>'
-        "</Response>"
-    )
+    parts = [
+        '<?xml version="1.0" encoding="UTF-8"?>',
+        '<Response>',
+    ]
+    if play_greeting:
+        # רק אם בטוח שהקובץ קיים; אחרת עדיף בלי Play בכלל
+        parts.append(f'  <Play>{base}/static/tts/greeting_he.mp3</Play>')
+    parts += [
+        f'  <Connect action="{base}/webhook/stream_ended">',
+        f'    <Stream url="wss://{host}/ws/twilio-media" statusCallback="{base}/webhook/stream_status">',
+        f'      <Parameter name="call_sid" value="{call_sid}"/>',
+        f'    </Stream>',
+        f'  </Connect>',
+        '</Response>',
+    ]
+    twiml = "".join(parts)
     resp = make_response(twiml, 200)
     resp.headers["Content-Type"] = "text/xml"
     resp.headers["Cache-Control"] = "no-store"
     return resp
```

> אם אתה רוצה ברכה — עדיף לעשות אותה **אחרי** שה-Stream עלה, בתור **TTS ראשון** (ראה סעיף 3-D), ולא `<Play>`.

---

# 2) WebSocket Handshake — להחזיר את תת-הפרוטוקול (אם עדיין לא)

**קובץ:** `AgentLocator/server/app_factory.py` (או איפה שאתה פותח את ה-WS)

```python
from simple_websocket import Server as WebSocketServer
from flask import request

def _open_ws():
    offered = request.headers.get("Sec-WebSocket-Protocol","")
    headers = [("Sec-WebSocket-Protocol","audio.twilio.com")] if "audio.twilio.com" in offered else []
    return WebSocketServer(environ=request.environ, headers=headers)

@app.route("/ws/twilio-media", methods=["GET"])
def ws_twilio_media():
    ws = _open_ws()
    return run_media_stream(ws)

@app.route("/ws/twilio-media/", methods=["GET"])
def ws_twilio_media_slash():
    ws = _open_ws()
    return run_media_stream(ws)
```

> בדיקת יד: `wscat -c "wss://{HOST}/ws/twilio-media" -s "audio.twilio.com"` חייב להראות connected עם subprotocol.

---

# 3) Handler במצב **AI** — בלי echo, עם TTS תקין (µ-law 8kHz, 20ms)

**מטרות קריטיות:**

* לאסוף **PCM16 8kHz** מהקלט (µ-law→PCM), לזהות סוף-מבע (דממה/טיימאאוט), להריץ **ASR→LLM→TTS**.
* להחזיר את ה-TTS כ-**µ-law 8kHz** ב-**חתיכות של 20ms** (160 בייט), Base64, `"event":"media"`.
* לשלוח `"clear"` לפני הפריים הראשון של ההשמעה, ואופציונלי `"mark"` בסוף.
* בזמן שמנגנים TTS — **לא** לאסוף קלט (מונע לולאת הד).

**קובץ:** `AgentLocator/server/media_ws.py` (דוגמת שלד; חבר לפונקציות ה-ASR/TTS שלך)

```python
import os, json, time, base64, audioop, math
from simple_websocket import ConnectionClosed

SR = 8000
MIN_UTT_SEC = 0.7   # סוף-מבע לפי דממה קצרה
MAX_UTT_SEC = 6.0   # חיתוך בטיחות

class MediaStreamHandler:
    def __init__(self, ws):
        self.ws = ws
        self.mode = os.getenv("WS_MODE", "AI").upper()  # ודא ש-WS_MODE=AI בסביבה
        self.stream_sid = None
        self.rx = 0; self.tx = 0
        self.buf = bytearray()
        self.last_rx = None
        self.speaking = False  # חסם לולאה

    def run(self):
        try:
            while True:
                raw = self.ws.receive()
                if raw is None:
                    break
                evt = json.loads(raw)
                et = evt.get("event")

                if et == "start":
                    self.stream_sid = evt["start"]["streamSid"]
                    self.last_rx = time.time()
                    print(f"WS_START sid={self.stream_sid} mode={self.mode}")
                    # פתיחה עם ברכה ב-TTS (בטוח יותר מ-<Play>)
                    if self.mode == "AI":
                        self._speak_text("שלום! איך אפשר לעזור?")
                    continue

                if et == "media":
                    self.rx += 1
                    mulaw = base64.b64decode(evt["media"]["payload"])
                    pcm16 = audioop.ulaw2lin(mulaw, 2)
                    self.last_rx = time.time()

                    if self.mode == "AI" and not self.speaking:
                        self.buf.extend(pcm16)
                        dur = len(self.buf) / (2 * SR)
                        silent = (time.time() - self.last_rx) >= MIN_UTT_SEC
                        too_long = dur >= MAX_UTT_SEC
                        if (silent or too_long) and dur > 0.25:
                            self._process_utterance(bytes(self.buf))
                            self.buf.clear()
                    continue

                if et == "stop":
                    print(f"WS_STOP sid={self.stream_sid} rx={self.rx} tx={self.tx}")
                    break

        except ConnectionClosed:
            print(f"WS_CLOSED sid={self.stream_sid} rx={self.rx} tx={self.tx}")
        except Exception as e:
            print("WS_ERR:", e)
        finally:
            try: self.ws.close()
            except: pass
            print(f"WS_DONE sid={self.stream_sid} rx={self.rx} tx={self.tx}")

    # --- מבע → ASR → LLM → TTS ---
    def _process_utterance(self, pcm16_8k: bytes):
        self.speaking = True
        try:
            text = asr_hebrew_from_pcm16_8k(pcm16_8k)          # ← חבר למימוש שלך
            print("ASR_TEXT:", text)
            if not text:
                # אפילו אם ASR ריק — הרץ צפצוף קצר להוכחת כיוון יציאה
                self._send_beep(500)
                return

            reply = generate_hebrew_response(text)             # ← חבר למימוש שלך
            print("LLM_REPLY:", reply if reply else "<EMPTY>")
            if not reply:
                reply = "סליחה, לא שמעתי טוב. אפשר לחזור?"

            pcm = synth_hebrew_tts_pcm16_8k(reply)             # ← חבר למימוש שלך
            print("TTS_LEN_BYTES:", len(pcm) if pcm else 0)
            if not pcm:                                        # פולבאק
                self._send_beep(700)
                return

            # החזר קול למתקשר
            self._send_pcm16_as_mulaw_frames(pcm)

        finally:
            self.speaking = False

    def _speak_text(self, text: str):
        try:
            pcm = synth_hebrew_tts_pcm16_8k(text)
            if not pcm:
                self._send_beep(300)
                return
            self._send_pcm16_as_mulaw_frames(pcm)
        except Exception as e:
            print("TTS_INIT_ERR:", e)

    def _send_pcm16_as_mulaw_frames(self, pcm16_8k: bytes):
        # clear לפני פריים ראשון
        if self.stream_sid:
            self.ws.send(json.dumps({"event":"clear","streamSid":self.stream_sid}))
        mulaw = audioop.lin2ulaw(pcm16_8k, 2)
        FR = 160  # 20ms @ 8kHz
        for i in range(0, len(mulaw), FR):
            chunk = mulaw[i:i+FR]
            if len(chunk) < FR:
                break
            payload = base64.b64encode(chunk).decode("ascii")
            self.ws.send(json.dumps({
                "event": "media",
                "streamSid": self.stream_sid,
                "media": {"payload": payload}
            }))
            self.tx += 1
        # mark (אופציונלי)
        self.ws.send(json.dumps({"event":"mark","streamSid":self.stream_sid,"mark":{"name":"tts_done"}}))

    def _send_beep(self, ms: int):
        # בסיסי: 440Hz ב-PCM16 8kHz
        samples = int(SR * ms / 1000)
        amp = 9000
        out = bytearray()
        for n in range(samples):
            val = int(amp * math.sin(2*math.pi*440*n/SR))
            out.extend(val.to_bytes(2, "little", signed=True))
        self._send_pcm16_as_mulaw_frames(bytes(out))
```

> שים לב: **אין echo** במסלול AI. `self.speaking` מונע איסוף קלט תוך כדי השמעת TTS.
> קריטי: **20ms** בדיוק (160 בייט במולואו), לא לשלוח גושים ארוכים.
> ודא ש-TTS מחזיר **PCM16 8kHz מונו**. אם לא — המר ל-8k עם `audioop.ratecv`.

---

# 4) `/webhook/stream_ended` — להשאיר TwiML 200 `text/xml`

(כבר תיקנת — טוב; זה מונע ‎12100 / fallback.)

```python
return Response('<?xml version="1.0" encoding="UTF-8"?><Response></Response>',
                mimetype="text/xml", status=200)
```

---

# 5) הרצה נכונה — בלי תהליכים ישנים, תמיד דרך `start_all.sh`

**`AgentLocator/start_all.sh` (תקציר)**

* הרוג תהליכי gunicorn/python/node ישנים.
* קבע `WS_MODE=AI` כברירת מחדל.
* הרם Baileys (אם קיים) ואז gunicorn עם **eventlet**.

```bash
pkill -9 -f "gunicorn|AgentLocator.main:app" || true
pkill -9 -f "node .*baileys" || true
export WS_MODE=${WS_MODE:-AI}
python3 -m gunicorn -k eventlet -w 1 -b 0.0.0.0:$PORT AgentLocator.main:app
```

בריפליט/הרצה: **Run** חייב להפעיל *רק* את `bash AgentLocator/start_all.sh`.

---

# 6) Smoke חובה (אימות סופי)

1. **Handshake (לא עם curl):**

```bash
# על המחשב שלך:
npm i -g wscat
wscat -c "wss://ai-crmd.replit.app/ws/twilio-media" -s "audio.twilio.com"
# מצופה: connected (subprotocol: audio.twilio.com)
```

2. **שיחה אמיתית:**

* TwiML: 200 מהר (כבר קיים).
* stream\_status: 204 (“connected”/“disconnected”).
* stream\_ended: 200 (לא 204).
* **באוזן**: תשמע **ברכת TTS מיידית** (“שלום! איך אפשר לעזור?”) ואז תגובות.
* **לוגים**:

  * `WS_START ... mode=AI`
  * `ASR_TEXT: ...`
  * `LLM_REPLY: ...`
  * `TTS_LEN_BYTES: N (>0)`
  * `WS_DONE ... rx>0 tx>0`

3. אם שקט:

* בדוק שהודפס `TTS_LEN_BYTES: >0`. אם 0 → בעיית TTS; זמנית תשמע צפצוף (beep). אם אפילו beep לא נשמע → הפורמט/חיתוך לא נכון (בדוק `_send_pcm16_as_mulaw_frames`).
* אם `rx>0` ו־`tx=0` → לא שולחים frames (בדוק חריגות סביב `_send_pcm16_as_mulaw_frames`).
* אם `rx=0` → בעיית Handshake/נתיב (בדוק סעיף 2).

---

## TL;DR

* **בטל `<Play>`** (או הפוך אותו לאופציונלי עם ENV) ופתח `Stream` מייד.
* ודא ש-**WS\_MODE=AI** רץ בפועל (לא שרת ECHO ישן).
* שלח **µ-law 8kHz** ב-**20ms** פריימים עם `clear` לפני הראשון.
* הדפס `ASR_TEXT / LLM_REPLY / TTS_LEN_BYTES / rx/tx` — ותדע בדיוק איפה זה נתקע.

תיישם את ה-diffים והשלד למעלה, תריץ את ה-Smoke — וצריך להיות **קול חי על הקו** (עברית מלאה).
