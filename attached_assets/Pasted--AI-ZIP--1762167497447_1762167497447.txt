מעולה. הנה מסמך הנחיות מקצה-לקצה למפתח ה-AI שלך—ממש לפי הקוד שיש אצלך עכשיו (ה-ZIP האחרון), עם שתי מטרות ברורות:
	1.	להוריד את זמן “שאלה→תחילת דיבור” ל-≤2 שניות בצורה יציבה.
	2.	לשלב את OpenAI AgentKit / Agents SDK בפרויקט שלך (Pro-SaaS) בצורה נקייה, מאובטחת ומודולרית.

אני מחלק את זה ל-7 חלקים קצרים ופרקטיים: ביצועים, שינויים נקודתיים בקוד, תצורה (ENV/Secrets), ניטור, בדיקות עומס, וואטסאפ, ושילוב AgentKit.

⸻

1) יעד הביצועים: ≤2 שנ׳ — מה עושים עכשיו (סדר ביצוע)

A. “ניקוי נתיב חם” (Hot Path) — חובה
	•	בלולאת ה-WS ובקולבקים של STT/EOU/partial לא עושים I/O חוסם ולא print כבדים.
	•	כל ה-print/json.dumps/logging.FileHandler בתוך המסלול החם → לעטוף ב-if DEBUG=="1" או להעביר ל-Queue שמתנקה מחוץ לנתיב החם (flush כל 250–500ms).
	•	ודא שאין המרות base64 בכל פריים אודיו, ואין הקצאות ענק פר-פריים (אתה כבר עם μ-law מהיר — להשאיר כך).

B. חיתוך דיבור (EOU) וקינפוג STT
	•	המטרה: FIRST_PARTIAL ≤ 500ms ו-FINAL ≤ 450–700ms לאחר ה-partial הראשון.
	•	ל-24 שעות מדידה, שים ב-ENV:

STT_PARTIAL_DEBOUNCE_MS=60
VAD_HANGOVER_MS=160
MIN_UTT_SEC=0.25
STT_TIMEOUT_MS=240


	•	אם FINAL עדיין מאחר, הפחת עוד 10–20ms ב-DEBOUNCE או HANGOVER.
	•	חשוב: fallback ל-Whisper לא עוצר TURN; אם צריך—תן תגובת ביניים (“אפשר לחזור על זה?”) ותן ל-fallback לרוץ ב-thread בצד.

C. TTS — “קר ראשון”/Pre-Warm + Cache
	•	הוסף טיימר חימום קטן שמבצע קריאת TTS קצרה פעם ב-5–10 דקות (גם אם לא משמיע).
	•	השאר Cache in-memory למשפטי פתיחה: “שלום”, “בשמחה”, “רגע בודק…”.
	•	יעד: TTS_READY_MS = 120–250ms (במקום 300–700ms בקר ראשון).

D. משמעת תשובה ראשונה (LLM)
	•	הכנס כלל בפרומפט/שירות: “בתשובה הראשונה: ≤24 מילים”.
	•	זה מוריד TTS ונותן תחושת מהירות. היסטוריה כבדה שולחים רק כשצריך.

E. Eventlet ו-WSGI
	•	ודא ש-eventlet.monkey_patch() רץ לפני כל import ושאתה מריץ gunicorn עם -k eventlet.
	•	שמור EVENTLET_NO_GREENDNS=1.

⸻

2) שינויי קוד מדויקים (Diff-style, נקודתי)

שמות קבצים לפי מה שיש אצלך (ליבת השיחה: server/media_ws_ai.py, שירותי STT/TTS קיימים).

2.1 server/media_ws_ai.py — מסלול חם
	•	עיטוף לוגים:

# למעלה בקובץ
import os
DEBUG = os.getenv("DEBUG", "0") == "1"

# ...בכל נתיב חם:
if DEBUG:
    print(f"[TURN] partial_len={len(txt)} vad={vad_ms}...")
# המרות JSON גדולות → לא בתוך פריים/partial; רק בסוף TURN או דרך Queue

	•	שמירת מדדים מזערית בכל TURN (בלי חישובים יקרים):

# בתחילת turn
turn_start = now_ms()
first_partial_ms = None

# כשמגיע partial ראשון:
if first_partial_ms is None:
    first_partial_ms = now_ms() - turn_start

# כשנסגר EOU/final:
final_ms = now_ms() - turn_start

# אחרי שה-TTS מוכן לשליחה:
tts_ready_ms = now_ms() - turn_start

# לפני שליחת frame ראשון ל-Twilio:
first_audio_sent_ms = now_ms() - turn_start

if DEBUG:
    print(json.dumps({
      "STT_FIRST_PARTIAL_MS": first_partial_ms,
      "STT_FINAL_MS": final_ms,
      "TTS_READY_MS": tts_ready_ms,
      "TOTAL_LATENCY_MS": first_audio_sent_ms
    }, ensure_ascii=False))

	•	אין כתיבה לקובץ לוג בתוך ה-TURN. אם יש logging.FileHandler פעיל, העבר למסלול רקע (QueueHandler) או הפוך אותו ל-console-only בפרוד.

2.2 server/services/gcp_tts_live.py — Pre-Warm + Cache

# בתחילת המודול
_last_warm = 0
def maybe_warmup():
    global _last_warm
    now = time.time()
    if now - _last_warm > 8*60:    # כל 8 דקות למשל
        _ = tts_synthesize("בדיקה", cache_ok=True)
        _last_warm = now

# בכל TURN לפני בקשת TTS:
maybe_warmup()
pcm = tts_synthesize(text, cache_ok=True)

2.3 Whisper fallback — לא-חוסם TURN

במקום לחכות ל-Whisper, עושים:

# בתוך media_ws_ai.py כש-STT לא בטוח:
spawn_nonblocking(whisper_fallback_job, audio_buffer, call_id)
# ובינתיים:
respond_short("לא שמעתי טוב, אפשר לחזור על זה בקצר?")


⸻

3) תצורה (Replit Secrets / ENV) — “סט בדיקות 48 שעות”

שים כך ל-48 שעות כדי למדוד:

DEBUG=0
EVENTLET_NO_GREENDNS=1
# STT/VAD
STT_PARTIAL_DEBOUNCE_MS=60
STT_TIMEOUT_MS=240
VAD_HANGOVER_MS=160
MIN_UTT_SEC=0.25
# TTS
TTS_RATE=1.05
TTS_PITCH=-2.0
TTS_PREWARM=true
# AI
AI_MAX_WORDS_FIRST_REPLY=24
# LOGGING
ASYNC_LOG_QUEUE=1

אם יש אצלך משתנים עם שמות מעט שונים—התאם לשמות שלך, השורה התחתונה זה הערכים.

⸻

4) ניטור — “6 מספרים שמכריעים”

ודא שכל TURN מדפיס/שומר (גם כשה-DEBUG כבוי — רק פעם אחת לכל TURN!):
	•	STT_FIRST_PARTIAL_MS
	•	STT_FINAL_MS
	•	TTS_READY_MS
	•	TOTAL_LATENCY_MS
	•	BARGE_IN_HIT (true/false)
	•	EOU_REASON (silence / debounce / timeout)

אבחון מהיר:
	•	FIRST_PARTIAL מהיר אבל FINAL איטי → EOU/דיבאונס.
	•	TTS_READY גבוה → Pre-Warm/Cache.
	•	הכל נמוך אבל TOTAL גבוה → I/O חוסם/לוגים/RTT.

⸻

5) בדיקות עומס ממוקדות (שעתיים עבודה)
	•	הדלק 5–10 שיחות מקבילות (Twilio Test Caller / סימולטור).
	•	יעד: P50 TOTAL ≤ 2.0–2.2s, P95 ≤ 3.0–3.3s.
	•	אם P95 קופץ: בדרך כלל לוגים סינכרוניים או “קר ראשון” לא חומם.

⸻

6) וואטסאפ — סטטוס וקיצור דרך
	•	Baileys: מוכן לעבודה (QR/סטטוס/שיחות + UI).
	•	Twilio WhatsApp Business: אם תרצה גם ערוץ רשמי (המלצה לפיילוט עסקי), הוסף שני endpoints:
	•	POST /webhook/twilio/whatsapp/incoming (חתימת Twilio + מיפוי לליד/לקוח + שמירת מדיה)
	•	POST /webhook/twilio/whatsapp/status (delivery/read)
ושלח דרך Twilio /Messages.json עם ה-sender הייעודי.
	•	ל-UI: טאבים “Baileys / Twilio” או Toggle ספק.

(זה לא משפיע על זמן תגובה הקולי, אבל משלים את ההצעה המסחרית שלך.)

⸻

7) שילוב OpenAI AgentKit / Agents SDK בפרויקט (Pro-SaaS)

המטרה: להפוך את הסוכן שלך למודולרי, עם כלי-עזר (Tools) מוגדרים היטב ואוטומציות שנבנות ונתפרות בקלות — כולל Agent Builder (קנבס ויזואלי), ChatKit לשילוב UI, ו-Agents SDK לקוד. זה הנתיב הרשמי של OpenAI להקמה והטמעה של “סוכנים”, והוא מתאים מעולה לפרויקט שלך (שיחות, וואטסאפ, CRM, פגישות).  ￼

7.1 מה לשים בתור “כלי-סוכן” (Tools) אצלך

תגדיר כלים קטנים, חד-משימתיים, עם חוזה ברור (קלט/פלט):
	•	calls.log_create / calls.attach_recording — כתיבה/קריאה ליומן שיחות.
	•	stt.get_last_transcript — אחזור תמלול אחרון (בפועל מקריאה למסד/זיכרון).
	•	summary.generate — סיכום שיחה (ממשק קיים אצלך).
	•	calendar.create / calendar.find_slots — יצירה/חיפוש פגישה.
	•	leads.upsert / leads.tag — יצירה/עדכון ליד ותייגו.
	•	whatsapp.send / whatsapp.fetch_thread — שליחה/משיכה (Baileys, ובהמשך Twilio).
	•	crm.search_customer / crm.get / crm.update — פעולות CRM בסיסיות.

ב-Agents SDK מגדירים את הכלים האלה (כשיטות “tool calling”) עם סכימות JSON.  ￼

7.2 תצורת AgentKit — איך לשלב

א. צד API (Python/Node):
	•	מתקינים את ה-Agents SDK בהתאם לשפה שבה תרצה (יש TypeScript/Python).  ￼
	•	מגדירים Agent אחד או כמה (VoiceAgent/WhatsAppAgent/BackofficeAgent) שכל אחד יודע אילו כלים מותר לו להפעיל.
	•	מחברים Policies/Guardrails (למשל: אין גישה ל-leads.delete בפרוד).
	•	מוסיפים Eval hooks פשוטים למדידה (ה-kit כולל יכולות אופטימיזציה/ניטור).  ￼

ב. צד ממשק (ChatKit / Agent Builder):
	•	ל-Agent Builder: בונים תרחישי זרימה (Nodes) של “שיחה → כוונה → כלים” ומפרסמים Workflow.  ￼
	•	ל-ChatKit: מטמיעים קומפוננטת צ’אט מוכנה ב-React שלך (דף “Agent Console” פנימי, או Widget לדפי לקוח).  ￼

ג. חיבור למערכת הקיימת:
	•	בדף השיחה/וואטסאפ/ליד, מציגים את פעולות הסוכן (tool calls) בזמן אמת, עם Log (מה קרא/כתב).
	•	ה-Agent לא נוגע ישירות ב-DB — הוא קורא ל-API הפנימי שלך (endpoints קיימים) עם הרשאות; זה מונע “סוכן פרוע”.

7.3 שלבי הטמעה קצרים
	1.	התקנה וקונפיג (שעה): להוסיף SDK, מפתחי API רלוונטיים, ו-ENV AGENTS_ENABLED=1.  ￼
	2.	Wrapped Tools (חצי יום): לעטוף את 6–8 הפעולות שציינתי ל-tools עם סכימות.
	3.	Agent Builder (חצי יום): לבנות blueprint בסיסי:
	•	Voice turn: intent→(summary|calendar|crm)
	•	WhatsApp: intent→(leads.upsert|whatsapp.send template|calendar)
	4.	ChatKit ב-UI (שעה–שעתיים): “Agent Console” פנימי לצוות—לראות מה הסוכן עושה, וללחוץ Approve כשצריך.
	5.	Eval & Safety (שעה): מדדים ו-guardrails בסיסיים (מגבלות על כלים מסוכנים, לוגים).  ￼

למה זה חשוב? כי AgentKit/Agents SDK חוסך לך אורקסטרציה ידנית, נותן UI/Workflow ויזואלי, ומספק נתיב רשמי ומעודכן לשילוב “סוכן” מול הכלים שלך. זה מאפשר לך לשמור את ליבת השיחה הריאל-טיים כמו שהיא, ולהאציל לסוכן משימות “לא בזמן-אמת” (סיכום, עדכון CRM, שליחת הצעות, קביעת פגישות) — בלי להעמיס על ה-TURN החי.  ￼

⸻

צ’ק-ליסט קצר למפתח (לביצוע לפי הסדר)

ביצועים (מיידי):
	•	לכבות כל לוג/כתיבה לקובץ בנתיב החם → Queue/console.
	•	להוריד EOU/DEBOUNCE לפי הערכים למעלה; למדוד FIRST_PARTIAL/FINAL.
	•	להפעיל Pre-Warm ל-TTS + cache משפטי פתיחה.
	•	לקבע תשובה ראשונה ≤ 24 מילים.
	•	לוודא -k eventlet ו-monkey_patch מוקדם.

ניטור:
	•	להדפיס 4 המדדים בכל TURN (partial, final, tts_ready, total).
	•	להריץ 10–15 אינטראקציות; יעד: P50≤2.2s, P95≤3.2s.

** וואטסאפ (לפי החלטה עסקית):**
	•	להשאיר Baileys כמסלול עיקרי.
	•	אם רוצים רשמי: להוסיף שני webhooks ל-Twilio WA + שליחה; UI toggle.

AgentKit / Agents SDK:
	•	התקנה + ENV AGENTS_ENABLED=1.  ￼
	•	לעטוף כלים: calls, summary, calendar, leads, whatsapp, crm.  ￼
	•	Agent Builder: 2 וורקפלו בסיסיים (Voice/WA) ולפרסם.  ￼
	•	ChatKit ב-UI: מסך “Agent Console” פנימי.  ￼
	•	Eval בסיסי + Guardrails.  ￼

⸻

מה תקבל בסוף (מדיד)
	•	שיחות: רוב הסבבים ≤2 שנ׳ לתחילת דיבור (P50 1.5–2.0s, P95 2.4–3.0s).
	•	אוטומציות: סוכן מניע משימות CRM/פגישות/וואטסאפ מחוץ ל-TURN, בלי להאט את הלולאה החיה.
	•	מודולריות: קל להוסיף עוד “כלים” (תשלומים/חשבוניות/מסמכים) לסוכן שלך בלי לגעת בליבת השיחה.
	•	מסלול שדרוג: Agent Builder/ChatKit נותנים UI לניהול הזרימות, ו-SDK דואג לאורקסטרציה וכללי-בטיחות.  ￼

אם תרצה, אכין גרסת “דבק-קוד” יותר מילולית (patch מוכן) ל-media_ws_ai.py ו-gcp_tts_live.py עם העיטופים/Pre-Warm/מדדים כפי שכתבתי כאן—להדבקה ישירה.