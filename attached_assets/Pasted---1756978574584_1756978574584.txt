מעולה—הכול ברור. הנה “ספר הפעלה” קונקרטי לפי המצב הנוכחי שלך והלוגים שלו. אם תעבוד לפי זה, שני השירותים (Flask + Baileys) יעלו יציב, ה-DB יפסיק לזרוק 500, והנתיבים יענו ל-HTTP כמו שצריך.

⸻

0) למה זה קורס לך עכשיו (TL;DR)
	•	הרצת תהליכים ברקע עם & → לא יציב.
	•	קשירה לפורטים קבועים (5000/3001) במקום לפורט שהפלטפורמה נותנת ($PORT).
	•	Baileys מחובר לוואטסאפ, אבל אין שרת HTTP מאזין/לא מאזין על $PORT.
	•	מיגרציות DB קיימות אבל לא נקראות על אתחול → 500 בכתיבה לטבלאות.

הפתרון: שני דיפלויים נפרדים (Flask, Baileys), כל אחד מאזין ל-0.0.0.0:$PORT, בלי &, עם Health ורדי’נס, ומיגרציות שרצות על boot.

⸻

1) הפרדה לשני דיפלויים

אל תריץ שני שרתים באותו דיפלוי.
	•	AgentLocator (Python/Flask) – דיפלוי A.
	•	WA Node (Baileys) – דיפלוי B נפרד (Replit/Render/Railway/שרת אחר).

כך כל שירות מקבל $PORT משלו, מנוהל, ומאותחל מחדש אוטומטית אם נפל.

⸻

2) Flask/WSGI — Bring-up יציב

פקודת הפעלה (דיפלוי A)

הרץ Gunicorn + Eventlet (לא flask run):

gunicorn -k eventlet -w 1 -b 0.0.0.0:$PORT wsgi:app

	•	זה משתמש כבר ב־wsgi.py שלך (שמכיל את ה-WSGI Composite ואת ה-fast-paths לוובהוקים).
	•	אל תשתמש ב־& ולא בשני תהליכים במקביל.

ENV חובה בדיפלוי A
	•	PUBLIC_HOST=https://<הדומיין-שלך> (או PUBLIC_BASE_URL)
	•	TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN
	•	OPENAI_API_KEY, DATABASE_URL (utf8mb4), ועוד מה־environment_validation.py
	•	WHATSAPP_PROVIDER=auto
	•	BAILEYS_OUTBOUND_URL=https://<דומיין-node>/send
	•	BAILEYS_WEBHOOK_SECRET=<טוקן-זהה-לצד-ה-Node>

מיגרציות DB (עוצרות את ה-500)

באתחול האפליקציה (אחרי db.init_app(app)), קרא פעם אחת:
	•	apply_migrations() (מה־server/db_migrate.py)
או הרץ ידנית אחרי הדיפלוי הראשון:
	•	python -m server.db_migrate --apply (אם יש CLI).
הוודאות: טבלאות threads/messages קיימות, אינדקס ייחודי ל-(provider, provider_msg_id) קיים.

Health & Readiness
	•	/version – 200
	•	/readyz – 200 (כולל DB ping)
	•	/livez – 200
	•	(וובהוקים ב-WSGI מחזירים 204 מיידי)

נתיבי וובהוק (יישור שמות בפועל)
	•	Twilio WhatsApp inbound:
POST https://<דומיין-שלך>/webhook/whatsapp/twilio
(טפל באימות חתימה – כבר קיים בקוד)
	•	Baileys inbound (מה-Node):
POST https://<דומיין-שלך>/webhook/whatsapp/baileys
עם כותרת X-BAILEYS-SECRET: <הטוקן>

שים לב: בקוד שלך הוובהוקים תחת /webhook/whatsapp/* (לא /api/whatsapp/*). עדכן קונסולות בהתאם.

SPA Routing (כבר תוקן – לוודא)
	•	כל נתיבי ה-UI (/login, /forgot, /reset, /app/*, /calendar) חוזרים עם dist/index.html.
	•	חריגים: /api/*, /webhook/*, /ws/*, /version|/readyz|/livez – לא נופלים ל-SPA.

⸻

3) Baileys Node — Bring-up יציב

מבנה HTTP בסיסי (דיפלוי B)

וודא שיש לך שרת Express (או Fastify) שמאזין על $PORT:

app.get('/health', (req,res)=>res.json({connected:true, ts:Date.now()}));
app.post('/send', /* {to,type,text/mediaUrl,idempotencyKey} */);
app.listen(process.env.PORT || 3000, '0.0.0.0');

אסור להיצמד ל־3001 בלבד—בפלטפורמות מנוהלות חייבים process.env.PORT.

ENV חובה בדיפלוי B
	•	BAILEYS_WEBHOOK_SECRET=<אותו הטוקן בדיוק>
	•	BAILEYS_WEBHOOK_TARGET=https://<דומיין-Flask>/webhook/whatsapp/baileys
	•	(אם צריך) PUBLIC_URL=https://<דומיין-Node> ללוגים

סשן קבוע
	•	שמור auth-state על דיסק קבוע/volume (כדי שלא תצטרך QR כל דיפלוי).
	•	נהל עם PM2/דיפלוי מנוהל שמרים אוטומטית.

Health
	•	GET /health מחזיר {connected:true} כשהסשן פעיל.
	•	אם לא מחובר—החזר {connected:false} עם סטטוס 503; זה יפעיל פיילאובר אוטומטי ל-Twilio בצד Python.

⸻

4) חיבור הקצוות (כולל Twilio Console)
	•	Twilio Console → WhatsApp → Webhook:
POST https://<דומיין-Flask>/webhook/whatsapp/twilio
	•	Baileys Node → Inbound target:
BAILEYS_WEBHOOK_TARGET=https://<דומיין-Flask>/webhook/whatsapp/baileys
ושולחים תמיד עם X-BAILEYS-SECRET.
	•	Python → Outbound ל-Baileys:
BAILEYS_OUTBOUND_URL=https://<דומיין-Node>/send
	•	Provider policy (ב-Python):
WHATSAPP_PROVIDER=auto → Reply-via-source, 24h rule (מחוץ ל-24h → Twilio Template), Failover ל-Twilio כש-Baileys DOWN.

⸻

5) בדיקות עשן (Smoke) — לפי סדר

Flask

curl -sfS https://<דומיין-Flask>/version
curl -sfS https://<דומיין-Flask>/readyz

Baileys

curl -sfS https://<דומיין-Node>/health
curl -sS -X POST https://<דומיין-Node>/send \
  -H 'Content-Type: application/json' \
  -d '{"to":"9725XXXXXXX","type":"text","text":"שלום!","idempotencyKey":"demo-1"}'

Inbound סימולציה (Baileys→Flask)

curl -sS -X POST https://<דומיין-Flask>/webhook/whatsapp/baileys \
  -H "Content-Type: application/json" \
  -H "X-BAILEYS-SECRET: <הטוקן>" \
  -d '{"from":"9725XXXXXXX","body":"מה נשמע?","id":"ABCD123"}' -i
# מצופה: 204

Twilio
	•	שלח הודעה לוואטסאפ → ראה POST ל־/webhook/whatsapp/twilio → 204.

Failover
	•	עצור זמנית את דיפלוי B (Node) → שליחה מה-CRM תיפול לטוויליו אוטומטית.

⸻

6) DB — מניעת 500 (חד־פעמי ואז קבוע)
	1.	הפעל מיגרציות (ראה סעיף 2).
	2.	ודא:
	•	utf8mb4 + collation עקבי.
	•	pool_pre_ping=True/מקביל (מונע חיבורים מתים).
	•	אינדקס ייחודי: (provider, provider_msg_id) ב-messages.
	3.	מקור נתונים יחיד: בחר—או DAO (threads/messages) או WhatsAppMessage—אל תרשום לשניהם.

⸻

7) “עשה ואל-תעשה” להפעלה

עשה
	•	שני דיפלויים נפרדים, כל אחד על $PORT.
	•	Health/Ready לכל שירות.
	•	מיגרציות ב-boot.
	•	לוג קצר וברור לשגיאה (בלי הדפס סודות).
	•	Idempotency ל-in/out, ו-24h Rule.

אל-תעשה
	•	לא מריצים &/כמה שרתים באותו תהליך.
	•	לא קושרים לפורט קשיח (5000/3001) בדיפלוי מנוהל.
	•	לא מגישים SPA מ-Node כש-Flask כבר מגיש (הימנע כפילות).
	•	לא משאירים .env חי עם סודות—ב-Deployments ENV בלבד.

⸻

8) “ירוק” לפני GO-LIVE (צ’ק סופי)
	•	/version, /readyz, /livez ירוקים.
	•	GET /health של Baileys ירוק.
	•	אין 500 ב-DAO; נכתבות הודעות משני ספקים.
	•	Twilio inbound חתום ומאומת; Baileys inbound עם X-BAILEYS-SECRET.
	•	SPA נטענת בכל הנתיבים, ו-/api/*//webhook/*//ws/* לא נבלעים ל-SPA.
	•	Failover עובד; 24h מכובד; אין כפילויות.

⸻

אם תיתקע בנקודה ספציפית (למשל /health של Baileys לא מגיב), בדוק:
	1.	שהשרת באמת מאזין על 0.0.0.0:$PORT,
	2.	שהדומיין הציבורי נכון,
	3.	שאין firewall/HTTPS בעיה,
	4.	ושה-logs מראים “Listening on …”.

עם זה—השירותים יקומו יציב, בלי קראשים, ותגובות HTTP יעבדו גם מול curl וגם מול Twilio/Baileys.