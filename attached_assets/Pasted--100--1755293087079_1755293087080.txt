סגור. הנה הנחיה סופר־מפורטת, ממוקדת תיקון בלבד (בלי ליצור קבצים חדשים), שמביאה את המערכת ל־100% לשיחות עברית בזמן אמת (Media Streams + Whisper + GPT + Wavenet), עם כיסויים לתקלות עתידיות ובלי לפגוע במה שעובד.
הכל לפי המבנה/שמות הקיימים אצלך (משנים רק מה שחסר/שבור ומאחדים כפולים).

⸻

עקרונות זהב (לפני שמתחילים)
	•	לא יוצרים קבצים חדשים. רק עורכים את הקיימים. אם יש כפולים—מאחדים ומשביתים רישום של הישן.
	•	Stream בלבד לשיחות זמן אמת: לא משתמשים יותר ב־<Say>/<Gather> לשיחה עצמה (זה המקור ל־13512).
	•	WS פתוח, Webhooks חתומים: ה־WebSocket לא דורש חתימה; כל ה־Webhooks של Twilio (Voice/WhatsApp) כן.
	•	Fail-soft: כל נקודת כשל (TTS/STT/LLM) עטופה try/except עם התנהגות חלופית, כדי שלא יחזור 500 באמצע שיחה.

⸻

מה לתקן – לפי קובץ (קופי־פייסט)

1) server/app_factory.py – אתחול קרדנצ׳יאלס + Sock + רישום יחיד

מטרה: להבטיח ש־Wavenet יעלה, שה־WebSocket רשום, ושאין רישום כפול של Blueprints.
	1.	בתחילת יצירת ה־app הוסף (שורה קיימת לעריכה; לא ייצור קבצים חדשים):

from server.bootstrap_secrets import ensure_google_creds_file
ensure_google_creds_file()  # יוצר/מכוון GOOGLE_APPLICATION_CREDENTIALS אם קיים GOOGLE_TTS_SA_JSON

	2.	ודא שה־Sock מאותחל פעם אחת בלבד וש־WS רשום:

from flask_sock import Sock
sock = Sock(app)  # פעם אחת

אם יש אתחולי Sock נוספים—מחק את המיותר (השאר רק את זה).

	3.	רישום Blueprints: השאר רק את הקנוניים שאתה עובד איתם (דוגמאות נפוצות):

from server.routes_twilio import twilio_bp
from server.routes_whatsapp_twilio import wa_twilio_bp
from server.api_whatsapp_unified import whatsapp_unified_bp
from server.health_routes import health_bp

app.register_blueprint(twilio_bp)
app.register_blueprint(wa_twilio_bp)
app.register_blueprint(whatsapp_unified_bp)
app.register_blueprint(health_bp)

	•	אם רשומים גם whatsapp_routes.py/whatsapp_bp.py/גרסאות “clean/old” — השבת את ה־import וה־register (אל תמחק קובץ, רק אל תטעין).
	•	השאר Rate-limit/CORS/Request-ID כפי שהם, רק וודא משמעותית: CORS מצביע לדומיינים אמיתיים (לא *), וה־Limiter מוחל על מסלולי /webhook/* ו־/api/whatsapp/send*.

⸻

2) server/routes_twilio.py – חיבור לשיחת Media Streams

מטרה: שהשיחה תתחבר ל־WS במקום ל־<Say>/<Record>.

ב־incoming_call() החלף את גוף ההחזרה ל־TwiML הבא (עדכן דומיין WSS שלך):

from flask import Response
from server.twilio_security import require_twilio_signature

def _xml(x): return Response(x, status=200, mimetype="text/xml")

@twilio_bp.post("/webhook/incoming_call")
@require_twilio_signature
def incoming_call():
    twiml = """<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Connect>
    <Stream url="wss://YOUR_PUBLIC_DOMAIN/ws/twilio-media"/>
  </Connect>
</Response>"""
    return _xml(twiml)

	•	הסר/נטרל כל <Say language="he-IL"> או <Gather> מהזרימה הזו.
	•	השאר handle_recording/call_status כפי שהם (לצרכי ווקסמייל/בקרה), אבל שיחת זמן אמת תזרום דרך ה־WS.

⸻

3) media_ws.py (או server/routes/ws_media.py) – חיבורי STT/TTS/LLM ופולבאקים

מטרה: להבטיח שהלוגיקה בזמן אמת באמת עובדת, עם כיסויים.
	1.	ייבוא audio_utils – הפוך עמיד למסלולי import שונים:

try:
    from server.utils.audio_utils import b64_to_bytes, mulaw8k_to_pcm16k, pcm16k_float_to_mulaw8k_frames
except Exception:
    from audio_utils import b64_to_bytes, mulaw8k_to_pcm16k, pcm16k_float_to_mulaw8k_frames

	2.	Whisper אמיתי: ודא ש־transcribe_chunk(...) לא מחזיר מחרוזת קשיחה (“שלום”). אם יש, החלף באחד מהבאים (השאר מה שכבר עובד אצלך):

	•	faster-whisper (מקומי) או Whisper API (ענן). דאג שהפונקציה תמיד תחזיר "" במקרה כשל, לא תרים חריגה.

	3.	Wavenet (TTS) עם Fallback:
במקום הקריאה הישירה, עטוף:

def tts_he_wavenet_safe(text: str):
    try:
        # ... הקריאה הקיימת שלך ל-GCP (LINEAR16 @16k)
        return audio_float32_16k  # np.ndarray
    except Exception as e:
        # Fallback: משפט קצר באנגלית בעזרת טון ניטרלי או דילוג על שליחה
        # (אל תשתמש ב-<Say> כאן; WS צריך להחזיר אודיו או כלום)
        return None

ובמקום שימוש ישיר ב־TTS:

audio = tts_he_wavenet_safe(reply)
if audio is not None:
    for frame in pcm16k_float_to_mulaw8k_frames(audio):
        ws.send(json.dumps({"event":"media","streamSid":stream_sid,"media":{"payload":frame}}))
        time.sleep(0.02)
# אם None: מדלגים על תגובה קולית באמירה זו (עדיף שקט מאשר 500)

	4.	בקרת באפר/שתיקה (כדי למנוע “זליגה” בזיכרון):

	•	חתוך באפר נכנס אחרי עיבוד אמירה: buf16k = np.zeros(0, dtype=np.float32)
	•	מגבלת אורך אמירה: אם len(buf16k) > 8*16000 (8 שניות) → בצע תמלול גם בלי שקט (timeout).
	•	“ביי”/סיום: שמור כמו שיש — אם מזוהה מילה מסיימת → TTS קצר + Calls.update(status="completed").

⸻

4) server/bootstrap_secrets.py – שימוש בפועל

מטרה: לוודא שהקריאה ל־ensure_google_creds_file() באמת רצה (עשינו בסעיף 1).
	•	אין ליצור או לשנות קובץ אחר; רק לוודא שהפונקציה קיימת והיא לא זורקת חריגה אם ה־ENV ריק (פשוט תחזיר False).

⸻

5) server/routes_whatsapp_twilio.py ו־API המאוחד – איחוד ושמשמושים

מטרה: שלא יהיו כפילויות ושכל שליחת Twilio WA תקינה.
	1.	ודא שכאן יש שני ראוטים בלבד:

	•	POST /webhook/whatsapp/incoming (שומר הודעה נכנסת ל־DB)
	•	POST /webhook/whatsapp/status (מעדכן סטטוסים/זמנים ב־DB)

שניהם עם:

from server.twilio_security import require_twilio_signature
@require_twilio_signature

	2.	ב־API המאוחד (server/api_whatsapp_unified.py):

	•	שליחה דרך Twilio: נרמול from_:

from_num = os.getenv("TWILIO_WHATSAPP_NUMBER","")
if not from_num.startswith("whatsapp:"):
    from_num = f"whatsapp:{from_num}"

	•	אם יש ספק Baileys—ה־API שלך ממילא מתור ל־queue; ודא שאין שני קבצי provider נטענים (השאר רק את זה שבשימוש והסר import של הישן).

	3.	אל תרשום Blueprints/Routes הכפולים ב־app_factory.py (סעיף 1 כבר מכסה).

⸻

6) server/twilio_security.py – חתימות נכונות + דלג ב־TESTING

מטרה: שלא ייפול בפרודקשן, ושאפשר להריץ curl ב־dev.

ודא שהדקורטור:
	•	קורא ל־RequestValidator עם TWILIO_AUTH_TOKEN.
	•	מתקן URL מ־http ל־https אם יש X-Forwarded-Proto: https.
	•	במצב TESTING (app.config.get("TESTING")) — מדלג (לא מאמת).

⸻

7) Rate-limit / CORS / Health – השאר אך עדכן
	•	CORS: רשום דומיינים ספציפיים בלבד (prod + preview).
	•	Rate-limit: 30/min ל־incoming_call/handle_recording; 60/min ל־call_status//webhook/whatsapp/status; 30/min ל־/api/whatsapp/send*.
	•	/health: מחזיר 200; אם כבר קיים—לא לשנות.

⸻

איחוד כפולים – בלי למחוק קבצים
	•	אם קיימים קבצים כפולים (למשל whatsapp_routes.py לצד routes_whatsapp_twilio.py, או whatsapp_providers.py לצד whatsapp_provider.py), השבת את ה־import וה־register של הכפולים.
	•	אפשר להזיז ל־legacy/ אם כבר קיימת אצלך התיקייה. אם לא — אל תיצור חדשה (הנחיה מפורשת). מספיק לא לייבא/לא לרשום אותם כדי שלא יפריעו.

⸻

בדיקות GO/NO-GO (להריץ עכשיו)

A) שיחת זמן־אמת (TwiML)

curl -s -o /tmp/t.xml -w "HTTP %{http_code}\n" -X POST https://<DOMAIN>/webhook/incoming_call && head -n3 /tmp/t.xml
# מצופה: 200 + יש <Connect><Stream url="wss://<DOMAIN>/ws/twilio-media">

B) WebSocket נגיש
	•	ודא Nginx/Proxy עם Upgrade:

proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection "Upgrade";

	•	מבחן חיבור (עם כלי כמו wscat/בדיקה ייעודית): פתיחה ל־wss://<DOMAIN>/ws/twilio-media מצליחה.

C) TTS עובד (קרדנצ׳יאלס)
	•	בקונסולה של השרת: echo $GOOGLE_APPLICATION_CREDENTIALS מצביע לקובץ.
	•	אם אתה עובד עם GOOGLE_TTS_SA_JSON—ודא שהקריאה ensure_google_creds_file() רצה (לוג “created creds file”).

D) חתימות Twilio
	•	בקשת POST ללא חתימה אל /webhook/whatsapp/status → 401/403.
	•	עם חתימה (מטוויליו) → 204.

E) WhatsApp (Twilio)
	•	שליחה מ־API: חוזר sid והודעות סטטוס מגיעות ל־/webhook/whatsapp/status ומעדכנות DB.

⸻

Definition of Done (ברזל)
	•	incoming_call מחזיר אך ורק <Connect><Stream> עם URL תקין (WSS).
	•	WS בנתיב /ws/twilio-media רץ ומטפל ב־start/media/stop, מבצע Whisper→GPT→Wavenet מחזורי, בלי 500 גם אם אחד מהם נופל.
	•	audio_utils נטען בהצלחה (אחד מהמסלולים ב־try/except).
	•	ensure_google_creds_file() נקרא בעליית השרת; אין שגיאת אישורים ב־TTS.
	•	כל ה־Webhooks של Twilio עם @require_twilio_signature.
	•	אין רישום כפול של Blueprints/Routes; מפת הנתיבים נקייה מקונפליקטים.
	•	CORS/Rate-limit/Health—פעילים.
	•	curl בדיקות A–E ירוקות; Twilio Debugger נקי מ־13512 ו־11200.

⸻

אם תבצע את השינויים המדויקים למעלה (רק עריכות, בלי ליצור קבצים), אתה חוצה את שער ה־GO עם שיחות עברית רציפות בזמן אמת—Whisper מתמלל, GPT עונה, Wavenet משמיע—יציב ופרודקשני.