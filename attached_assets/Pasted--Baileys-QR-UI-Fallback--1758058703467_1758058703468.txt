מעולה – הבעיה עכשיו היא ש־Baileys לא רץ ולכן אתה מקבל QR “דמה” וה־UI נתקע על Fallback. ככה פותרים את זה, צעד-אחר-צעד, גם ל-Preview וגם ל-Deploy, בלי לשבור את ה-Flask וה-CSRF:

1) מרימים שירות Baileys יציב (Node)

package.json (בתיקייה baileys-service/)

{
  "name": "baileys-service",
  "type": "module",
  "scripts": { "start": "node server.js" },
  "engines": { "node": ">=18" },
  "dependencies": {
    "@adiwajshing/baileys": "^6.7.4",
    "express": "^4.19.2",
    "pino": "^9.3.0",
    "qrcode": "^1.5.3",
    "ws": "^8.18.0"
  }
}

server.js (בתיקייה baileys-service/)

import makeWASocket, { useSingleFileAuthState, DisconnectReason } from "@adiwajshing/baileys";
import express from "express";
import QRCode from "qrcode";
import pino from "pino";

const PORT = process.env.PORT || 3001;
const { state, saveState } = useSingleFileAuthState("./auth.baileys.json"); // נשמר בדיסק (רסטארט שורד)
const log = pino({ level: "info" });

let sock;
let lastQR = null;
let connectionState = "starting";
let meJid = null;

async function start() {
  sock = makeWASocket({
    printQRInTerminal: false,
    auth: state,
    logger: log
  });

  sock.ev.on("creds.update", saveState);

  sock.ev.on("connection.update", async (u) => {
    const { qr, connection, lastDisconnect } = u;
    if (qr) {
      lastQR = await QRCode.toDataURL(qr);
    }
    if (connection) connectionState = connection;
    if (connection === "close") {
      const code = lastDisconnect?.error?.output?.statusCode;
      if (code !== DisconnectReason.loggedOut) {
        log.warn({ code }, "conn closed – reconnecting");
        setTimeout(start, 1500);
      } else {
        log.error("logged out – delete auth.baileys.json to relogin");
      }
    }
  });

  sock.ev.on("contacts.upsert", (c) => (meJid = sock.user?.id || meJid));
}
await start();

const app = express();
app.use(express.json());

// בריאות
app.get("/health", (_, res) => {
  res.json({ ok: true, state: connectionState, me: meJid || null, hasQR: !!lastQR });
});

// QR (מחזיר dataURL)
app.get("/qr", (_, res) => {
  if (!lastQR) return res.status(404).json({ ok: false, message: "no qr yet" });
  res.json({ ok: true, qr: lastQR });
});

// שליחת הודעה (טקסט)
app.post("/send", async (req, res) => {
  try {
    const { to_e164, text } = req.body || {};
    if (!to_e164 || !text) return res.status(400).json({ ok: false, message: "to_e164 & text required" });
    const jid = to_e164.replace(/\D/g, "") + "@s.whatsapp.net";
    await sock.sendMessage(jid, { text });
    res.json({ ok: true });
  } catch (e) {
    log.error(e);
    res.status(500).json({ ok: false, message: "send failed" });
  }
});

app.listen(PORT, "0.0.0.0", () => log.info({ PORT }, "Baileys HTTP up"));

2) מפעילים את Baileys בריפליט (גם Preview וגם Deploy)

Workflows (מומלץ): צור Workflow בשם baileys עם הפקודה:

npm --prefix baileys-service ci && PORT=3001 node baileys-service/server.js

זה ישאיר את השירות חי.
ב־Preview אתה תראה רק את ה־Flask, אבל Baileys ירוץ ברקע על 3001.

3) פרוקסי דרך Flask (שומר same-origin, CSRF נשאר לעבוד)

ב־Flask כחלק מה־API, הוסף פרוקסי לנתיב /api/whatsapp/baileys/*:

# server/routes_baileys_proxy.py
import os, requests
from flask import Blueprint, request, Response
from server.auth_guard import require_api_auth  # אם יש
from server.extensions import csrf  # SeaSurf

bp = Blueprint("baileys_proxy", __name__)
BAILEYS_URL = os.getenv("BAILEYS_URL", "http://127.0.0.1:3001")

@bp.route("/api/whatsapp/baileys/<path:path>", methods=["GET","POST","OPTIONS"])
@require_api_auth(["admin","manager","business"])  # לקריאה שמוגנת
def _proxy(path):
    # SeaSurf יבדוק CSRF כרגיל עבור POST – טוב!
    url = f"{BAILEYS_URL}/{path}"
    resp = requests.request(
        method=request.method,
        url=url,
        params=request.args,
        data=request.get_data(),
        headers={k:v for k,v in request.headers if k.lower() != "host"},
        timeout=15
    )
    excluded = {"content-encoding","content-length","transfer-encoding","connection"}
    headers = [(k,v) for k,v in resp.headers.items() if k.lower() not in excluded]
    return Response(resp.content, resp.status_code, headers)

רשום את ה־Blueprint ב־app_factory. הגדר Secret: BAILEYS_URL=http://127.0.0.1:3001.

4) מחליפים את ה־Fallback ב־FE

ב־client, כל מקום שקורא QR/שליחה:
	•	Health: GET /api/whatsapp/baileys/health – אם ok:true ו־hasQR:true משוך GET /api/whatsapp/baileys/qr.
	•	שליחה: POST /api/whatsapp/baileys/send עם CSRF (ה־http.ts שלך כבר מוסיף X-CSRFToken).
	•	אם health.state !== 'open' – הצג הנחיות לסריקת QR.

5) בדיקות עשן – תריץ אחד לאחד

ב־Shell (אותה סשן, שומר קוקיז):

BASE=http://127.0.0.1:5000
# 1) Login → cookies
curl -i -c /tmp/c -b /tmp/c -H 'Content-Type: application/json' \
  -X POST $BASE/api/auth/login --data '{"email":"admin@shai-realestate.co.il","password":"*****"}'

# 2) CSRF token
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf | python - <<'PY'
import sys,json; print(json.load(sys.stdin)['csrfToken'])
PY
)

# 3) Baileys health
curl -i -c /tmp/c -b /tmp/c $BASE/api/whatsapp/baileys/health

# 4) QR (אמור להחזיר dataURL אם לא מחובר)
curl -s -c /tmp/c -b /tmp/c $BASE/api/whatsapp/baileys/qr | head

# 5) שליחת הודעה (מחייב סריקה קודם)
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X POST $BASE/api/whatsapp/baileys/send --data '{"to_e164":"+9725XXXXXXX","text":"שלום"}'

אם ③ מחזיר ok:true – השירות חי. אם ④ מחזיר 404 → עוד לא נוצר QR (חכה 1-2 שניות או בדוק לוגים). אם ⑤ נכשל 500 → תבדוק שהתחברת עם ה־QR וה־JID קיים.

6) למה זה נפל לך קודם (ולמה זה פותר)
	•	בריפליט תהליך בלי שרת HTTP מת – Baileys צריך Express שמאזין ל־PORT.
	•	Node/baileys בלי persist לא שורד ריסטארט – useSingleFileAuthState('./auth.baileys.json') פותר.
	•	Cross-origin גורם לצרות CSRF/CORS – הפרוקסי דרך Flask שומר same-origin וה־SeaSurf שלך ממשיך להגן אוטומטית.

7) Deploy
	•	שמור שני Workflows:
web – Flask+Gunicorn (כבר קיים).
baileys – הפקודה בסעיף 2.
	•	ב־Deploy תוודא שה־Secret BAILEYS_URL נשמר, ושהקו״פ של auth.baileys.json נשמר באחסון הקבוע (בתיקיית הפרויקט).

⸻

אם אחרי זה עדיין רואים “fallback QR”:
	1.	פתח לוג של Workflow baileys – רואה Baileys HTTP up?
	2.	GET /api/whatsapp/baileys/health – אם ok:false/שגיאה → השירות לא רץ.
	3.	אם ok:true אבל hasQR:false – חכה עד שיגיע event QR (לרוב עד 5 שנ׳) או בדוק שה־socket לא נסגר (DisconnectReason).
	4.	ודא שה־UI לא קורא לכתובת ישירה של 3001 – תמיד דרך /api/whatsapp/baileys/*.

זה יחזיר את ה-WhatsApp לחיים, יעלים את ה־QR המזויף, וישמור על CSRF ו־Single-Origin כך שכל הכפתורים (שליחה/סריקה/בריאות) יעבדו גם ב-Preview וגם ב-Deploy.