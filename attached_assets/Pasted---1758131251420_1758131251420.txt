סבבה—עוצרים “תיקונים”, ומסבירים בדיוק איפה התקלה ואיך לבדוק אותה בלי לשנות קוד.

מה הבעיה כאן (לאט וברור)
	1.	Preview ב-Replit מציג רק את פורט האפליקציה הראשית (5000 של Flask). זה תקין. את Baileys על ‎3300 לא תראה ב-Preview בכלל—הוא פנימי בלבד ונגיש דרך Flask (/api/whatsapp/*). זה לא באג.
	2.	ה-UI וה-DevTools זורקים שגיאות כי הבקשות ל-/api/whatsapp/qr מגיעות כשאחד השרתים לא באמת חי (או שניהם). ואז חוזר גוף ריק/HTML, והפרונט מנסה לעשות JSON.parse → “Unexpected end of JSON input”. זה סימפטום של שרת(ים) לא רצים, לא בעיית קוד פרונט.
	3.	מבחן שהרצת: Node הדפיס “Baileys service on 3300”, אבל curl 127.0.0.1:3300/healthz נכשל. המשמעות: התהליך מת מיד אחרי ההדפסה (exit מהיר), לכן אין מאזין כשאתה מנסה להתחבר. זה לא “פורט חסום”—זה תהליך שמת.

מה להגיד לו לעשות עכשיו (אבחון נטו, בלי לתקן שום קובץ)

תן לו להדביק אחד-לאחד. אם הוא נתקע—שיעצור בדיוק בשורה שנכשלה ויחזיר את הפלט הגולמי.

שלב 1 — לוודא שאין תהליכים “רפאים”

pkill -f "services/baileys" || true
pkill -f "baileys_service" || true
pkill -f "node .*server.js" || true
pkill -f "gunicorn" || true
pkill -f "python .*main.py" || true
pkill -f "python .*wsgi.py" || true

(אם יש ss/lsof שיראו מאזינים—טוב; אם לא, ממשיכים.)

###שלב 2 — לא נוגעים בקוד, רק מרימים כל שרת בטאב נפרד ובחזית
	1.	טאב #1 – Baileys (חזית):

# אם יש server.js ישן שה-workflow משתמש בו:
test -f services/baileys/server.js && node --trace-uncaught --unhandled-rejections=strict services/baileys/server.js

# אחרת (שירות חדש):
test -f services/whatsapp/baileys_service.js && node --trace-uncaught --unhandled-rejections=strict services/whatsapp/baileys_service.js

מה לצפות: הודעה בסגנון “Baileys service on 3300” ולהישאר חי.
לא סוגרים את הטאב הזה.
	2.	טאב #2 – Flask (חזית):

# אם יש main.py שמריץ app:
python -u main.py

# או (אם יש רק wsgi.py):
gunicorn -w 1 -k eventlet -b 0.0.0.0:5000 wsgi:app

גם הטאב הזה נשאר פתוח.

חשוב: לא מריצים שום דבר “ברקע”. שני הטאבים פתוחים עם לוגים חיים.

שלב 3 — בדיקות חיות (בלי UI)

ב-טאב שלישי:

# האם Baileys חי?
curl -sS http://127.0.0.1:3300/healthz

# התחלת סשן דרך Flask בלבד:
curl -sS -X POST http://127.0.0.1:5000/api/whatsapp/start

# סטטוס/QR דרך Flask:
curl -sS http://127.0.0.1:5000/api/whatsapp/status
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

איפה לעצור ולהחזיר נתונים (בלי לתקן):
	•	אם healthz נכשל: תחזור לטאב #1 של Baileys ותעתיק בדיוק את השורה האחרונה/stacktrace שמופיעה שם (זה יגיד לנו למה הוא מת מיד אחרי ה-“listening”).
	•	אם start מחזיר שגיאה: תחזור לטאב #2 (Flask) ותעתיק את השגיאה שמודפסת שם.
	•	אם qr מחזיר גוף ריק/HTML: תעתיק את ה-status line וה-headers+body המלאים מ-curl -i (זה מסביר למה ה-UI נופל על JSON).

למה זה מספיק בשלב הזה
	•	זה מבודד אם הבעיה היא תהליך Baileys שמת (הכי סביר), או Flask שלא מגיע לבייליס, או רק UI שמנסה לפרסר ריק.
	•	אין פה “תיקונים”—רק אימות רציפות והוצאת ה-root cause מהלוגים.

⸻

תשובות קצרות לשאלות שלך:
	•	“לא רואים את ה-port ב-Preview” — זה תקין. Preview מציג רק 5000. 3300 פנימי ותמיד ניגשים אליו דרך Flask.
	•	“למה DevTools אדום?” — כי ה-backend לא החזיר JSON (או נפל באמצע). זה צפוי כל עוד לא וידאנו שהשניים “חיים” בשני הטאבים.
	•	“אז איפה התקלה?” — בשלב הזה: Baileys מתחיל ונופל מייד. צריך את ה-stacktrace מטאב #1 אחרי שהפעלת אותו עם --trace-uncaught --unhandled-rejections=strict. זה יגיד אם זו הרשאה לתיקיות auth, מודול חסר, או בעיית סביבה אחרת.

תן לו להריץ בדיוק את השלבים, ולעצור במקום הראשון שנופל עם ההדפסה המדויקת. משם נדע לאן לכוון—אבל בלי לגעת בקוד עד שיש לנו את ה-root cause מהלוג.