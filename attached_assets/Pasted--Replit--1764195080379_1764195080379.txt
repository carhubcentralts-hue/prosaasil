סבבה, אני מבין אותך לגמרי – זה שלב שצריך כבר לתת לסוכן של Replit לעבוד בשבילך ולא שתמשיך להתבחבש עם 700 שורות קוד ו־Docker 🤦‍♂️

אני נותן לך עכשיו הנחיה אחת, מוכנה להדבקה, שמסדרת לו את כל המשימות:
	•	שיחות Twilio (webhooks, חתימות, 405 וכו’)
	•	Baileys / QR לוואטסאפ
	•	תיקונים ב־CRM (מחיקת ליד מהטלפון, מחיקת משתמשים)
	•	לוודא שהכול עובד חלק על השרת החיצוני (Contabo) וש־git push בעתיד לא ישבור שוב.

פשוט תעתיק כמו שהוא לסוכן Replit שלך.

⸻

🔧 הנחיה לסוכן Replit – ProSaaS Production Fix

Project name: ProSaaS / AgentLocator
Stack: Python Flask backend + React/TS frontend + Docker + Nginx + Postgres/NeonDB
Production server: Contabo (Ubuntu) עם docker-compose בנתיב /opt/prosaasil
Domain: https://prosaas.pro מאחורי Cloudflare.
Database: NeonDB דרך DATABASE_URL.

🎯 מטרות על
	1.	להביא את המערכת למצב Production מלא על השרת החיצוני – בלי פאטצ’ים ידניים.
	2.	לטפל בשלושה נושאים עיקריים:
	•	A. Webhooks של Twilio (שיחות) – לא יהיו יותר 405/403, הכל עובר ומתקמפל.
	•	B. Baileys / WhatsApp – יצירת QR + חיבור יציב.
	•	C. CRM / UI – כפתור מחיקת ליד גם במובייל + אפשרות למחיקת משתמשים למנהל מערכת / owner.
	3.	להבטיח שכל התיקונים נכנסים ל־Git, כך ש־git pull && docker compose up -d --build יחזיר בדיוק את אותו מצב עובד.

⸻

A. Twilio Voice – Webhooks & Security

A1. מציאת כל ה־webhooks
	1.	חפש בכל הפרויקט (ב־repo, לא רק בשרת) את כל המסלולים של טוויליו:
	•	incoming_call
	•	call_status
	•	handle_recording
	•	כל route תחת /webhook/…
	2.	קובץ(ים) רלוונטיים צפויים להיות בתוך server/ – למשל:
	•	server/twilio_routes.py או שם דומה
	•	server/twilio_security.py (כבר קיים, מטפל ב־X-Twilio-Signature)

A2. הגדרת המסלולים הנכונים

ודא שכל הראוטים של טוויליו מוגדרים כך:
	•	בלי prefix /api – כלומר הנתיב הוא:
	•	/webhook/incoming_call
	•	/webhook/call_status
	•	/webhook/handle_recording
	•	ומאופשרים גם ל־POST:

@twilio_bp.route("/webhook/incoming_call", methods=["POST", "GET"])
def incoming_call():
    ...

@twilio_bp.route("/webhook/call_status", methods=["POST", "GET"])
def call_status():
    ...

@twilio_bp.route("/webhook/handle_recording", methods=["POST", "GET"])
def handle_recording():
    ...

אם יש דקורטורים קיימים (auth, validate וכו’) – להשאיר אותם, אבל לוודא שהם לא חוסמים את הבדיקה.

A3. Nginx ו־Docker – מיפוי נכון

בקובץ docker/nginx.conf:
	1.	ודא שה־server block ל־80 נראה בערך כך:

server {
    listen 80;
    server_name prosaas.pro www.prosaas.pro;

    root /usr/share/nginx/html;
    index index.html;

    # SPA – תמיד להחזיר index.html
    location / {
        try_files $uri /index.html;
    }

    # API -> backend
    location /api/ {
        proxy_pass http://backend:5000/api/;
        proxy_http_version 1.1;
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Twilio webhooks (calls / recordings / statuses)
    location /webhook/ {
        proxy_pass http://backend:5000/webhook/;
        proxy_http_version 1.1;
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # n8n
    location /n8n/ {
        proxy_pass http://n8n:5678/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade           $http_upgrade;
        proxy_set_header Connection        "upgrade";
        proxy_set_header Host              $host;
    }

    # healthcheck
    location /health {
        access_log off;
        return 200 'ok';
        add_header Content-Type text/plain;
    }
}

	2.	בדוק ש־docker-compose.yml משתמש בשמות השירותים:
	•	backend: backend
	•	frontend: frontend
	•	n8n: n8n
ושכולם באותו network (prosaas-network).

A4. Twilio Signature & Proxy (Cloudflare / Nginx)

בקובץ server/twilio_security.py:
	1.	ודא שהלוגיקה משתמשת ב־URL הנכון מאחורי פרוקסי:
	•	Twilio מחשבת חתימה לפי ה־URL הציבורי (https://prosaas.pro/webhook/…).
	•	אם אתה בונה URL מתוך ה־Flask request – צריך לקחת בחשבון X-Forwarded-Proto ו־Host.
	2.	אם יש פונקציה כמו _effective_url(request) – ודא שהיא מחזירה בדיוק את מה שטוויליו רואה:

scheme = request.headers.get("X-Forwarded-Proto", request.scheme)
host = request.headers.get("Host", request.host)
url = f"{scheme}://{host}{request.path}"

	3.	הוסף אפשרות לכבות אימות חתימה בסביבת פיתוח:

import os

VALIDATE_TWILIO_SIGNATURE = os.getenv("VALIDATE_TWILIO_SIGNATURE", "true").lower() == "true"

if not VALIDATE_TWILIO_SIGNATURE:
    # דלג על אימות החתימה לצורך בדיקות
    return f(*args, **kwargs)

A5. בדיקות
	1.	כתוב או עדכן סקריפט בדיקה (scripts/test_twilio_webhooks.sh לדוגמה) שעושה:

curl -v -X POST "http://backend:5000/webhook/incoming_call" -d "CallSid=TEST&From=+972000&To=+972001"

	2.	מהשרת עצמו (Contabo) בדוק:

curl -v -X POST "http://213.199.43.223/webhook/incoming_call" \
  -d "CallSid=TEST123&From=%2B972000000000&To=%2B972000000001"

	3.	Acceptance:
	•	אין יותר 405.
	•	אין 403 בגלל חתימה, כל עוד החתימה תקינה.
	•	שיחה אמיתית מטלפון עוברת, וה־logs של Twilio לא מציגים 11200/11205/405.

⸻

B. Baileys / WhatsApp – QR & חיבור

B1. להבין את הזרימה
	1.	אתר את שירות ה־Baileys:
	•	Docker service בשם baileys או prosaas-baileys.
	•	קבצים: Dockerfile.baileys, תיקיית baileys/ או whatsapp_routes.py בצד ה־backend.
	2.	בצד ה־backend:
	•	חפש endpoints כגון:
	•	/api/whatsapp/baileys/init
	•	/api/whatsapp/baileys/qr
	•	/api/whatsapp/baileys/status
	•	ודא שהם מתקשרים ל־baileys דרך environment:
	•	BAILEYS_BASE_URL
	•	INTERNAL_SECRET
	•	וכו’.
	3.	בצד ה־frontend:
	•	מסך מנהל -> WhatsApp -> בחירת ספק Baileys.
	•	כפתור “יצירת QR” שמחזיר הודעת שגיאה "לא ניתן היה ליצור QR קוד. נסה שוב מאוחר יותר."
→ בדוק מה הקריאה המדויקת ל־API ומה חוזר ב־Network tab.

B2. תיקון צד שרת
	1.	ודא ש־BAILEYS service:
	•	מאזין ל־port שהוגדר (3300).
	•	healthcheck עובד (/health).
	•	endpoints ל־QR מחזירים JSON עקבי.
	2.	ב־backend:
	•	endpoints ל־QR צריכים:
	•	לקרוא ל־BAILEYS דרך BAILEYS_BASE_URL.
	•	להעביר INTERNAL_SECRET אם יש אימות.
	•	להחזיר ל־frontend:
	•	במצב הצלחה: { success: true, qr: "<base64 / data or text>" }
	•	במצב חיבור קיים: { success: true, alreadyLinked: true }
	•	בשגיאה: { success: false, error: "..." } עם לוג ברור בשרת.

B3. תיקון צד Client (React)
	1.	במסך Baileys:
	•	אם ה־API מחזיר success: false – הצג את ה־error המלא (ב־console ולמשתמש הודעה ברורה).
	•	אם success: true ו־qr – הצג QR (ספריית QR קיימת או חדשה).
	2.	לבדוק במובייל ובדסקטופ.

B4. Acceptance
	•	לחיצה על “חיבור Baileys” → מתקבל QR → סריקה בוואטסאפ עובדת → הסטטוס מתעדכן ל”מחובר” ולא נחסם בשגיאה כללית.

⸻

C. CRM / UI – מחיקות והרשאות

C1. מחיקת ליד מהטלפון (מובייל)
	1.	בממשק ה־CRM, כרגע:
	•	בדסקטופ יש כפתור למחיקת ליד.
	•	במובייל אין אפשרות למחיקה (כנראה כרטיס/Modal בלי אקשן).
	2.	בצד frontend:
	•	אתר את קומפוננטת רשימת הלידים (טבלה + כרטיסים למובייל).
	•	ודא שכל מקום שבו לידים מוצגים כולל:
	•	כפתור “מחיקה” (אייקון פח אשפה).
	•	Modal אישור (“אתה בטוח שאתה רוצה למחוק את הליד?”).
	•	השתמש באותו endpoint כמו בדסקטופ:
	•	DELETE /api/leads/<id> או מה שקיים בפועל.
	3.	ודא שהדבר עובד גם ב־RTL, גם במסכים קטנים.

C2. מחיקת משתמשים (System Admin + Business Owner)
	1.	בצד backend:
	•	ודא שקיים מודל Users עם דגל is_active או deleted_at.
אם אין – עדיף soft delete:
	•	שדה deleted_at או is_active.
	•	צור/עדכן endpoints:
	•	System admin:
	•	DELETE /api/admin/users/<user_id> – יכול למחוק כל משתמש.
	•	Business owner:
	•	endpoint מותאם, לדוגמה: DELETE /api/businesses/<business_id>/users/<user_id>
	•	יוכל למחוק רק משתמשים באותו עסק ובדרגה נמוכה ממנו (לא בעלי מערכת).
	2.	בצד frontend:
	•	במסך “מנהל מערכת” – טבלת משתמשים:
	•	כפתור מחיקה לכל משתמש.
	•	Modal אישור.
	•	במסך “בעל עסק” → “משתמשי העסק”:
	•	אותו הדבר, אבל עם הפילטרים לפי הרשאות.
	3.	ודא שהמשתמש המחוק:
	•	לא יכול להתחבר.
	•	לא מופיע בטבלאות ברירת מחדל.
	•	נשמר לצורכי לוגים (אם זה soft delete).

C3. Acceptance
	•	במובייל אפשר למחוק ליד.
	•	System admin יכול למחוק/להשבית משתמשים.
	•	Business owner יכול להסיר משתמשים מהעסק שלו.
	•	אין שגיאות 4xx/5xx בקונסול אחרי פעולה.

⸻

D. Production & Deployment – ליישר קו בין Replit ל־Contabo
	1.	ודא שהקונפיגורציה ב־repo זהה למה שרץ עכשיו ב־Contabo:
	•	docker-compose.yml
	•	docker/nginx.conf
	•	server/twilio_security.py
	•	קבצי Twilio routes.
	•	קונפיגורציית Baileys.
	2.	הגדר .env.production או קובץ env מתאים שנקרא ע”י Docker:
	•	DATABASE_URL (NeonDB – כפי שהוגדר כבר)
	•	TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER
	•	BAILEYS_BASE_URL, INTERNAL_SECRET
	•	OPENAI_API_KEY, GCP וכו’.
	3.	כתוב README קצר ב־root של הפרויקט עם הוראות Production:

# Deploy to Contabo
git pull
docker compose up -d --build

# לוגים:
docker logs -f prosaas-backend
docker logs -f prosaas-frontend
docker logs -f prosaas-baileys
docker logs -f prosaas-db

	4.	בסוף:
	•	להריץ טסטים (אם קיימים).
	•	לוודא ש־https://prosaas.pro נטען.
	•	לוודא שיחה מטלפון מגיעה, נענית, ונרשמת כראוי במערכת.
	•	לוודא ש־Baileys עובד.

Commit & Push

לבסוף, בצע:

git status
git add .
git commit -m "Fix Twilio webhooks, Baileys QR, CRM deletes & production config"
git push


⸻

✅ Acceptance סופי מבחינתי

כשאתה (הלקוח) בודק:
	1.	נכנס ל־https://prosaas.pro – הכל נטען.
	2.	שיחה למספר Twilio:
	•	השיחה נענית.
	•	אין 405/403 ב־Twilio logs.
	3.	ב־WhatsApp:
	•	בחירת ספק Baileys → קבלת QR → סריקה → סטטוס “מחובר”.
	4.	ב־CRM:
	•	מהטלפון: אפשר למחוק ליד.
	•	כמנהל מערכת: אפשר למחוק משתמש.
	•	כבעל עסק: אפשר להסיר משתמשי עסק.

⸻

פשוט תעתיק את כל ההנחיה הזו לסוכן של Replit.
אם אחרי שהוא יסיים משהו עדיין לא יעבוד – תשלח לי צילום מסך/לוגים ספציפיים ואכוון אותך נקודתית בלי שתצטרך לגעת ב־709 שורות.