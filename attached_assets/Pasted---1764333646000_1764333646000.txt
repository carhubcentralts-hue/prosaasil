הפעם אני איתך לגמרי – ועובד רק עם מה שנתת עכשיו, בלי להמציא כלום.
יש לנו תמונת מצב מאוד ברורה מהבדיקות:
	•	השרת שלך ב־Contabo: 213.199.43.223
	•	curl ifconfig.me → ‎2a02:c207:2293:819::1 ✅ (Contabo שלך)
	•	nslookup prosaas.pro → כתובות Cloudflare (188.114.97.x, 2a06:98c1:...) ✅
	•	curl -v https://prosaas.pro/health →
HTTP/2 200, server: cloudflare, גוף: ok ✅
כלומר: Cloudflare כן מעביר ל־origin שלך, וה־/health של nginx עובד מהאינטרנט.
	•	curl -v http://127.0.0.1/health →
HTTP/1.1 200 OK, Server: nginx/1.29.3, גוף: ok ✅
זה בדיוק ה־nginx.conf ששלחת.

מסקנה:
✅ DNS + Cloudflare + ניתוב בסיסי לאוריג׳ן עובדים.
הבעיה של 405 + שיחות שלא נענות + DB היא עכשיו בקוד / Docker / routes, לא ב־DNS.

כמו שביקשת – אני נותן לך עכשיו הנחיה מושלמת ל־Agent 3 בריפליט, שתדביק לו כמו שהיא, כדי שיתקן את כל זה צעד־אחר־צעד.

⸻

הנחיה ל-Agent 3 (Replit) – לתקן את פרויקט ProSaaS על Contabo

תעתיק /י אחד־לאחד:

⸻

You are an expert DevOps + Backend engineer working on my project ProSaaS / AgentLocator, currently deployed on a Contabo VPS with Docker and Nginx, behind Cloudflare.
Your job is to make the external server behave EXACTLY like the working Replit environment: Twilio calls must be answered, the Flask backend must be reachable, and the PostgreSQL DB must be connected.
Follow the steps below EXACTLY, don’t skip validations, and show all code changes as unified diffs.

⸻

0. PROJECT & CONTEXT
	•	The production server is: 213.199.43.223
	•	The public domain (behind Cloudflare proxy) is: https://prosaas.pro
	•	The project on this repo is built with Docker Compose:
	•	prosaasil-frontend – Nginx + React SPA, exposes port 80
	•	prosaasil-backend – Flask backend (API + webhooks + Twilio + Realtime API)
	•	prosaasil-db – PostgreSQL
	•	prosaasil-baileys, prosaasil-n8n – additional services
	•	The health endpoint is already working and returning ok:
	•	curl -v http://127.0.0.1/health (inside the server) → 200 ok
	•	curl -v https://prosaas.pro/health (via Cloudflare) → 200 ok

Important: Do NOT change DNS or Cloudflare. We already know they work.
Your job is to fix the backend routing, Twilio webhooks and DB connectivity.

⸻

1. VERIFY THAT NGINX IN DOCKER IS THE ONE SERVING THE DOMAIN
	1.	Open the file: docker/nginx.conf
Confirm it matches this structure (I already have it, just verify):
	•	listen 80;
	•	location /health { return 200 'ok'; ... }
	•	location /api { proxy_pass http://backend:5000; ... }
	•	location /webhook { proxy_pass http://backend:5000; ... }
	•	location /ws/ { proxy_pass http://backend:5000; ... }
	•	location / { try_files $uri $uri/ /index.html; }
	2.	Make sure the Dockerfile for the frontend image actually copies this nginx.conf to /etc/nginx/conf.d/default.conf (or equivalent).
	•	If it doesn’t – FIX it so the container uses THIS config.
	•	Show the Dockerfile and the diff.
	3.	In docker-compose.yml, verify that:
	•	The frontend service is named something like prosaasil-frontend
	•	It maps 80:80
	•	It uses the image that includes the nginx.conf above.

⸻

2. FIX & VALIDATE THE TWILIO WEBHOOK ROUTE IN FLASK

We currently have Twilio failing with HTTP 405 on https://prosaas.pro/webhook/incoming-call.
We already validated that method is POST on Twilio.
So the problem is almost certainly in the Flask routes or blueprint registration.

Your task:
	1.	Locate the Twilio webhook code in the backend. Typical locations to search:
	•	app/routes/twilio_routes.py
	•	server/routes/twilio.py
	•	Any file with “twilio” or “webhook” in its name.
	2.	Confirm how the blueprint is defined and registered. Something like:

twilio_bp = Blueprint("twilio_bp", __name__, url_prefix="/webhook")

@twilio_bp.route("/incoming-call", methods=["POST"])
def incoming_call():
    ...


	3.	Make SURE that:
	•	The blueprint twilio_bp is registered in create_app() or the main Flask app factory:

app.register_blueprint(twilio_bp)


	•	The route path exactly matches what Twilio calls:
	•	If Twilio URL is /webhook/incoming-call → route must be /incoming-call
	•	If route is /incoming_call with underscore → EITHER change the route OR change Twilio URL to match.
	•	The allowed methods explicitly include "POST":

@twilio_bp.route("/incoming-call", methods=["POST"])


	4.	Add a temporary DEBUG route to be 100% sure the backend sees POST on /webhook prefix:

@twilio_bp.route("/debug-method", methods=["GET", "POST"])
def debug_method():
    from flask import request, current_app
    current_app.logger.info(f"[TWILIO DEBUG] method={request.method}, path={request.path}")
    return f"method={request.method}, path={request.path}", 200


	5.	Rebuild the backend & frontend images and restart Docker Compose (show the exact commands in the answer).
	6.	After rebuild, simulate Twilio from the backend container:

docker compose exec prosaasil-backend curl -v -X POST http://backend:5000/webhook/incoming-call
docker compose exec prosaasil-backend curl -v -X POST http://backend:5000/webhook/debug-method

	•	If you still see 405 – show the Flask route map (next step).
	•	If you see 200 and the response string – routing is OK.

	7.	Print the Flask URL map to verify all webhook routes and methods:

docker compose exec prosaasil-backend python - << 'EOF'
from app import create_app
app = create_app()
for rule in app.url_map.iter_rules():
    if "webhook" in str(rule):
        print(rule, "→ methods:", rule.methods)
EOF

	•	Paste the output in the explanation so I can see EXACTLY which paths and methods are configured.
	•	If any webhook route has only {'GET', 'HEAD', 'OPTIONS'} – fix it to allow POST.

	8.	Only after all the above passes locally, document clearly:
	•	“Twilio webhook for incoming calls should be exactly:
https://prosaas.pro/webhook/incoming-call with HTTP POST”
So I can verify in Twilio console.

⸻

3. VERIFY THAT THE BACKEND IS ACTUALLY REACHABLE VIA /webhook FROM OUTSIDE
	1.	From inside the backend container:

docker compose exec prosaasil-backend curl -v http://backend:5000/health
docker compose exec prosaasil-backend curl -v http://backend:5000/webhook/incoming-call

	•	Confirm 200 or at least 500 (Flask hit), NOT 404/405.

	2.	From HOST (Contabo, NOT inside container):

curl -v http://127.0.0.1/webhook/incoming-call

	•	This should go: Nginx → backend:5000 → Flask route.
	•	If this returns 405, show exactly the response headers so we know who sends it (Nginx vs Flask).

	3.	From OUTSIDE (simulated by me later) we should then expect:

curl -v https://prosaas.pro/webhook/incoming-call

	•	to reach the same backend route via Cloudflare.

Make sure your changes guarantee this chain is working end-to-end.

⸻

4. FIX & VALIDATE DATABASE CONNECTIVITY IN BACKEND

Currently, on the external server, the backend does not see the database correctly.

Your tasks:
	1.	In docker-compose.yml, find the backend service (prosaasil-backend):
	•	Verify there is an environment variable like DATABASE_URL or individual POSTGRES_... variables.
	•	Make sure these values are identical (host/user/db/ssl params) to what works on Replit, except for the host if using internal Docker DB.
	2.	Inside the backend container, print the env:

docker compose exec prosaasil-backend env | grep -Ei 'DATABASE|POSTGRES'

	•	Confirm DATABASE_URL is present and not empty.

	3.	Test direct DB connectivity from inside the backend container:
	•	If using a URL:

docker compose exec prosaasil-backend bash -c 'apt-get update && apt-get install -y postgresql-client || true'
docker compose exec prosaasil-backend bash -c 'psql "$DATABASE_URL" -c "\dt"'


	•	If using host/user/pass variables, build the connection string on the fly and test.

	4.	If the DB is external (Neon/Supabase/etc.) and requires SSL:
	•	Make sure the URL has ?sslmode=require or the proper SSL parameters, just like it did on Replit.
	•	If there is an IP allowlist, ensure Contabo’s IP is allowed.
	5.	If the DB is the internal Docker prosaasil-db service:
	•	Host should be the service name (e.g. db or prosaasil-db, NOT localhost).
	•	Port should be 5432 inside the Docker network, not 127.0.0.1 of the host.
	•	Show the prosaasil-db section in docker-compose.yml and how the backend connects to it.
	6.	After fixing connection details, restart Docker Compose and check backend logs:

docker compose logs prosaasil-backend | tail -n 100

	•	Verify there are no “could not connect to server” / “connection refused” errors from SQLAlchemy/psycopg.

⸻

5. ACCEPTANCE CHECKLIST – WHAT MUST WORK WHEN YOU ARE DONE

When you finish, you MUST confirm all of the following and explain in your answer:
	1.	curl -v http://127.0.0.1/health on the server → 200 ok (already passes)
	2.	curl -v http://127.0.0.1/webhook/incoming-call on the server:
	•	Reaches Flask route (returns valid TwiML or at least 200/500 from Flask, not 404/405)
	3.	curl -v https://prosaas.pro/webhook/incoming-call from anywhere on the internet:
	•	Reaches the SAME backend route via Cloudflare → same status code as (2)
	4.	Inside backend container:
	•	psql "$DATABASE_URL" -c "\dt" shows the expected tables (or at least connects without error)
	5.	Twilio incoming call webhook:
	•	Configured to https://prosaas.pro/webhook/incoming-call with HTTP POST
	•	Call logs show 2xx or 5xx from origin, NOT 405

For every change you make, show:
	•	The file path
	•	A unified diff (diff / patch style)
	•	A one-line explanation in English what the change fixes.

Don’t touch the Realtime logic or business logic – only infra, routing, and DB connectivity needed to make the external server behave like the working Replit environment.

⸻

End of instructions. Follow them exactly.

⸻

אם תרצה, אחרי שהסוכן יריץ את זה ויחזיר תשובה – תוכל להדביק לי פה את הסיכום / הדיפים שהוא עשה, ואני אעבור עליהם ואגיד לך אם הכל באמת מחובר כמו שצריך או שעדיין חסר משהו.