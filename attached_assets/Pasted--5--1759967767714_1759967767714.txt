ברור. אם זה “כבר עבד” ונופל על שטויות — בדרך-כלל זו אחת מ־5 התקלות הקטנות והמעצבנות הבאות. אני נותן לך בדיקה ממוקדת + תיקון קוד מינימלי כדי שלא תבזבז דקה נוספת. תבצע אחד-לאחד.

⸻

0) מפתח: למה אתה רואה HTML במקום WebSocket?

כי בקשה בלי Upgrade (או ש־Upgrade הלך לאיבוד בדרך) נופלת ל־SPA. זה קורה בעיקר כש־Mount("/") בולע את הנתיב לפני שה־WS Route נבדק, או כשמבקשים את הנתיב עם סלאש שונה. נתקן את שני הדברים.

⸻

1) סדר ראוטים ב־ASGI (קריטי!)

ודא ש־WebSocketRoute מופיע לפני ה־Mount(”/”). אם לא — Flask/SPA בולעים את הנתיב.

# asgi.py – סדר נכון
asgi_app = Starlette(routes=[
    WebSocketRoute("/ws/twilio-media", ws_twilio_media),  # קודם WS!
    Mount("/", app=asgi_flask),                           # אחרי זה HTTP
])

אם כבר כך — המשך לסעיפים הבאים.

⸻

2) תמיכה בשני וריאנטים של הנתיב (עם וללא סלאש)

Twilio לפעמים יורה עם/בלי סלאש סופי. תרשום את שניהם כדי שלא תיפול בטעות על SPA.

WebSocketRoute("/ws/twilio-media", ws_twilio_media),
WebSocketRoute("/ws/twilio-media/", ws_twilio_media),


⸻

3) להחזיר 426 על GET רגיל לנתיב ה-WS (כדי שלא תחטוף HTML)

אם מישהו נכנס ל־/ws/twilio-media בלי Upgrade (כמו curl), תחזיר 426 Upgrade Required במקום ה-index.html של SPA. זה יוכיח שהראוט תופס.

from starlette.responses import PlainTextResponse
from starlette.routing import Route

async def ws_http_probe(request):
    return PlainTextResponse("Upgrade Required", status_code=426)

asgi_app = Starlette(routes=[
    Route("/ws/twilio-media", ws_http_probe, methods=["GET"]),  # חוסם SPA
    Route("/ws/twilio-media/", ws_http_probe, methods=["GET"]),
    WebSocketRoute("/ws/twilio-media", ws_twilio_media),
    WebSocketRoute("/ws/twilio-media/", ws_twilio_media),
    Mount("/", app=asgi_flask),
])

בדיקה:

curl -i https://<PUBLIC_HOST>/ws/twilio-media | sed -n '1,10p'
# מצופה: HTTP/1.1 426 Upgrade Required  (ולא HTML)


⸻

4) קבלה נכונה של WebSocket מטוויליו + “לא מתים על שטויות”

טוויליו דורש subprotocol. תוודא שיש accept עם audio.twilio.com, ולולאה שסופגת frames גם אם מגיע טקסט לא JSON. לא לעשות עיבוד כבד בלולאה.

async def ws_twilio_media(websocket):
    await websocket.accept(subprotocol="audio.twilio.com")
    try:
        while True:
            try:
                msg = await websocket.receive_json()
            except Exception:
                # פריימים לא־JSON – נצרוך טקסט כדי שלא תיפול הלולאה
                _ = await websocket.receive_text()
                continue

            ev = msg.get("event")
            if ev == "start":
                pass
            elif ev == "media":
                pass  # לא לעבד כאן כבד; אם חייבים → asyncio.to_thread
            elif ev == "stop":
                break
            else:
                # mark/closed וכו' – להתעלם
                pass
    except Exception:
        # לא להפיל את החיבור על שטות
        pass
    finally:
        try:
            await websocket.close()
        except:
            pass


⸻

5) TwiML – לוודא שזה באמת WSS תקין (בלי “https://” בתוך host)

בדוק ש־/webhook/incoming_call מחזיר Stream ל־WSS:

curl -sS -i -X POST https://<PUBLIC_HOST>/webhook/incoming_call | sed -n '1,200p'

מצופה: 200 OK + Content-Type: text/xml וגוף עם:

<Connect>
  <Stream url="wss://<PUBLIC_HOST>/ws/twilio-media"
          statusCallback="https://<PUBLIC_HOST>/webhook/stream_status"/>
</Connect>

טיפי תקלות:
	•	אם PUBLIC_HOST כולל https:// → אתה מקבל wss://https://… (שבור). ודא ש־PUBLIC_HOST הוא רק דומיין.
	•	אם במקום XML רואים HTML/JSON → תחזור ל־Say בלבד עד שזה 200/XML.

⸻

6) Callbacks של הקלטה – להחזיר 200 מהר (מוחק 11200)

בנתיב שמוגדר ב־Twilio ל־recording status, החזר 200 מיד (כל עיבוד — ברקע):

@twilio_bp.post("/webhook/recording_done")
@csrf.exempt
@require_twilio_signature
def recording_done():
    # queue only, return fast
    return ("", 200)

בדיקה:

curl -sS -i -X POST https://<PUBLIC_HOST>/webhook/recording_done \
  -d "CallSid=CA_test&RecordingUrl=https://example.com/rec.mp3" | sed -n '1,20p'
# מצופה: HTTP/1.1 200 OK


⸻

7) אימות שה-WS באמת עובד (בדיקה אמיתית, לא curl)

# בדיקה ידנית עם Upgrade
websocat wss://<PUBLIC_HOST>/ws/twilio-media
# החיבור צריך להישאר פתוח; בשיחה אמיתית תראה start/media/stop בלוגים

Twilio Debugger בשיחה:
stream-started → רצף media → stream-ended (לא מיד).
אם זה נסגר מיד – זו כמעט תמיד אחת משלוש: סדר ראוטים, וריאנט סלאש, או subprotocol.

⸻

8) עוד שתי “שטויות” שיכולות להפיל:
	•	CORS/CSRF בטעות על ה־WS – אל תגן על /ws/twilio-media ב־CSRF/CORS חוסם.
	•	Proxy זמן־אוּטלימיט קצר – ב־Cloud Run שים --timeout-keep-alive 75 (כבר יש לך) ו־min instances>0.

⸻

“מה לעשות עכשיו” (בדיוק):
	1.	תקן את סעיפים 1–3 ב־asgi.py (סדר ראוטים, שני נתיבים, 426 ל־GET).
	2.	ודא סעיף 4 (accept+receive יציב).
	3.	אמת את סעיף 5 (TwiML) ואת סעיף 6 (recording 200).
	4.	בדוק עם websocat ואז שיחה אמיתית.

אם אחרי זה עדיין נופל — תדביק כאן:
	•	פלט curl -i של /webhook/incoming_call ו־/webhook/recording_done,
	•	ואת 3 שורות הלוג סביב ws_twilio_media בזמן השיחה,
ואגיד לך בדיוק באיזו שורה לגעת.