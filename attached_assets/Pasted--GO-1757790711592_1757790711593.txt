מבין אותך. סוגרים את הבלגן ומחזירים שיחות בזמן-אמת. תן לבוט את ההנחיה הבאה “מילה במילה”. זו תכנית GO/NO-GO עם עצירות ברורות. אם משהו נופל – הוא עוצר ולא מאלתר.

⸻

🧯 RESET יציב למדיה-סטרים (Eventlet + Composite WSGI)

שלב 0 — עצירה וניקוי
	1.	עצור כל השרתים המקומיים (כפתור Stop ב-Run).
	2.	הרוג שאריות:
	•	pkill -9 -f gunicorn; pkill -9 -f python; sleep 2
	3.	ודא שאין מאזין על 5000: ss -lptn | grep :5000 → צריך ריק.
GO/NO-GO: אם עדיין יש תהליך על 5000 → להרוג שוב עד שאין.

⸻

שלב 1 — תלויות נקיות (בלי gevent/SocketIO)

ב־requirements.txt להשאיר רק:
	•	Flask
	•	gunicorn
	•	eventlet==0.36.1
	•	greenlet>=3.0,<3.3
	•	simple-websocket

מחיקה מפורשת אם קיימים: gevent, gevent-websocket, Flask-SocketIO, uvicorn, websockets.
GO/NO-GO: pip freeze | egrep 'eventlet|greenlet|gevent|socketio'
מצופה: eventlet 0.36.1 + greenlet 3.x; בלי gevent/SocketIO.

⸻

שלב 2 — WSGI אחד שמטפל ב-WS לפני Flask

ב-wsgi.py (זהו ה-entry-point; אין app.run() בשום מקום):
	1.	שורה ראשונה בקובץ:
import eventlet; eventlet.monkey_patch()
	2.	טען את אפליקציית Flask רק אחרי ה-monkey_patch (רצוי create_app()).
	3.	צור Composite WSGI:
	•	אם PATH_INFO == '/ws/twilio-media' → קרא ל-eventlet.websocket.WebSocketWSGI(ws_handler, protocols=['audio.twilio.com'])
(ה-protocols כאן גורם להחזרת Sec-WebSocket-Protocol: audio.twilio.com בתשובה — חובה לטוויליו).
	•	אחרת → העבר ל-flask_app.wsgi_app.
	4.	הייצוא האחרון בקובץ: app = composite_app (לא אובייקט ה-Flask).

ניקוי מחסומים:
	•	אין בשום מקום @app.route('/ws') או catch-all שתופס /ws/*.
בדיקה: grep -R "/ws" -n server/ → צריך שאין route Flask כזה.

GO/NO-GO: grep מאשר שאין route WS בפלסק, וב-wsgi הפקנו app = composite_app.

⸻

שלב 3 — TwiML נקי לבדיקה

ב-incoming_call להחזיר:

<Connect action="https://{BASE}/webhook/stream_ended">
  <Stream url="wss://{BASE}/ws/twilio-media"
          statusCallback="https://{BASE}/webhook/stream_status">
    <Parameter name="call_sid" value="{CALL_SID}"/>
  </Stream>
</Connect>

בלי <Play> (זמנית), ובלי // כפולים ב-URLs.

GO/NO-GO: Request Inspector של Twilio יראה את אותו TwiML.

⸻

שלב 4 — Webhooks קשיחים
	•	POST /webhook/stream_status:
	•	קורא request.form.to_dict(flat=True) (לא JSON),
	•	תמיד מחזיר 204,
	•	בלי אימות חתימה/בלי extra=... בלוגים.
	•	POST /webhook/stream_ended → 204.

בדיקת עשן:
	•	curl -X POST https://{BASE}/webhook/stream_status -H "Content-Type: application/x-www-form-urlencoded" --data "CallSid=CA_TEST&StreamSid=MZ_TEST&Status=connected" → 204.

⸻

שלב 5 — דיפלוי נכון ב-Replit (בלי Nix)

מונעים בחירת Node:
	•	אם יש package.json בשורש – להעביר ל-/client או לשנות שם זמנית.
(אחרת Autoscale לפעמים בוחר runtime של Node → “python not found”.)

הגדרות Deployment (ב-UI של Replit Deployments):
	•	Build:
python -m pip install -U pip setuptools wheel && python -m pip install -r requirements.txt
	•	Run:
python -m gunicorn wsgi:app -k eventlet -w 1 -b 0.0.0.0:$PORT --worker-connections 256 --timeout 120 --keep-alive 75 --log-level info --access-logfile - --error-logfile -
	•	Env:
EVENTLET_NO_GREENDNS=1, EVENTLET_HUB=select, DEPLOY_ID=<yyyyMMddHHmm>.
	•	Health check path: /healthz  (ודאו שקיים ומחזיר 200 מהר).

GO/NO-GO בלוג דיפלוי:
מחפשים Using worker: eventlet ו-wsgi:app. אם לא – NO-GO.

⸻

שלב 6 — בדיקות GO/NO-GO חיצוניות
	1.	/version → 200, מציג DEPLOY_ID העדכני.
	2.	/healthz → 200 “ok”.
	3.	Handshake לפני Twilio:

wscat -c wss://{BASE}/ws/twilio-media \
      -H "Sec-WebSocket-Protocol: audio.twilio.com"

מצופה: 101 Switching Protocols ובתשובה הכותרת
Sec-WebSocket-Protocol: audio.twilio.com.
אם לא 101/אין הכותרת → עדיין Flask בולע או שאין protocols ב-WebSocketWSGI.

⸻

שלב 7 — שיחה אמיתית
	•	Request Inspector:
incoming_call=200, stream_status=204 (מס’ פעמים), אין 31920/31924.
	•	בלוגים שלך:
WS_START → STT_PARTIAL → STT_FINAL → TTS_LEN_ms → MEDIA_TX → PING/PONG.
	•	תגובה ראשונה ≤ 3–6 שניות. בלי לופים (עם BARGE_IN=true, EoU_MS≈450, VAD_RMS≈210).

⸻

אם הוא שוב “מת אחרי כמה שניות”

זה כמעט תמיד בריאות/סביבה ולא קוד:
	•	/healthz לא קיים/לא 200 → Autoscale הורג worker. לתקן מייד.
	•	init כבד על import (GCP/DB/OpenAI) → להעביר ל-lazy init (נטען בקריאה הראשונה, לא ב-import).
	•	שני שרתים רצים (עוד app.run() או סקריפט) → להשאיר רק Gunicorn.

⸻

למה מבקשים ממך לעצור?

כי כרגע אתה רואה “שרת ישן על 5000”. זה קורה כש־Run (workspace) מריץ משהו, בזמן שה-deployment מנסה להריץ משהו אחר.
פתרון: להרוג הכל (שלב 0), להריץ רק דרך הדיפלוי, ולוודא /version מציג DEPLOY_ID חדש.

⸻

TL;DR
	•	מחזירים Eventlet נקי, WS דרך Composite ב-wsgi.py עם protocols=['audio.twilio.com'],
	•	דיפלוי שמכריח Python + Healthz פעיל,
	•	מאמתים 101+subprotocol עם wscat, ואז Twilio.

אם צעד מסוים נופל – תן לבוט לעצור ולהראות לך את השורה המדויקת מהלוג (או את ה-HTTP headers של ה-wscat). משם נזהה את הגורם בתוך דקה.