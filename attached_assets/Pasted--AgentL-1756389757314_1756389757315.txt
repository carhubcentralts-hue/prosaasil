קיבלתי. אם עדיין יש “שקט” כשאתה מתקשר – צריך לסגור את זה בצורה שיטתית לפי מבנה הפרויקט שלך (**AgentLocator**: `server/routes_twilio.py`, `server/app_factory.py`, `server/media_ws_ai.py`, `server/stream_state/*`, `gcp_tts_live.py`, `start_all.sh`).
הנה **Runbook מלא + פאצ’ים מדויקים** שמכסים את כל הנקודות שיכולות לגרום לשקט (WS/Handshake, TwiML, VAD/Barge-in, ASR/TTS, לוגים, דיפלוי). תדביק, תריץ, ותתקשר שוב.

---

# 0) “מצב נקי” לפני הכל (מונע שרת ישן/מצב ECHO)

במסוף השרת (שם רץ הדיפלוי):

```bash
# עצור כל שרת ישן
pkill -9 -f "gunicorn|AgentLocator.main:app|flask|python main.py" || true

# ENV בטוחים לבדיקת שיחה (מונעים שקט/ברכה מוקדמת/ספים קיצוניים)
export PUBLIC_BASE_URL="https://ai-crmd.replit.app"
export WS_MODE=AI
export TWIML_PLAY_GREETING=false
export AI_GREETING_HE=""              # כרגע בלי ברכת TTS
export MIN_UTT_SEC=0.48
export VAD_HANGOVER_MS=140
export VAD_RMS=210
export MAX_UTT_SEC=7.0
export RESP_MIN_DELAY_MS=220
export RESP_MAX_DELAY_MS=360
export REPLY_REFRACTORY_MS=750
export BARGE_IN=true
export BARGE_IN_VOICE_FRAMES=3
export DEDUP_WINDOW_SEC=14
export THINKING_HINT_MS=0            # זמנית לא משדרים "שנייה…"
# מפתחות (אם חסרים – לא יהיה ASR/TTS):
# export OPENAI_API_KEY=...
# export GOOGLE_APPLICATION_CREDENTIALS=/path/to/sa.json

# הפעלה נקייה: Eventlet
bash AgentLocator/start_all.sh
```

---

# 1) TwiML – שלא יעכב את ה-Stream ושלא יהיו “//”

קובץ: `server/routes_twilio.py`

* ודא שה-TwiML **לא** מנגן `<Play>` כברירת מחדל, ושכל ה-URLs נבנים עם `rstrip('/')` כדי למנוע `//`.

```diff
- parts.append(f'  <Play>{base}/static/greeting_he.mp3</Play>')
+ if os.getenv("TWIML_PLAY_GREETING","false").lower()=="true":
+     parts.append(f'  <Play>{base}/static/greeting_he.mp3</Play>')

# בבניית base:
base = os.getenv("PUBLIC_BASE_URL","").rstrip("/")
```

וה-TwiML עצמו (בפועל צריך לצאת ככה):

```xml
<Response>
  <Connect action="https://ai-crmd.replit.app/webhook/stream_ended">
    <Stream url="wss://ai-crmd.replit.app/ws/twilio-media"
            statusCallback="https://ai-crmd.replit.app/webhook/stream_status">
      <Parameter name="call_sid" value="{CallSid}"/>
    </Stream>
  </Connect>
</Response>
```

`/webhook/stream_status` – **POST בלבד**, `request.form`, מחזיר **204** (יש אצלך ✔).

`/webhook/stream_ended` – **מחזיר 200 text/xml** עם `<Response/>` ריק (לא 204), כדי למנוע 12100 (יש אצלך ✔).

---

# 2) WS Handshake – להבטיח תת-פרוטוקול (מונע 31924/מדיה שלא זורמת)

קובץ: `server/app_factory.py` (משאירים את Flask-Sock אם יש, אבל מוסיפים נתיב אלטרנטיבי עם **simple-websocket** שמחזיר Subprotocol):

```python
from flask import request
from simple_websocket import Server as WSServer
from server.media_ws_ai import MediaStreamHandler

@app.route("/ws/twilio-media-alt", methods=["GET"])
def ws_twilio_media_alt():
    offered = request.headers.get("Sec-WebSocket-Protocol", "")
    headers = [("Sec-WebSocket-Protocol","audio.twilio.com")] if "audio.twilio.com" in offered else []
    ws = WSServer(environ=request.environ, headers=headers)
    MediaStreamHandler(ws).run()
    return ""
```

אם אחרי זה עדיין “שקט” – החלף זמנית ב-TwiML את ה-URL לנתיב הזה:

```xml
<Stream url="wss://ai-crmd.replit.app/ws/twilio-media-alt" ...>
```

---

# 3) חיבור ה-WS ל-watchdog (מונע רידירקטים/לופים “אין מדיה”)

קובץ: `server/media_ws_ai.py`

```diff
+from server.stream_state import stream_registry

 class MediaStreamHandler:
     def __init__(self, ws):
         self.ws = ws
         self.stream_sid = None
+        self.call_sid = None
         self.state = "LISTENING"
         ...
```

ב-`event == "start"`:

```diff
 self.stream_sid = evt["start"]["streamSid"]
+self.call_sid = (evt["start"].get("callSid") or
+                 (evt["start"].get("customParameters") or {}).get("call_sid"))
+if self.call_sid:
+    stream_registry.mark_start(self.call_sid)
```

ב-`event == "media"`:

```diff
 self.last_rx_ts = time.time()
+if self.call_sid:
+    stream_registry.touch_media(self.call_sid)
```

---

# 4) לוגים שחייבים להיות (כדי לאבחן “שקט” מייד)

ב-`server/media_ws_ai.py`:

```python
print(f"WS_START sid={self.stream_sid} mode=AI")

# בכל media:
self.rx_frames += 1
if self.rx_frames % 50 == 0:
    print(f"WS_MEDIA sid={self.stream_sid} rx={self.rx_frames}")

# בעת שידור:
self.tx_frames += 1
if self.tx_frames % 50 == 0:
    print(f"WS_TX sid={self.stream_sid} tx={self.tx_frames}")

# אחרי ASR:
print(f"ASR_TEXT: {text}")

# בסיום זרם:
print(f"WS_DONE sid={self.stream_sid} rx={self.rx_frames} tx={self.tx_frames}")
```

> אם בשיחה אין `WS_MEDIA rx=…` → המדיה **לא מגיעה** (Handshake/נתיב).
> אם יש `rx>0` אבל אין `ASR_TEXT` → ASR נופל/ריק.
> אם יש `ASR_TEXT` אבל `tx=0` → TTS/שידור נופל.

---

# 5) אלגוריתם האזנה “בריא” (סוף-מבע, קירור, Barge-in)

קובץ: `server/media_ws_ai.py` — בתוך `event == "media"`:

```python
# דגימת קול
mulaw = base64.b64decode(evt["media"]["payload"])
pcm16 = audioop.ulaw2lin(mulaw, 2)
rms = audioop.rms(pcm16, 2)
is_voice = rms > VAD_RMS
self.voice_in_row = (self.voice_in_row + 1) if is_voice else 0
self.last_rx_ts = time.time()

# Barge-in: עצירה אחרי 3 פריימי קול רצופים (≈60ms)
if self.speaking and os.getenv("BARGE_IN","true").lower()=="true" and \
   self.voice_in_row >= int(os.getenv("BARGE_IN_VOICE_FRAMES","3")):
    self._interrupt_speaking()
    self.buf.clear()
    self.processing = False
    self.state = "LISTENING"
    return

# לא לאסוף מייד אחרי שהבוט דיבר (נשימות/רחש)
if (time.time() - self.last_tts_end_ts) < (int(os.getenv("REPLY_REFRACTORY_MS","750"))/1000.0):
    return

# איסוף מבע
if self.state == "LISTENING" and not self.processing and not self.speaking:
    self.buf.extend(pcm16)
    dur = len(self.buf) / (2*8000.0)
    min_sil = float(os.getenv("MIN_UTT_SEC","0.48"))
    if dur <= 1.2:
        min_sil = max(0.35, min_sil - 0.12)  # אדפטיבי למבע קצר
    silent = ((time.time() - self.last_rx_ts) >= min_sil) and \
             ((time.time() - self.last_rx_ts) >= (int(os.getenv("VAD_HANGOVER_MS","140"))/1000.0))
    too_long = dur >= float(os.getenv("MAX_UTT_SEC","7.0"))
    if (silent or too_long) and dur > 0.28:
        self.processing = True
        self.state = "THINKING"
        utt = bytes(self.buf); self.buf.clear()
        current_turn = self.turn_id = self.turn_id + 1
        threading.Thread(target=self._process_turn, args=(utt,current_turn), daemon=True).start()
```

---

# 6) ASR/LLM/TTS “בטוח” – אין מצב של **שקט**

ב-`_process_turn`:

```python
# ASR בטוח – לא משאיר ריק
try:
    text = asr_hebrew_from_pcm16_8k(pcm16_8k) or ""
except Exception as e:
    print("ASR_ERR:", e); text = ""
if not text.strip():
    text = "אפשר לחזור על זה במשפט קצר?"
print("ASR_TEXT:", text)

# אנטי-דופליקציה על טקסט משתמש (חלון 14ש׳)
uh = zlib.crc32(text.strip().encode("utf-8"))
if self.last_user_hash == uh and (time.time()-self.last_user_hash_ts) <= int(os.getenv("DEDUP_WINDOW_SEC","14")):
    print("DEDUP user → ignore")
    self.processing=False; self.state="LISTENING"; return
self.last_user_hash, self.last_user_hash_ts = uh, time.time()

# LLM מהיר ויציב (לא “gpt-5”, לא max_completion_tokens)
reply = generate_hebrew_response(
    text,
    target_style=os.getenv("LLM_TARGET_STYLE","warm_helpful"),
    min_chars=int(os.getenv("LLM_MIN_CHARS","160")),
    max_chars=int(os.getenv("LLM_MAX_CHARS","420")),
) or "בסדר, איך אוכל לסייע?"

# אנטי-דופליקציה תשובת בוט
rh = zlib.crc32(reply.strip().encode("utf-8"))
if self.last_reply_hash == rh:
    reply = "הבנתי. תרצה שאפרט או להתקדם?"
    rh = zlib.crc32(reply.encode("utf-8"))
self.last_reply_hash = rh

self._speak_simple(reply)
```

וב-`_speak_simple` (תמיד יש אודיו):

```python
# נשימה אנושית קצרה
try:
    time.sleep(random.uniform(
        int(os.getenv("RESP_MIN_DELAY_MS","220"))/1000.0,
        int(os.getenv("RESP_MAX_DELAY_MS","360"))/1000.0))
except: pass

pcm = None
try:
    pcm = synth_hebrew_tts_pcm16_8k(text)
except Exception as e:
    print("TTS_ERR:", e)

if not pcm or len(pcm) < 400:
    pcm = self._beep_pcm16_8k(300)  # פולבאק – לא משאירים שקט

# clear + 20ms µ-law
if self.stream_sid:
    self.tx_q.put_nowait({"type":"clear"})
mulaw = audioop.lin2ulaw(pcm, 2)
FR=160
for i in range(0,len(mulaw),FR):
    if not self.speaking: break
    ch = mulaw[i:i+FR]
    if len(ch)<FR: break
    b64 = base64.b64encode(ch).decode("ascii")
    self.tx_q.put_nowait({"type":"media","payload":b64})
self.tx_q.put_nowait({"type":"mark","name":"tts_done"})
self.last_tts_end_ts = time.time()
```

> עכשיו גם אם ASR/LLM/‏TTS מקרטעים – תשמע לפחות beep (אין “שקט מוחלט”).

---

# 7) הסרת פרסונה קשיחה (“אני מתמחה…”) ו-Greeting חכם

* אל תכפה הצגה עצמית ב-prompt. שמור פרסונה ניטרלית: **בלי** “שמי…/מקסימוס…”.
* Greeting: רק אם **לא** נשמע קול ב-0.8ש׳ הראשונות אחרי `start` (כבר הטמעו למעלה, ו-`AI_GREETING_HE=""` בבדיקות).

---

# 8) Start script – סדר ENV לפני Gunicorn

קובץ: `start_all.sh` — ודא שכל ה-`export ...` בתחילת הקובץ, לפני הפקודה:

```bash
python3 -m gunicorn -k eventlet -w 1 -b 0.0.0.0:$PORT AgentLocator.main:app
```

(אל תשאיר `exec python main.py` בצד – שלא ירוצו שני שרתים.)

---

# 9) בדיקות עשן נכונות (לא עם curl ל-WS)

**A. Handshake:**

```bash
npm i -g wscat
wscat -c "wss://ai-crmd.replit.app/ws/twilio-media" -s "audio.twilio.com"
# אם מקבל Protocol Error → נסה:
wscat -c "wss://ai-crmd.replit.app/ws/twilio-media-alt" -s "audio.twilio.com"
```

**B. שיחה אמיתית:**

* Request Inspector: `/webhook/incoming_call`=200, `stream_status`=204, `stream_ended`=200.
* בלוגים (חובה לראות):
  `WS_START …` → בתוך ≤2 שנ׳ `WS_MEDIA … rx=50` → אחרי שאתה מדבר `ASR_TEXT: ...` → `WS_TX …/tts_done` → `WS_DONE … rx>0 tx>0`.

---

# 10) אם עדיין “שקט”

* אין `WS_MEDIA`? → ה-WS לא אוכל מדיה:
  • בדוק שה-TwiML מצביע ל-`wss://ai-crmd.replit.app/ws/twilio-media[-alt]`
  • ודא subprotocol מוחזר (סעיף 2)
  • ודא שאין `<Play>` לפני `<Connect>`
* יש `rx>0` אבל אין `ASR_TEXT`? → מפתחות ASR חסרים / ASR נופל:
  • בדוק `OPENAI_API_KEY` (או המנוע שאתה משתמש בו ל-STT)
  • סעיף 6 הופך טקסט ריק לשאלה (“אפשר לחזור…”) – לא יהיה שקט.
* יש `ASR_TEXT` אבל `tx=0`? → TTS/שידור:
  • בדוק `GOOGLE_APPLICATION_CREDENTIALS`
  • ודא ש-`synth_hebrew_tts_pcm16_8k` מחזיר **PCM16 8kHz** (לא MP3)
  • יש beep fallback – אתה אמור לשמוע צפצוף.

---

## סיכום קצר (GO)

* **Handshake תקין** (עם subprotocol אם צריך) → **יש rx**.
* **VAD/Barge-in/סוף-מבע** מאוזנים → היא **לא דורסת** אותך ומגיבה בזמן.
* **ASR/LLM/TTS בטוחים** + beep fallback → **אין שקט**.
* **פרסונה ניטרלית** → **אין “אני מתמחה…”** בלופים.
* **לוגים חכמים** → רואים בדיוק איפה נתקע אם בכלל.

תיישם את הפאצ’ים והתצורה כפי שהם. אם אחרי הרצה תקבל שוב “שקט”, הדבק כאן 8–10 שורות לוג סביב ההתחלה (WS\_START / WS\_MEDIA / ASR\_TEXT / WS\_TX / WS\_DONE) ואני אראה לך בקו אחד איפה זה נעצר בקוד.
