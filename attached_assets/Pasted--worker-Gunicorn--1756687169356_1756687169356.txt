הבנתי—זה כבר לא באג בקוד אלא סביבתי: worker של Gunicorn מתחיל, לא מקשיב, ואז מת בלי שגיאה ברורה; ועכשיו אפילו “אפליקציה פשוטה” לא עומדת. נלך כמו SRE: נבודד בעיה שכבה-שכבה עד שיש 200 /healthz, ורק אז נחזור ל-WS/שיחות. הכל בלי לגעת בפיצ’רים — רק ייצוב ריצה.

להדביק לו אחד-אחד. בכל צעד כתוב מה מצופה לראות. אם משהו לא תואם—זו הנקודה שמצביעים עליה.

⸻

0) בסיס: לא בודקים מהמחשב שלך

בדיקות 127.0.0.1:$PORT חייבות לרוץ בתוך אותה מכונה/סשן שבה השרת רץ. לבדיקה חיצונית – רק https://{PUBLIC_BASE_URL}.

אחרת תמיד תראה Connection refused גם כשהכול בסדר.

⸻

1) פורט נכון, תהליך אחד, לוגים מוצגים

1.1 נקה ריצות קודמות
	•	הרוג כל gunicorn|python|flask|main שרץ.
	•	מחק/נקה קבצי לוג ישנים כדי שלא יבלבלו.

1.2 ודא $PORT נכון
	•	echo "PORT=$PORT" → חייב להחזיר מספר לא ריק (בסביבות מנוהלות מקבלים פורט דינמי).
	•	אם ריק → קבע זמנית export PORT=8000 ותשתמש בו גם בבדיקות.

1.3 הרץ Gunicorn עם sync (אבחון טהור) + לוגים מלאים
	•	הפעלה (אותה שורת הרצה בכל פעם; אל תערב dev-server):

python3 -m gunicorn AgentLocator.main:app \
  -k sync -w 1 -b 0.0.0.0:$PORT \
  --log-level debug --capture-output \
  --timeout 60 --keep-alive 30 \
  --access-logfile '-' --error-logfile '-'



מצופה בלוג:
Listening at: http://0.0.0.0:<PORT> ומיד לאחר מכן אין “Handling signal: term”.

1.4 אימות מיידי (באותה מכונה):
	•	ss -ltnp | grep ":$PORT" → חייב לראות LISTEN עם python/gunicorn.
	•	curl -sS -m 3 http://127.0.0.1:$PORT/healthz -i → חייב HTTP/1.1 200 OK.

אם כאן עדיין Connection refused או ה-worker מת אחרי ~10ש׳:
ב-90% זה אחד משניים:
	•	לא מאזין על ה-$PORT שהפלטפורמה דורשת → הסופרוויזור הורג (SIGTERM). אל תקבע 5000 ידנית.
	•	קריסה שקטה בזמן boot (import/תלויות/משאבים) שלא מגיעה ללוג.

⸻

2) שוללים “קריסה שקטה” ומכריחים שגיאה לצאת

2.1 הפעלה עם preload כדי לחשוף שגיאות boot

python3 -m gunicorn AgentLocator.main:app \
  -k sync -w 1 -b 0.0.0.0:$PORT \
  --preload --capture-output --log-level debug \
  --access-logfile '-' --error-logfile '-'

	•	אם יש ImportError/Exception ב-create_app/blueprints — תראה עכשיו.

2.2 ייבוא יבש (תוך שניות)
בודק שה־app קיים וה-/healthz עובד בלי שרת:

python3 - <<'PY'
import AgentLocator.main as M
print("APP?", hasattr(M, "app"))
print("URL_MAP?", getattr(M.app, "url_map", None))
print("TEST /healthz ->", M.app.test_client().get("/healthz").status_code)
PY

	•	אם כאן 200 אבל Gunicorn עדיין מסרב → זו שכבת WSGI/פורט/סופרוויזור, לא אפליקציה.

⸻

3) שוללים בעיות מערכת (הורג אותך מבחוץ)

3.1 משאבים
	•	df -h → לא Disk Full (אם מלא—Gunicorn ימות מהר).
	•	ulimit -n → לפחות 1024 קבצים פתוחים.
	•	ps aux --sort=-%mem | head → אין תהליך “בולען” שמפיל OOM.

3.2 אין שרת dev נסתר
	•	אסור לראות בלוג “Running on all addresses (0.0.0.0)”. אם כן — יש app.run() בזמן import. להשאיר רק תחת if __name__ == "__main__":.

3.3 Proc/Runner אחד
	•	אין שני מנהלי ריצה שמנסים להרים/להפיל אותך במקביל (סימן: SIGTERM מחזורי).
	•	ודא שה-runner של הפלטפורמה בודק בדיוק את אותו $PORT שאתה מאזין עליו.

⸻

4) אם sync יציב — ורק אז עוברים ל-eventlet

4.1 גרסאות ותצורה eventlet/greenlet
בדוק:

python3 - <<'PY'
import eventlet, greenlet, sys
print("eventlet", eventlet.__version__)
print("greenlet", greenlet.__version__)
print("python", sys.version)
PY

מומלץ יציב:
	•	eventlet >= 0.33.3
	•	greenlet תואם לפייתון שלך (לרוב 3.0.x/3.1.x לפייתון 3.11/3.12).

ENV שמונעים קריסות “שקטות”:

export EVENTLET_NO_GREENDNS=1
export EVENTLET_HUB=select

greendns ו-epoll גורמים לקריסות בלתי־מדווחות בסביבות מסוימות.

4.2 הפעלה עם eventlet

python3 -m gunicorn AgentLocator.main:app \
  -k eventlet -w 1 -b 0.0.0.0:$PORT \
  --log-level debug --capture-output \
  --timeout 120 --keep-alive 75 \
  --access-logfile '-' --error-logfile '-'

	•	חייב LISTEN על $PORT ו-/healthz 200 (מקומי וחיצוני).

אם eventlet עדיין מת אבל sync עובד:
	•	זו בעיית ספריות/ENV. השאר sync לרגע (כדי שהמערכת חיה), ובמקביל:
	•	עדכן eventlet/greenlet לגרסאות היציבות.
	•	ודא אין gevent/uvloop מותקנים (התנגשויות).
	•	ודא ש-eventlet.monkey_patch() קורה פעם אחת ולפני כל import רשת — לא מאוחר, לא כפול.

אם הסביבה ממש עוינת ל-eventlet: שקול worker חלופי gevent-websocket או Bridge Node.js (ws) ל-subprotocol של Twilio; אבל קודם סגור את sync.

⸻

5) אחרי שהשרת עונה — מיד מחזירים שיחות

5.1 TwiML/Webhooks
	•	incoming_call → <Connect><Stream ...> (בלי // כפול).
	•	stream_status/stream_ended → 204 ריק, request.form בלבד.

5.2 Handshake WS (מוריד 31920)
	•	בדוק:

wscat -c wss://{BASE}/ws/twilio-media \
      -H "Sec-WebSocket-Protocol: audio.twilio.com"

מצופה 101 וה-subprotocol חוזר.

5.3 STT/TTS (למנוע “שקט”)
	•	μ-law (PCMU) 8000Hz מונו; פריימים של 20ms; MEDIA_TX בלוגים.
	•	GCP creds קיימים (או JSON env אחד).

⸻

6) “למה הוא קורס?” — 10 גורמים שכיחים (וטיפול)
	1.	מאזין לפורט הלא-נכון → הסופרוויזור הורג (SIGTERM אחרי ~10ש׳).
טיפול: האזן על $PORT של הפלטפורמה, לא 5000 קשיח.
	2.	dev server רץ בזמן import (יש app.run() לא מוגן) → התנגשויות/סגירה.
טיפול: להסיר; רק Gunicorn מריץ.
	3.	eventlet/greenlet גרסאות לא תואמות → קריסה שקטה.
טיפול: שדרוג/ENV (NO_GREENDNS, HUB=select), הסרת gevent/uvloop.
	4.	Disk full/FD limit → Gunicorn קם ומת.
טיפול: df -h, ulimit -n, לנקות/להגדיל.
	5.	Import כבד/Init כבד בזמן boot → לא מגיע להאזנה/מת מיד.
טיפול: Lazy + Warmup ברקע (עשית—טוב).
	6.	שני ראנרים/פרוססים מעלים/מורידים אותך בלופ.
טיפול: ראנר יחיד; ודא pipeline אחד.
	7.	חומת אש/Proxy פנימי שומע על פורט אחר.
טיפול: ודא שה-runner מכוון לאותו $PORT.
	8.	Service Worker/Cache ישן בצד הקליינט (פחות רלוונטי ל-healthz, אך יכול לבלבל).
טיפול: בדיקות דרך curl.
	9.	קרדנציאלס/ENV חסרים שזורקים שגיאה רק ב-Gunicorn.
טיפול: --preload --capture-output ומדיניות ENV ברורה.
	10.	בדיקה מ-localhost הלא נכון (המחשב שלך במקום המכונה של השרת).
טיפול: בדוק 127.0.0.1:$PORT רק בתוך אותה סביבה; מבחוץ—PUBLIC_BASE_URL.

⸻

מה לבקש ממנו עכשיו (להוכיח איפה נופל)
	1.	פלט של:

echo PORT=$PORT
ss -ltnp | grep ":$PORT" || netstat -ltnp | grep ":$PORT"
curl -sS -m 3 http://127.0.0.1:$PORT/healthz -i

	2.	פלט חיצוני:

curl -sS -m 5 https://{PUBLIC_BASE_URL}/healthz -i

	3.	פלט הפעלה עם sync ו---preload --capture-output (אם עדיין מת).
	4.	אם עוברים ל-eventlet: פלט גרסאות eventlet/greenlet + ה-ENV שהגדרת.

עם זה נאתר את הנקודה המדויקת (פורט/סופרוויזור/תלויות) ונסגור את זה. ברגע שיש 200 /healthz יציב—נחבר שוב את Handshake של Twilio ונחזיר את הקול.