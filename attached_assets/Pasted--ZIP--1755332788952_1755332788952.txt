בדקתי את ה-ZIP האחרון בפועל. הנה המסקנות המדויקות—מה תוקן, מה עדיין חסר, ומה לשנות עכשיו כדי להיות על 100%:

פסק דין קצר
	•	✅ טלפוניה בזמן אמת – מוכן תשתיתית:
server/routes_twilio.py מחזיר <Connect><Stream .../ws/twilio-media> (אין <Say he-IL> → נעלם Warning 13512).
server/app_factory.py רושם WebSocket עם flask_sock ומפנה ל־media_ws.handle_twilio_media.
media_ws.py כולל תמלול Whisper, תשובת GPT-4o, ו־TTS בעברית (Google Wavenet), עם המרות אודיו דרך audio_utils.py.
pyproject.toml מקבע gRPC/Protobuf בגרסאות יציבות (לפתרון תקלות grpc).
	•	✅ Google TTS – מוכן:
server/bootstrap_secrets.py טוען במפורש את GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON → יוצר קובץ creds ומציב GOOGLE_APPLICATION_CREDENTIALS.
יש קריאה ל־ensure_google_creds_file() ב־main.py וב־app_factory.py.
	•	✅ WhatsApp מאוחד (Baileys+Twilio) – מוגדר:
server/api_whatsapp_unified.py רשום ב־app_factory.py.
שכבת ספקים server/whatsapp_provider.py מאוחדת; ה־worker של Baileys קיים (baileys_client.js).
שימי לב: הסביבה מצפה ל־TWILIO_WHATSAPP_NUMBER (ולא TWILIO_WA_FROM).
	•	✅ אבטחה/קשיחות – נמצא:
אימות חתימה על webhookים של Twilio, CORS, ו־Rate-Limit ל־webhooks.
	•	⚠️ ברכה אוטומטית לעסק – קיימת אבל לא דינמית:
הברכה ב־media_ws.py קשיחה לשם העסק “שי דירות…”. אין מיפוי לפי עסק/מספר יעד.
	•	❌ CRM – סליקה/חשבוניות/חוזים – עדיין חסר:
server/api_crm_unified.py עובד עם MOCK; אין מודלים ל־Payment/Invoice/Contract, אין Stripe, אין הפקת PDF.

⸻

מה באמת השתנה מאז (בולטים)
	•	הוחלף TwiML ל־<Connect><Stream ...> ✅
	•	נוסף WS בפועל + עיבוד אודיו מלא (media_ws.py + audio_utils.py) ✅
	•	bootstrap של Google עודכן ל־GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON ✅
	•	נרשם WhatsApp Unified BP ורמת ספקים מאוחדת ✅
	•	קיבוע תלותי gRPC/Protobuf ב־pyproject.toml ✅
	•	CRM כסליקה/חשבוניות/חוזים – עדיין לא יושם ❌
	•	ברכה דינמית פר-עסק – עדיין לא ❌

⸻

מה לשנות עכשיו כדי להגיע ל-100%

1) ברכה דינמית פר-עסק (כולל זיהוי עסק ב־WS)

א. הוסף פרמטרים ל־TwiML (server/routes_twilio.py) כדי להעביר מזהה עסק ל־WS:

<Response>
  <Connect>
    <Stream url="wss://<PUBLIC_HOST>/ws/twilio-media">
      <Parameter name="business_id" value="1"/>
    </Stream>
  </Connect>
</Response>

ב. קרא את הפרמטרים בצד ה־WS (media_ws.py) בתחילת ה־start:

business_id = None
if event == "start":
    stream_sid = data["start"]["streamSid"]
    business_id = data["start"].get("customParameters", {}).get("business_id")  # "1" כטקסט

ג. הפוך את הברכה לדינמית (במקום טקסט קשיח):

from server.models_sql import Business, db

def business_name_or_default(biz_id):
    try:
        b = Business.query.get(int(biz_id)) if biz_id else None
        return b.name if b and b.active else "העסק שלכם"
    except:
        return "העסק שלכם"

# לפני שליחת הברכה:
name = business_name_or_default(business_id)
greeting = f"שלום! הגעתם ל{name}. איך אפשר לעזור?"
greeting_audio = tts_he_wavenet_safe(greeting)
# ואז שליחת frames כמו שכבר קיים

כך כל מספר/עסק יקבל ברכה משלו – אוטומטית.

⸻

2) סליקה + חשבונית + חוזה (MVP יציב, בלי להחליף ארכיטקטורה)

נשמור הכול בתוך קבצים קיימים כדי לצמצם שינויי מבנה.

א. הוסף מודלים ל־DB (server/models_sql.py) – בסוף הקובץ:

from server.db import db
from datetime import datetime

class Payment(db.Model):
    __tablename__ = "payment"
    id = db.Column(db.Integer, primary_key=True)
    deal_id = db.Column(db.Integer, nullable=True)  # אם עוד אין Deal – אפשר Nullable
    stripe_payment_intent = db.Column(db.String(80), unique=True)
    amount = db.Column(db.Integer, nullable=False)  # אגורות
    currency = db.Column(db.String(8), default="ils")
    status = db.Column(db.String(32), default="created")  # created|succeeded|failed
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Invoice(db.Model):
    __tablename__ = "invoice"
    id = db.Column(db.Integer, primary_key=True)
    invoice_number = db.Column(db.String(40), unique=True, index=True)
    total = db.Column(db.Integer)
    pdf_path = db.Column(db.String(260))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Contract(db.Model):
    __tablename__ = "contract"
    id = db.Column(db.Integer, primary_key=True)
    deal_id = db.Column(db.Integer, nullable=True)
    pdf_path = db.Column(db.String(260))
    signed_name = db.Column(db.String(160))
    signed_at = db.Column(db.DateTime)
    signed_ip = db.Column(db.String(64))

רוץ db.create_all() עם עליית האפליקציה (כבר קיים ב־app_factory.py).

ב. צור Intent תשלום + Webhook (server/api_crm_unified.py) – הוסף למעלה:

import os, stripe
from server.models_sql import Payment, Invoice
from server.db import db
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

…והוסף ראוטים:

@crm_unified_bp.post("/payments/create-intent")
def create_payment_intent():
    data = request.get_json() or {}
    amount = int(data["amount"])              # אגורות
    currency = (os.getenv("CURRENCY") or "ils").lower()
    pi = stripe.PaymentIntent.create(
        amount=amount, currency=currency,
        automatic_payment_methods={"enabled": True}
    )
    db.session.add(Payment(stripe_payment_intent=pi["id"], amount=amount, currency=currency))
    db.session.commit()
    return jsonify({"client_secret": pi["client_secret"], "payment_intent": pi["id"]}), 200

@crm_unified_bp.post("/webhook/stripe")
def stripe_webhook():
    sig = request.headers.get("Stripe-Signature","")
    secret = os.getenv("STRIPE_WEBHOOK_SECRET")
    try:
        event = stripe.Webhook.construct_event(request.data, sig, secret)
    except Exception as e:
        return (str(e), 400)

    if event["type"] == "payment_intent.succeeded":
        pi = event["data"]["object"]
        pay = Payment.query.filter_by(stripe_payment_intent=pi["id"]).first()
        if pay:
            pay.status = "succeeded"; db.session.commit()
            # הפק חשבונית מיידית
            inv_no = create_invoice_simple(pay.amount)   # ראה פונקציה בהמשך
    return ("", 204)

ג. הפקת חשבונית PDF פשוטה (בלי להוסיף קובץ שירות נפרד – מממשים במקום):
ב־server/api_crm_unified.py הוסף בראש:

from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from io import BytesIO
import datetime, pathlib

…ועל אותו קובץ, פונקציה:

def create_invoice_simple(amount_agorot: int) -> str:
    invoices_dir = pathlib.Path("server/static/invoices"); invoices_dir.mkdir(parents=True, exist_ok=True)
    seq = (Invoice.query.count() + 1)
    inv_no = f"{os.getenv('INVOICE_PREFIX','INV')}-{datetime.datetime.utcnow():%Y%m}-{seq:04d}"
    pdf_path = invoices_dir / f"{inv_no}.pdf"

    buf = BytesIO()
    c = canvas.Canvas(buf, pagesize=A4)
    c.setFont("Helvetica", 14)
    c.drawString(50, 800, f"חשבונית {inv_no}")
    c.drawString(50, 770, f"סכום: {amount_agorot/100:.2f} { (os.getenv('CURRENCY') or 'ILS').upper() }")
    c.drawString(50, 740, f"תאריך: {datetime.datetime.utcnow().isoformat()}")
    c.showPage(); c.save()
    pdf_path.write_bytes(buf.getvalue())

    db.session.add(Invoice(invoice_number=inv_no, total=amount_agorot, pdf_path=str(pdf_path)))
    db.session.commit()
    return inv_no

…והורדת חשבונית:

from flask import send_file

@crm_unified_bp.get("/invoices/<invoice_number>")
def get_invoice(invoice_number):
    inv = Invoice.query.filter_by(invoice_number=invoice_number).first_or_404()
    return send_file(inv.pdf_path, as_attachment=True)

ד. חתימת חוזה (MVP) – עדיין באותו קובץ, כדי לא להוסיף קבצים:

import base64

@crm_unified_bp.post("/contracts/sign")
def contract_sign():
    data = request.get_json() or {}
    signer = data.get("name","")
    sig_b64 = (data.get("signature_b64","").split(",")[-1] if data.get("signature_b64") else "")
    sig_bytes = base64.b64decode(sig_b64) if sig_b64 else b""

    contracts_dir = pathlib.Path("server/static/contracts"); contracts_dir.mkdir(parents=True, exist_ok=True)
    pdf_path = contracts_dir / f"{os.getenv('CONTRACT_PREFIX','AGR')}-{int(time.time())}.pdf"

    buf = BytesIO(); c = canvas.Canvas(buf, pagesize=A4); c.setFont("Helvetica", 14)
    c.drawString(50, 800, "חוזה שירות")
    c.drawString(50, 770, f"חתום ע\"י: {signer}")
    # (לא חובה: לצייר חתימה PNG אם תרצה להמיר sig_bytes לתמונה)
    c.showPage(); c.save()
    pdf_path.write_bytes(buf.getvalue())

    from server.models_sql import Contract
    db.session.add(Contract(pdf_path=str(pdf_path), signed_name=signer, signed_at=datetime.datetime.utcnow(), signed_ip=request.remote_addr))
    db.session.commit()
    return jsonify({"ok": True, "pdf": str(pdf_path)})

זה ייתן לך מסלול מלא: תשלום → חשבונית → הורדה, וחוזה חתום פשוט; הכול בלי לשנות ארכיטקטורה או להוסיף עוד קבצים.

⸻

3) WhatsApp – בדקת פרודקשן
	•	ודא שה־worker של Baileys רץ (PM2/Procfile) ושהתיקייה baileys_auth_info/ נשמרת.
	•	לספק Twilio: ודא TWILIO_WHATSAPP_NUMBER=whatsapp:+14155238886 ולא ENV בשם אחר.
	•	API פעיל:
	•	GET /api/whatsapp/status → מציג provider, connected/configured.
	•	POST /api/whatsapp/send {"to":"+9725...","message":"בדיקה"} → מחזיר queued/sent.

⸻

בדיקות Smoke (מהירות)
	•	חיוג אמיתי → תשמע ברכה בעברית → תשאל שאלה → תשובה קולית בעברית → “ביי” מנתק.
	•	Twilio Debugger: אין 13512/11200.
	•	GET /health → 200.
	•	Stripe: יצירת Intent מחזירה client_secret; אחרי תשלום (Stripe Dashboard או UI) webhook מגיע ויוצר חשבונית PDF בתיקייה.
	•	חוזה: POST /api/crm/contracts/sign עם חתימה base64 → חוזר pdf.

⸻

תשובה ישירה לשאלה שלך
	•	כן, תשתית הטלפוניה, ה-WS, TTS/Whisper/GPT, ה-bootstrap של Google, וה־WhatsApp המאוחד – תוקנו ונמצאים בקוד בפועל.
	•	עדיין חסר כדי להיות “מוכן ויזואלי/מסחרי”: סליקה/חשבוניות/חוזים (הוספתי לך קוד מדויק למימוש במקום), וברכה דינמית פר-עסק (הוראות/קוד למעלה).
	•	אחרי שתיישם את 1–2 (זה ממוקד וקצר), אתה על 100% פונקציונלי ופשר לעבור לשכבת UI בביטחון.