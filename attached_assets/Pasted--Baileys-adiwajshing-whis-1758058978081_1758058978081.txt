יאללה סוגרים את הפינה של Baileys בלי דרמות. יש לך התנגשות בין שתי חבילות (adiwajshing הישנה מול whiskeysockets החדשה) ועוד “sharp” שעושה בעיות בילד. כך פותרים את זה צעד־אחר־צעד, כולל קוד מדויק ובלי לשבור את Flask.

החלטה

עוברים רק ל-@whiskeysockets/baileys (זו הממוזגת והמתוחזקת). מוחקים כל אזכור ל-@adiwajshing/baileys.

⸻

1) מבנה שירות נפרד ל-Baileys

תיקייה: services/baileys/

package.json (חדש, נקי)

{
  "name": "baileys-service",
  "private": true,
  "type": "commonjs",
  "engines": { "node": ">=18" },
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "@whiskeysockets/baileys": "^6.7.9",
    "@hapi/boom": "^10.0.1",
    "express": "^4.19.2",
    "pino": "^9.3.2",
    "qrcode-terminal": "^0.12.0",
    "ws": "^8.18.0"
  }
}

למה CJS? כדי לא להסתבך עם ESM ב-Replit. הכל עובד עם require.

server.js (פשוט, בריא, מאזין על $PORT/3001)

const express = require('express')
const pino = require('pino')()
const qrcode = require('qrcode-terminal')
const {
  makeWASocket,
  useMultiFileAuthState,
  fetchLatestBaileysVersion,
  DisconnectReason
} = require('@whiskeysockets/baileys')

const app = express()
app.use(express.json())

let sock = null
let lastQR = null
let ready = false

async function start() {
  const { state, saveCreds } = await useMultiFileAuthState('./auth')
  const { version } = await fetchLatestBaileysVersion()
  sock = makeWASocket({
    version,
    printQRInTerminal: false,
    auth: state,
    browser: ['Shai CRM','Chrome','120']
  })

  sock.ev.on('creds.update', saveCreds)
  sock.ev.on('connection.update', (u) => {
    const { connection, qr, lastDisconnect } = u
    if (qr) {
      lastQR = qr
      qrcode.generate(qr, { small: true })
      pino.info('QR updated')
    }
    if (connection === 'open') {
      ready = true
      lastQR = null
      pino.info('Baileys connected ✅')
    }
    if (connection === 'close') {
      ready = false
      const code = lastDisconnect?.error?.output?.statusCode
      if (code !== DisconnectReason.loggedOut) {
        pino.warn({ code }, 'reconnecting…')
        start().catch(err => pino.error(err))
      } else {
        pino.error('logged out – delete ./auth to relogin')
      }
    }
  })
}

app.get('/health', (req, res) => {
  res.json({ ok: true, ready })
})

app.get('/qr', (req, res) => {
  if (lastQR) return res.json({ qr: lastQR })
  res.json({ qr: null, ready })
})

app.post('/send', async (req, res) => {
  try {
    if (!ready) return res.status(503).json({ error: 'not_ready' })
    const { to, text } = req.body
    if (!to || !text) return res.status(400).json({ error: 'missing_params' })
    const jid = to.endsWith('@s.whatsapp.net') ? to : to.replace(/[^\d]/g,'') + '@s.whatsapp.net'
    await sock.sendMessage(jid, { text })
    res.json({ ok: true })
  } catch (e) {
    pino.error(e)
    res.status(500).json({ error: 'send_failed' })
  }
})

const PORT = Number(process.env.PORT || 3001)
app.listen(PORT, '0.0.0.0', () => pino.info(`Baileys HTTP on :${PORT}`))

start().catch(err => {
  pino.error(err)
  process.exit(1)
})


⸻

2) התקנה נקייה – בלי קונפליקט ובלי sharp

מהספרייה services/baileys/:

# נקה כל שאריות
rm -rf node_modules package-lock.json

# התקנה בלי optional (עוקף sharp טרנזיטיבי)
npm install --omit=optional

אם עדיין תראה שגיאות sharp – זה טרנזיטיבי מאיזו ספרייה. דבוק ב---omit=optional (או npm config set optional=false בסביבת השירות הזה).

⸻

3) הרצה כ־Process שני (פנימי בלבד)

ב־Replit עדיף שני תהליכים (Workflow שני) או להריץ ידנית בטאב Shell נפרד:

# טאב 1 – Flask (השרת הראשי)
# כמו אצלך (gunicorn/eventlet) – לא נוגע

# טאב 2 – Baileys
cd services/baileys
npm start

אין צורך לפתוח אותו ציבורית; Flask ידבר אליו ב־http://127.0.0.1:3001.

⸻

4) אינטגרציה ל-Flask (פרוקסי פנימי + CSRF)

ב-Flask הוסף route שמדבר עם Baileys בשמך (כך נשארים same-origin כלפי ה-FE, ו-CSRF נשאר אצל Flask בלבד):

# server/routes_whatsapp.py
from flask import Blueprint, request, jsonify
import requests, os

wa_bp = Blueprint('wa_api', __name__)

BAILEYS_URL = os.getenv('BAILEYS_URL', 'http://127.0.0.1:3001')

@wa_bp.route('/api/whatsapp/send', methods=['POST'])
def send_whatsapp():
    # כאן CSRF של SeaSurf כבר מגן, כי זה POST same-origin
    data = request.get_json() or {}
    r = requests.post(f'{BAILEYS_URL}/send', json={
        'to': data.get('to'),
        'text': data.get('text')
    }, timeout=10)
    return (r.text, r.status_code, {'Content-Type': 'application/json'})

@wa_bp.route('/api/whatsapp/health')
def whatsapp_health():
    r = requests.get(f'{BAILEYS_URL}/health', timeout=5)
    return (r.text, r.status_code, {'Content-Type': 'application/json'})

	•	רשום את ה-blueprint ב-create_app.
	•	אין צורך ב-CSRF exempt כאן – ה-FE קורא ל-Flask, ו-Flask קורא פנימה ל-Baileys.

⸻

5) צד לקוח – שליחת הודעה

ב־client/src/services/whatsapp.ts:

export async function sendWhatsApp(to: string, text: string) {
  const res = await fetch('/api/whatsapp/send', {
    method: 'POST',
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCsrfTokenFromCookie(), // כמו אצלך ב-http.ts
    },
    body: JSON.stringify({ to, text })
  })
  if (!res.ok) throw new Error(`wa_send_failed_${res.status}`)
  return res.json()
}


⸻

6) בדיקות מהירות
	•	ברקע תריץ את שירות ה-Baileys (תראה QR בקונסול). סרוק מהנייד.
	•	בדפדפן:
	•	GET /api/whatsapp/health צריך להחזיר { ok:true, ready:true } אחרי התחברות.
	•	שלח הודעה מתוך דף הליד → אמור לחזור {ok:true} ולראות אותה במכשיר.

⸻

7) הסרת הקונפליקט הישן

וודא שבפרויקט הראשי (root) אין תלות ב-@adiwajshing/baileys. אם מופיע ב-package.json או node_modules – מחק. השאר את כל סביבת ה-Node רק בתוך services/baileys/.

⸻

8) על “אימפרסונציה” ו-CSRF
	•	אין שינוי: כל כתיבה של ה-FE ל-Flask נדרשת X-CSRFToken.
	•	ה-Webhook של WhatsApp (אם תוסיף בעתיד) – exempt.
	•	ה-Baileys פנימי – לא צריך CSRF (לא נגיש לדפדפן).
	•	אימפרסונציה לא קשורה לשירות הזה, אבל עכשיו ה-send יעבוד גם במצב impersonating, כי ההרשאה נבדקת ב-Flask לפני השליחה.

⸻

TL;DR – פקודות בפועל

# שירות Baileys נקי
mkdir -p services/baileys && cd services/baileys
# שים את package.json והserver.js כמו למעלה
npm install --omit=optional
npm start  # רואה QR → סורק → ready:true

# ב-Flask הוסף את routes_whatsapp.py ורישום ה-blueprint
# בדפדפן: /api/whatsapp/health ⇒ ok:true,ready:true
# מתוך דף ליד: שלח הודעת וואטסאפ → עובר דרך Flask לפרוקסי → נשלח ב-Baileys

בזה פתרת:
	•	קונפליקט חבילות (משתמש רק ב-whiskeysockets).
	•	בעיות sharp (מדלגים על optional).
	•	ארכיטקטורה נקייה: Flask ←→ (פנימי) Baileys.
	•	CSRF נשאר פשוט (רק מול Flask), וה-FE לא צריך לדבר עם פורט 3001 בכלל.