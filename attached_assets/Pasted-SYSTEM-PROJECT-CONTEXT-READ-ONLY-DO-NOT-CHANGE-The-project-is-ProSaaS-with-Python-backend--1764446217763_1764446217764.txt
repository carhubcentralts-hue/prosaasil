SYSTEM / PROJECT CONTEXT (READ-ONLY, DO NOT CHANGE)
The project is ProSaaS with:
	•	Python backend (Flask/FastAPI style) + WhatsApp Baileys + Twilio voice calls.
	•	React/TypeScript frontend (AI CRM + WhatsApp settings page).
	•	Postgres (Neon) + Docker + nginx + external server (Contabo).

Code on the server and in Git is synchronized (a git pull was done from production after docker-compose fixes).

Already existing:
	•	Full Baileys integration (webhook → Flask, outbound HTTP from backend to Baileys).
	•	WhatsApp settings page in the CRM UI.
	•	Business model/entities that include at least a “whatsapp_enabled” (or similar) flag.

Business goal
Add parallel support for 2 WhatsApp providers:
	1.	Baileys (WhatsApp Web) – existing behavior, must remain fully working.
	2.	Official WhatsApp via Meta Cloud API (NOT Twilio WhatsApp in this phase).

Each business should have a field whatsapp_provider and be able to choose:
	•	“baileys” – keep the current Baileys flow.
	•	“meta” – use the official WhatsApp Business Cloud API (Meta).

You MUST NOT break anything that currently works with Baileys or voice (Twilio calls).

⸻

RULES AND BOUNDARIES (VERY IMPORTANT)
	1.	Files you MUST NOT touch

	•	.env – do NOT change its format, do NOT add quotes, do NOT remove any variables.
	•	docker-compose.yml, all Dockerfile.*, docker/nginx.conf – leave as they are.
	•	Any Twilio voice / Realtime / TTS / n8n related files – do not touch.

	2.	Allowed changes
You may only touch or create code where it is really needed for WhatsApp:

	•	Business models (models.py or equivalent).
	•	Existing WhatsApp / Baileys services (e.g. whatsapp_routes.py, whatsapp_service.py, baileys_service.py).
	•	API / route files related to WhatsApp only.
	•	React components for WhatsApp settings only (settings page / status / QR button).
	•	You MAY create new service/route modules if it helps keeping the logic clean and isolated.

	3.	General guidelines

	•	Do NOT perform large refactors in unrelated areas.
	•	Do NOT remove existing functions/fields – only extend or wrap them.
	•	Keep all existing Baileys endpoints and URLs exactly as they are so production is not broken.
	•	You may read new env vars (see Meta section) but DO NOT modify .env automatically.
	•	Keep everything compatible with the external server setup (PUBLIC_BASE_URL is already in use).

⸻

STEP 1 – IDENTIFY CURRENT WHATSAPP LAYER
	1.	Search the codebase for: “Baileys”, “whatsapp”, “BAILEYS_OUTBOUND_URL”, “BAILEYS_WEBHOOK_SECRET”.
	2.	Internally (in your own notes) map the following:
	•	The main WhatsApp route file (e.g. whatsapp_routes.py).
	•	The service that sends messages via Baileys (e.g. WhatsAppService / BaileysClient).
	•	The Business / Account / Company model where WhatsApp is enabled per business.
	3.	Do NOT delete anything. Just understand the current pipeline:
	•	Incoming: Baileys webhook → Flask route → service → CRM/AI.
	•	Outgoing: backend service → HTTP call to Baileys.

⸻

STEP 2 – EXTEND BUSINESS MODEL (DB)

Goal: add a WhatsApp provider choice per business.
	1.	In the Business model (or equivalent) add a new field:
	•	Name: whatsapp_provider
	•	Type: short String / Enum
	•	Default value: “baileys” (to keep all existing businesses working without changes).
	2.	If there is a migration system (Alembic or similar):
	•	Create a minimal migration that adds this column with default “baileys”.
	•	Do NOT alter any other columns.
	3.	Ensure that whenever business settings for WhatsApp are returned by the API,
the field whatsapp_provider is included together with whatsapp_enabled and any other relevant fields.

⸻

STEP 3 – CREATE A UNIFIED WHATSAPP SERVICE LAYER

Idea: one gateway that the rest of the system uses. Inside it, we decide Baileys vs Meta.
	1.	Create (or extend, if already present) a service module, for example:
	•	server/services/whatsapp_gateway.py
	2.	In that module, create a unified interface, for example:

from typing import Optional

def get_business_whatsapp_provider(business) -> str:
# If field missing/None → “baileys” (backwards compatible)
provider = getattr(business, “whatsapp_provider”, None)
return provider or “baileys”

def send_whatsapp_message(business, to: str, text: str) -> None:
provider = get_business_whatsapp_provider(business)

if provider == "baileys":
    from .baileys_client import send_message_baileys
    return send_message_baileys(business, to, text)

if provider == "meta":
    from .meta_whatsapp_client import send_message_meta
    return send_message_meta(business, to, text)

# Not enabled → logical error, but do not crash the whole app
raise ValueError("WhatsApp not enabled for this business")

	3.	Add a unified handler for incoming messages, e.g.:

def handle_incoming_whatsapp_message(
*,
provider: str,
business,
from_number: str,
to_number: str,
body: str,
raw_payload: dict,
):
“””
Shared logic for all providers:
- Create/update leads
- Write to CRM (conversations, messages, etc.)
- Trigger AI / n8n flows as needed
- Optionally send replies via send_whatsapp_message(…)
“””
# Inside this function you should not care if it’s Baileys or Meta,
# provider is only used for logging / analytics if needed.
…
	4.	Wherever the code currently talks directly to Baileys, change it to call:
	•	send_whatsapp_message(…) and/or handle_incoming_whatsapp_message(…).
	•	Do NOT delete the Baileys-specific code – wrap it inside a dedicated Baileys client (next step).

⸻

STEP 4 – SEPARATE PROVIDER CLIENTS (BAILEYS / META)

A. Baileys client (already exists, just organize it)
	1.	Create or keep a dedicated module, for example:
	•	server/services/baileys_client.py
	2.	Move existing Baileys-specific logic into it:
	•	Read env vars: BAILEYS_BASE_URL, BAILEYS_WEBHOOK_SECRET, BAILEYS_OUTBOUND_URL, etc.
	•	Perform HTTP calls to Baileys for sending messages.
	3.	Expose a clear function:

def send_message_baileys(business, to: str, text: str) -> None:
…
	4.	Make sure all existing Baileys URLs, webhook paths, and behaviors remain unchanged.

B. Meta WhatsApp Cloud client (new)
	1.	Create a new module:
	•	server/services/meta_whatsapp_client.py
	2.	Read ONLY env vars (do NOT modify .env) such as:
	•	META_WA_ACCESS_TOKEN
	•	META_WA_PHONE_NUMBER_ID
	•	META_WA_WABA_ID (if needed for your logic)
	•	META_WA_VERIFY_TOKEN (for webhook validation – used in the route, not here)

These variables will be set manually later on the server.
	3.	Implement a basic send function using Meta’s Cloud API:

import os
import requests

def send_message_meta(business, to: str, text: str) -> None:
access_token = os.getenv(“META_WA_ACCESS_TOKEN”)
phone_number_id = os.getenv(“META_WA_PHONE_NUMBER_ID”)

if not (access_token and phone_number_id):
    # Controlled error – log and propagate, but don’t crash the whole app
    raise RuntimeError("Meta WhatsApp Cloud API is not fully configured")

url = f"https://graph.facebook.com/v21.0/{phone_number_id}/messages"
headers = {
    "Authorization": f"Bearer {access_token}",
    "Content-Type": "application/json",
}
payload = {
    "messaging_product": "whatsapp",
    "to": to,
    "type": "text",
    "text": {"body": text},
}
resp = requests.post(url, json=payload, headers=headers, timeout=10)
# You may log errors but don’t raise if it’s a transient 4xx/5xx unless you decide otherwise
if not resp.ok:
    # Minimal logging; adjust to the project’s logging style
    # e.g. logger.warning("Meta WA send failed", status=resp.status_code, body=resp.text)
    pass

	4.	Ensure this client module is pure Python – no Flask app context inside it.

⸻

STEP 5 – SEPARATE WEBHOOKS, SHARED HANDLING

A. Existing Baileys webhook (keep behavior, just route through the gateway)
	1.	Locate the current Baileys webhook route (e.g. /whatsapp/baileys/webhook).
	2.	At the end of that route, instead of inline logic, normalize the data and call:

handle_incoming_whatsapp_message(
provider=“baileys”,
business=business,          # however you currently resolve the business
from_number=from_number,
to_number=to_number,
body=body,
raw_payload=request.json,
)
	3.	Do NOT change the expected JSON format from Baileys and do NOT change the endpoint URL.

B. New webhook for Meta WhatsApp Cloud
	1.	Add a new route, e.g. under the same WhatsApp blueprint:

@whatsapp_bp.route(”/webhook/meta”, methods=[“GET”, “POST”])
def meta_webhook():
import os
verify_token_env = os.getenv(“META_WA_VERIFY_TOKEN”)

if request.method == "GET":
    # Webhook verification flow (Meta Cloud standard)
    mode = request.args.get("hub.mode")
    token = request.args.get("hub.verify_token")
    challenge = request.args.get("hub.challenge")

    if mode == "subscribe" and token and token == verify_token_env:
        # Return the challenge as plain text
        return challenge, 200
    return "Forbidden", 403

# POST – incoming message(s) from Meta Cloud
data = request.get_json(silent=True) or {}

# Extract business and message details according to Meta’s payload structure
# (high level – adjust to actual JSON shape you see in docs/logs)
# Example shape:
# data["entry"][0]["changes"][0]["value"]["messages"][0]["from"], ["to"], ["text"]["body"]

...

handle_incoming_whatsapp_message(
    provider="meta",
    business=business,      # resolve business based on your existing auth/tenant logic
    from_number=from_number,
    to_number=to_number,
    body=body,
    raw_payload=data,
)

return "OK", 200

	2.	The final public URL for this webhook should be:
	•	PUBLIC_BASE_URL + “/api/whatsapp_meta/webhook” (or similar consistent path)
Make sure the Flask route path matches the URL you’ll configure in Meta’s dashboard.
	3.	Keep the response very fast and always return HTTP 200 “OK” for POST (unless verification fails).

⸻

STEP 6 – FRONTEND UI: PER-BUSINESS PROVIDER SELECTION
	1.	Locate the React WhatsApp settings page:
	•	Search for “WhatsApp”, “Baileys”, “QR” in the frontend code.
	2.	Extend the settings data model for the business to include:
	•	whatsapp_provider (string) which comes from the backend API.
	3.	In the UI, add a selector (radio buttons or ) with at least two options:
	•	“Baileys (WhatsApp Web)” → value “baileys”
	•	“WhatsApp Business API (Meta Cloud)” → value “meta”
	4.	When the user changes this field and clicks “Save”, send a PATCH/PUT request to the backend
that updates only whatsapp_provider (and any other WhatsApp-related fields already present),
without touching unrelated business data.
	5.	Visual logic:
	•	If whatsapp_provider === “baileys”:
	•	Show the “Generate new QR” button and connection status exactly as today.
	•	If whatsapp_provider === “meta”:
	•	Hide the QR button (Meta Cloud does not use WhatsApp Web QR).
	•	Show an explanatory text that this business uses an official WhatsApp Business API number
configured by the ProSaaS admin.
	•	Optionally show a “Send test message” button that calls a backend /whatsapp/test endpoint
which uses the unified gateway (see next step).

⸻

STEP 7 – OPTIONAL BUT RECOMMENDED: WHATSAPP TEST API

On the backend, add a small test endpoint, for example:

@whatsapp_bp.route(”/test”, methods=[“POST”])
def whatsapp_test():
business = current_business()  # use the existing tenant/business resolution
payload = request.get_json(force=True)
to = payload[“to”]
text = payload.get(“text”, “היי, זו הודעת בדיקה מ-ProSaaS”)

from .whatsapp_gateway import send_whatsapp_message
send_whatsapp_message(business, to, text)

return jsonify({"status": "ok"})

This endpoint MUST use send_whatsapp_message and MUST NOT call Baileys or Meta client directly.

⸻

STEP 8 – DEFINITION OF DONE (MANUAL VERIFICATION REQUIRED)

The feature is considered done only if ALL of the following pass:
	1.	Existing business (no manual changes):
	•	Its whatsapp_provider defaults to “baileys”.
	•	Baileys QR login and connection continue to work exactly as before.
	2.	Incoming message via Baileys:
	•	Customer sends a message to a Baileys-linked number.
	•	Baileys sends a webhook → Flask Baileys route → handle_incoming_whatsapp_message runs.
	•	A lead/CRM record is created or updated as before.
	•	AI / n8n flows (if any) still run.
	•	Replies are sent back via Baileys successfully.
	3.	Outgoing message from CRM for a business with whatsapp_provider=“baileys”:
	•	User clicks “Send via WhatsApp” → message is sent via Baileys (existing behavior).
	4.	Business switched to whatsapp_provider=“meta” (via UI or manually in DB for testing):
	•	Calling the /whatsapp/test endpoint (or an equivalent UI button) sends a message via Meta Cloud API
using meta_whatsapp_client.send_message_meta.
	•	If Meta env vars are missing or invalid, a controlled error is logged / returned as JSON,
but the whole backend and other businesses are unaffected.
	5.	No infra/config changes were made:
	•	docker-compose.yml is unchanged (other than what was already fixed before the latest git pull).
	•	All Dockerfile.* remain unchanged.
	•	.env was NOT modified automatically by the code or the agent.
	6.	All tests/builds still pass:
	•	Backend starts successfully.
	•	Frontend builds successfully.
	•	There are no new runtime crashes in logs when processing WhatsApp for existing Baileys businesses.

⸻

FINAL NOTES
	•	Implement all changes carefully and keep them minimal and focused on WhatsApp.
	•	Create a single clean commit with a message similar to:

feat(whatsapp): add per-business provider (baileys/meta) with unified gateway
	•	Ensure both backend and frontend run successfully and nothing existing is broken.