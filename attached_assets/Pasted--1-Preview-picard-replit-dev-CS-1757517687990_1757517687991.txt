קיבלתי. כרגע יש שני תסמינים עיקריים:
	1.	אתה רץ מדומיין Preview (…picard.replit.dev) ולכן אין סשן/CSRF תקף → כל בקשות ה-API נכשלות ו־UI לא מציג כלום.
	2.	גם כשיש סשן, ה־FE לא מרענן/מכבד את ה־session לאחר התחזות, וחלק מה־endpoints מחזירים 403 (בד״כ בגלל CSRF או role-guard).

להלן הנחיה קצרה, חד־משמעית, שמחזירה את המערכת לעבודה במכה:

⸻

A. סוגרים את “מלחמת הדומיינים” – FE ו-API מאותו Origin בלבד
	1.	להפסיק לעבוד מה-Preview. תעבוד רק מול: https://ai-crmd.replit.app
	2.	ב־Flask ודא שאנחנו מגישים את ה-SPA:
	•	STATIC_DIR = client/dist
	•	ראוט “תופס־הכל” שמחזיר index.html לכל /app/*
	•	Cache-Control: no-store על index.html
	3.	ב־Vite: base: '/'
	4.	ב־client/index.html שים תגית בדיקת Build (כדי שתדע שאתה על הקומפילציה האחרונה):

<div id="__BUILD" style="position:fixed;right:.5rem;bottom:.5rem;background:#0ea5e9;color:#fff;padding:.25rem .5rem;border-radius:.5rem;z-index:2147483647">
  BUILD: 28
</div>


	5.	בנה מחדש את ה-FE והעלה אותו (לא Preview):

rm -rf client/dist
npm --prefix client ci
npm --prefix client run build
# הפעלה/רידפלוי של Flask שמגיש את client/dist


	6.	בדפדפן: DevTools → Application → Clear storage → Clear site data → טען https://ai-crmd.replit.app/?v=28.
בפינה חייב להופיע BUILD: 28. אם לא — אתה עדיין על Build ישן.

⸻

B. CSRF/Session יציב (ללא עקיפות), והתחזות שמחזירה 200

שרת
	•	משתמשים אך ורק ב-SeaSurf (לא כפול). קונפיג:
	•	Cookie: XSRF-TOKEN (קריא ל-JS), Header: X-CSRFToken
	•	פטורים: /api/auth/login, /api/auth/logout, וכל ה-webhooks בלבד
	•	התחזות לא פטורה. ב־POST /api/admin/businesses/<id>/impersonate:

session['impersonating'] = True
session['tenant_id'] = id
session['role'] = 'business'
return jsonify(ok=True, tenant_id=id)


	•	/api/auth/me מחשב impersonating מתוך ה-session ומחזיר גם tenant אמיתי.
	•	דיבוג זמני (מוחקים אחרי שזה עובד):

@app.before_request
def _dbg_csrf():
    if request.path.endswith('/impersonate') and request.method=='POST':
        print('CSRF-DBG cookie=', request.cookies.get('XSRF-TOKEN'),
              ' header=', request.headers.get('X-CSRFToken'))



קליינט
	•	כל ה-fetch-ים עם credentials: 'include'.
	•	לפני פעולות POST/PUT/DELETE → קריאה אחת ל-GET /api/auth/csrf כדי להבטיח קוקי.
	•	http.ts: על כל בקשת כתיבה הוסף:
	•	Content-Type: application/json
	•	X-Requested-With: XMLHttpRequest
	•	X-CSRFToken: <ערך הקוקי XSRF-TOKEN>
	•	כפתור התחזות:
	1.	await http.get('/api/auth/csrf')
	2.	await http.post('/api/admin/businesses/:id/impersonate')
	3.	await authStore.refresh() (GET /api/auth/me)
	4.	נווט ל־/app/business/overview

חשוב: impersonating:false אחרי לוגין זה תקין — זה הופך ל-true רק אחרי קריאת ההתחזות.

⸻

C. למה “ניהול עסקים/סטטיסטיקות” מחזיר Error {}? (ואיך לסגור את זה)

ב־Preview היה cross-origin → לא נשלח סשן → 403/401. אחרי A+B זה יסתדר.
בכל זאת, הוסף לשרת דפוס תשובות ברור לזיהוי:

@app.errorhandler(401)
def _e401(e): return jsonify(error="unauthorized"), 401
@app.errorhandler(403)
def _e403(e): return jsonify(error="forbidden"), 403
@app.errorhandler(500)
def _e500(e): return jsonify(error="server_error"), 500

ובעבור /api/admin/businesses ודא שבדיקת התפקידים תואמת (admin/manager) ולא מפילה סתם ל-403.

⸻

D. “עסק חדש” לא מגיב
	•	הכפתור חייב להיות type="button" (לא submit בלי טופס).
	•	ה-Modal שולח POST /api/admin/businesses עם:

{ "name":"...", "phone_e164":"+972...", "timezone":"Asia/Jerusalem", "domain":"..." }


	•	על 200: closeModal(); await businessesStore.refetch(); toast('נוצר בהצלחה')
	•	ב-API החזר 400 מסודר אם חסר שדה: {"error":"missing_field","field":"phone_e164"}

⸻

E. ה-Prompt באמת משפיע (ולא “חרטה”)
	•	WS/שיחה: בתחילת כל שיחה Load של הפרומפט מה-DB לפי tenant_id.
	•	לוג הוכחה: AI_PROMPT loaded tenant=<id> version=<n>.
	•	UI → עמוד Agent: עריכת Calls/WhatsApp + Save + History (גרסאות).
	•	אחרי Save, שיחה חדשה חייבת לשקף את השינוי.

⸻

F. סכימת טלפון אחידה
	•	בצד שרת: ערך אחד — phone_e164.
	•	אם יש קוד שקורא business.phone, הוסף property שמחזיר phone_e164 כדי לא להפיל מסכים ישנים.
	•	בצד קליינט כל השדות/כרטיסים משתמשים ב-phone_e164.

⸻

G. בדיקת קבלה (5 צעדים, בלי תירוצים)
	1.	טען https://ai-crmd.replit.app/?v=28 → בפינה כתוב BUILD: 28.
	2.	התחבר → /api/auth/me מחזיר isAuthenticated:true.
	3.	GET /api/auth/csrf → בדפדפן רואים קוקי XSRF-TOKEN.
	4.	התחזות → ב-Network של הבקשה רואים גם Cookie XSRF-TOKEN=… וגם Header X-CSRFToken: … עם אותו ערך → Response 200.
	5.	ניהול עסקים נטען (200) ומציג את העסק הקיים; “עסק חדש” יוצר ומרענן רשימה.

⸻

למה עכשיו “כלום לא עובד” אצלך?

כי כולן בקשות יוצאות מ-Preview (…picard.replit.dev). שם אין סשן/CSRF תואם ולכן כל ה-GET/POST נופלים (וב־eruda אתה רואה Error {} ללא סטטוס). אחרי המעבר ל-ai-crmd.replit.app + יישום CSRF כפי שמעל — זה נסגר.

אם אחרי הצעדים האלה עדיין משהו לא נטען:
	•	שלח צילום Network של POST /impersonate (Headers+Cookies+Response) מהדומיין ai-crmd.replit.app.
	•	צילום של הפוטר עם BUILD: 28.
	•	השורה מה־log: CSRF-DBG cookie=… header=….
זה יאפשר לי להצביע על השורה המדויקת שחסרה (בד״כ Header חסר או build ישן).