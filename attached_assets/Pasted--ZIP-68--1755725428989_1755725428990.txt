קפצתי על ZIP ‎(68)‎ ובדקתי בפנים. הנה הסטטוס האמיתי + מה להשלים כדי שזה יהיה “פיקס”:

פסק דין מהיר
	•	✅ קיים: Media Streams בקוד (WS), stream_state (watchdog), TwiML עם <Connect><Stream>, db_migrate, logging_setup, אבטחה (twilio_security.py), ואין עקבות של Socket.IO במסלול המדיה.
	•	⚠️ חסר/טעון שיפור: קובץ פריסה (.replit), Webhook ל־WhatsApp (לא מצאתי routes_whatsapp.py), וודאות ש־Flask-Sock נרשם כמו שצריך (sock.init_app(app)), ורישום שני הנתיבים ל-WS (עם/בלי סלאש). בנוסף, לוודא ש־<Play> משתמש ב־URL מוחלט (פתרון סופי ל־11100) ושקבצי MP3 קיימים בפריסה.

⸻

מה לתקן/להשלים עכשיו (סדר ביצוע קצר)

1) רישום Flask-Sock נכון + שני נתיבי WS

ב־AgentLocator/server/app_factory.py ודא שזה נראה כך (למנוע 426/404/redirect בהנדשייק):

from flask_sock import Sock
from werkzeug.middleware.proxy_fix import ProxyFix
sock = Sock()  # יוזם פעם אחת גלובלית

def create_app():
    app = Flask(__name__, static_url_path="/static",
                static_folder=os.path.join(os.path.dirname(__file__), "..", "static"))
    app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1)

    sock.init_app(app)                     # ← חשוב! לא לשכוח init_app
    assert "sock" in app.extensions        # דיאגנוסטיקה למניעת 426

    from .media_ws import MediaStreamHandler
    @sock.route("/ws/twilio-media")
    def ws_a(ws): MediaStreamHandler(ws).run()
    @sock.route("/ws/twilio-media/")      # ← גם עם סלאש
    def ws_b(ws): MediaStreamHandler(ws).run()

    # ... רישום שאר ה־blueprints/routes ...
    return app

2) TwiML עם URLs מוחלטים (סוגר 11100 “Invalid Play URL”)

ב־routes_twilio.py בתוך incoming_call() בנה URL מהדומיין האמיתי:

def abs_url(path: str) -> str:
    base = os.getenv("PUBLIC_BASE_URL") or request.url_root.rstrip("/")
    return f"{base}{path}"

greeting_url = abs_url("/static/tts/greeting_he.mp3")
wss_host = (os.getenv("PUBLIC_BASE_URL") or request.url_root).replace("https://","").replace("http://","").strip("/")

twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Play>{greeting_url}</Play>               <!-- לא Say בעברית -->
  <Connect action="/webhook/stream_ended">
    <Stream url="wss://{wss_host}/ws/twilio-media">
      <Parameter name="call_sid" value="{call_sid}"/>
    </Stream>
  </Connect>
</Response>"""

וב־watchdog redirect (אם יש): השתמש ב־abs_url("/static/tts/fallback_he.mp3").

ודא שב־Deployment קבצי static/tts/greeting_he.mp3 ו־fallback_he.mp3 באמת קיימים ומחזירים 200.

3) חתימת Twilio – רק על HTTP, לא על WS

וודא שהדקורטור @require_twilio_signature נמצא על:
	•	/webhook/incoming_call, /webhook/stream_ended, /webhook/handle_recording, /webhook/call_status
ולא על /ws/twilio-media.

4) WhatsApp – להוסיף webhook ולרשום אותו

בקובץ חדש AgentLocator/server/routes_whatsapp.py:

from flask import request
from twilio.twiml.messaging_response import MessagingResponse

def register_whatsapp_routes(app):
    @app.post("/webhook/whatsapp/inbound")
    def whatsapp_inbound():
        from_ = request.form.get("From")      # whatsapp:+972...
        body  = request.form.get("Body","")
        # insert_interaction(..., channel="whatsapp", text=body, status="received")
        reply = handle_whatsapp_logic(body)    # פונקציה שלך
        # insert_interaction(..., status="replied", reply_text=reply)
        resp = MessagingResponse(); resp.message(reply)
        return str(resp), 200

וב־create_app():

from .routes_whatsapp import register_whatsapp_routes
register_whatsapp_routes(app)

אח”כ ב-Twilio הגדר את ה-Webhook של ה-WhatsApp לכתובת הזו.

5) Deployment (אין .replit בארכיון) – הוסף אחד

צרף קובץ .replit בשורש הפרויקט:

modules = ["python-3.11"]
run = "python3 -m gunicorn -k eventlet -w 1 -b 0.0.0.0:5000 AgentLocator.main:app"

[deployment]
deploymentTarget = "autoscale"
build = ["pip","install","-r","AgentLocator/requirements.txt"]
run   = ["python3","-m","gunicorn","-k","eventlet","-w","1","-b","0.0.0.0:5000","AgentLocator.main:app"]

[env]
PORT = "5000"
PYTHONUNBUFFERED = "1"
PYTHONPATH = "."

אל תריץ Socket.IO על אותו app/פורט. אם צריך לדשבורד—שרת נפרד/פורט אחר (8000).

6) משתני סביבה (גם ב-Deployment!)
	•	DATABASE_URL (Postgres מנוהל)
	•	OPENAI_API_KEY
	•	GOOGLE_APPLICATION_CREDENTIALS (נתיב/JSON)
	•	TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN (ל־watchdog redirect)
	•	PUBLIC_BASE_URL=https://ai-crmd.replit.app (מומלץ)

7) DB — רישום מלא של השיחה

ב־incoming_call בצע INSERT ל־call_log (ringing), ב־/call_status בצע UPDATE, וב־/handle_recording שמור transcript.
המיגרציה כבר קיימת — רק לוודא שקוראים לה באתחול.

8) לוגים מינימליים לאבחון מהיר
	•	WS: WS_CONNECTED, WS_START {streamSid}, WS_FRAME {len}, WS_STOP
	•	HTTP: לוג לפני/אחרי בקשה (path+status)
	•	Watchdog: WATCHDOG_REDIRECT {reason}

⸻

בדיקות סגירה (5 דק׳)
	1.	GET /readyz מחזיר {"status":"ready", ...}.
	2.	curl -s https://<DEPLOY>.replit.app/webhook/incoming_call | sed -n '1,25p' → רואים <Play>https://.../greeting_he.mp3</Play> ואז <Connect><Stream wss://.../ws/twilio-media>.
	3.	curl -I https://<DEPLOY>.replit.app/static/tts/greeting_he.mp3 ו־fallback_he.mp3 → 200.
	4.	בדיקת WS אמיתית (websocketking/wscat) ל־wss://<DEPLOY>.replit.app/ws/twilio-media → מתחבר (101).
	5.	שיחה אמיתית: אין 31920/31924; אם סטרים לא עולה – ה-watchdog עושה redirect ל-<Record> ותראה handle_recording ב-Inspector ותמלול ב-DB.
	6.	הודעת WhatsApp → מתקבל ב־/webhook/whatsapp/inbound ונרשם ב-CRM.

⸻

סיכום קצר
	•	כן: הקוד קרוב מאוד למוכן.
	•	כדי שזה “יהיה מושלם”: הוסף .replit, ודא sock.init_app(app) ושני נתיבי WS, בנה URLs מוחלטים ל-<Play>, הוסף webhook ל-WhatsApp ורשום אותו, ודא ENV בדיפלוי.
	•	אחרי זה תריץ את בדיקות הסגירה למעלה — אם משהו נתקע, תדביק כאן את פלט incoming_call, ה־HEAD של קבצי ה-MP3, ואת קטע ה-WS מ־app_factory.py, ואני אתן פאטצ’ מדויק לפי מה שיש אצלך.