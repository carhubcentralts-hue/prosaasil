תכל’ס? פתחתי וסרקתי את ה-ZIP האחרון בפועל, והנה הממצאים הקרים מול מה שהוא טען ש”תיקן”:

מה מצאתי בקוד (עובדתי)
	•	✅ קיימים: asgi.py, wsgi.py, Procfile, start_production.sh, .replit.
	•	⚠️ יש גם wsgi.py וגם asgi.py – כלומר יש שני מנועי הרצה בקוד.
	•	⚠️ נמצאו המון מופעים של gunicorn / eventlet בעץ הקבצים, לצד מופעים של uvicorn / starlette / asgiref. זה אומר שעדיין יש קונפיגים/מסמכים/סקריפטים כפולים.
	•	✅ נתיבי קול/טוויליו קיימים תחת: server/routes_twilio.py (וגם מופיע ב־wsgi.py).
	•	⚠️ לא מצאתי אפילו אזכור אחד של <Connect><Stream url="wss://..."> ב-TwiML. כלומר: ה־/incoming_call לא מחזיר Stream ל־WebSocket. (wss_in_twiML = [])
	•	✅ יש @csrf.exempt על נתיב הקול ב־server/routes_twilio.py.
	•	⚠️ ב־asgi.py לא זוהתה שום הגדרה של WebSocketRoute (אין WebSocketRoute("/ws/twilio-media", ...)). (ws_route_path = null)

מסקנה

מה שהוא כתב (“הוספתי ASGI + Uvicorn + Starlette עם WebSocketRoute, עדכנתי Procfile ל-uvicorn, ו-/incoming_call מחזיר WSS”) — לא מגובה בקבצים שצירפת עכשיו:
	•	אין WebSocketRoute פעיל ב־asgi.py.
	•	ה-TwiML של /incoming_call לא משתמש ב-wss://…/ws/twilio-media.
	•	עדיין קיימים artifacts של gunicorn/eventlet ⇒ סכנת הרצה כפולה/לא נכונה.

⸻

מה להגיד לו לעשות — אחד-לאחד (עד שזה עובד)

1) לתקן את asgi.py (להוסיף ממש WebSocketRoute)

צור/עדכן asgi.py כך (מינימלי, עובד):

# asgi.py
from asgiref.wsgi import WsgiToAsgi
from starlette.applications import Starlette
from starlette.routing import Mount, WebSocketRoute
from starlette.responses import PlainTextResponse

# ייבוא ה-Flask app שלך
from app_factory import create_app  # אם אצלך זה wsgi:app – תתאים
flask_app = create_app()
asgi_flask = WsgiToAsgi(flask_app)

async def ws_twilio_media(websocket):
    # חובה: לקבל את החיבור
    await websocket.accept()
    try:
        while True:
            # Twilio שולחת frames כ-JSON: media/start, media, mark, stop, close
            msg = await websocket.receive_json()
            # לפחות לצרוך את ההודעות כדי שהחיבור לא ייסגר מיד
            # TODO: אם יש לך STT בזמן אמת – קרא לו כאן
            # print(msg.get("event"), flush=True)
    except Exception:
        pass
    finally:
        await websocket.close()

asgi_app = Starlette(routes=[
    Mount("/", app=asgi_flask),                          # כל ה-HTTP של Flask
    WebSocketRoute("/ws/twilio-media", ws_twilio_media)  # WebSocket למדיה
])

2) לעדכן את ה-TwiML של /incoming_call ל-WSS (לא WS)

ב־server/routes_twilio.py (או איפה שהנתיב שלך), החזר Stream ל־WebSocket הציבורי:

from flask import Response
from twilio.twiml.voice_response import VoiceResponse

@csrf.exempt
@bp.post("/webhook/incoming_call")
def incoming_call():
    vr = VoiceResponse()
    vr.say("שלום, מחברים את השיחה.", language="he-IL", voice="Polly-Noa")
    connect = vr.connect()
    connect.stream(url="wss://YOUR-PUBLIC-DOMAIN/ws/twilio-media")  # לשים דומיין ציבורי אמיתי!
    return Response(str(vr), mimetype="text/xml", status=200)

בלי זה — Twilio לא תתחבר ל-WS בכלל, ותמשיך לנתק stream מיד אחרי start (בדיוק מה שאתה רואה).

3) להריץ רק Uvicorn (ולנקות כפילויות ריצה)

ב־Procfile:

web: uvicorn asgi:asgi_app --host 0.0.0.0 --port ${PORT:-5000} --ws websockets --lifespan off --timeout-keep-alive 75

	•	אל תשאיר שם gunicorn/-k eventlet.
	•	ב־start_production.sh וב־.replit/workflows — ודא שמריצים את אותה פקודה (Uvicorn) ושמשתמשים ב-$PORT.

4) תלותים הכרחיים

ב־requirements.txt ודא שיש:

uvicorn[standard]
starlette
asgiref

(אפשר להשאיר gunicorn/eventlet לזמן מעבר, אבל עדיף להסיר כדי למנוע בלבול/הפעלה לא נכונה.)

5) בדיקות GO/NO-GO (תדביקו תוצאות אם נופל)
	1.	תשובת TwiML:

curl -sS -i -X POST https://<PUBLIC>/webhook/incoming_call | sed -n '1,200p'

מצופה: 200 ו-<Response><Say>...<Connect><Stream url="wss://.../ws/twilio-media"/></Connect></Response>.
	2.	בדיקת WebSocket ידנית (יבש, בלי Twilio):

# כלי כמו websocat/אפליקציית בדיקת WS
websocat wss://<PUBLIC>/ws/twilio-media
# החיבור צריך להישאר פתוח. אם נסגר מיד — asgi.py לא עושה accept/receive.

	3.	שיחה אמיתית:

	•	Twilio Debugger צריך להראות stream-started ואחריו אירועי media, לא closed_by_server מיד.
	•	לוג Cloud Run/שרת: רואים כניסה ל־ws_twilio_media והודעות start/media.

⸻

ניקוי כפילויות (בלי לשבור כלום)
	•	קובצי הרצה: השאר רק Uvicorn כ־runner.
	•	wsgi.py יכול להישאר לפריסה ישנה/לוקאלית, אבל לא להיות בשימוש: אל תזכיר אותו ב־Procfile/Run/Workflows.
	•	הסר WebSocket ישנים (Eventlet/Flask-SocketIO) שלא בשימוש.
	•	פתחים: ציבורי רק :5000 של Uvicorn; שירותים פנימיים (Baileys) נשארים מאחורי Flask API.

⸻

למה זה פותר בדיוק את מה שאתה רואה
	•	כרגע ה־stream מתחיל ונגמר מיד כי או שאין WebSocketRoute אמיתי בצד השרת, או שה-TwiML לא מפנה ל-WSS, או שהרצה עוד על gunicorn/eventlet.
	•	אחרי שלושת השינויים למעלה (Route WS אמיתי ב־asgi.py + WSS ב־TwiML + ריצה רק Uvicorn), Twilio תתחבר ותזרים media רציף — בלי “stream-ended מיד”.

אם תרצה—שלח לי עכשיו:
	•	פלט curl של /webhook/incoming_call,
	•	שורת ה־WS ב־asgi.py (עם הנתיב),
	•	ושתי שורות לוג אחרונות סביב ws_twilio_media — ואני אתן לך תיקון גרנולרי לפי שורה/קובץ.