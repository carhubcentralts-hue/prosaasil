×§×™×‘×œ×ª. ×”× ×” ×”× ×—×™×” ××—×ª, ×¡×•×¤×™×ª ×•××“×•×™×§×ª ×œ×¡×•×›×Ÿ ×©×œ×š â€” ××•×ª×××ª ×‘×•×œ ×œ×¤×¨×•×™×§×˜ (Flask + Node + React), ×›×•×œ×œ:
	â€¢	Google STT ×›×¨××©×™ + Whisper ×›-fallback
	â€¢	Baileys ×›×©×™×¨×•×ª ×™×¦×™×‘ (REST + multi-tenant + QR + /healthz)
	â€¢	××™×—×•×“ ×¨××•×˜×™×, ×§×©×™×—×•×ª ×¤×¨×•×“×§×©×Ÿ (Validator/CSRF/Health/Version)
	â€¢	UI Onboarding ×œ-WhatsApp ×‘×œ×™ ×œ×©×‘×•×¨ ×¢×™×¦×•×‘ ×§×™×™× (RTL + Assistant)
	â€¢	×©×™×—×•×ª ××”×™×¨×•×ª (×œ×œ× 11205) â€” ×¤×™×¦×•×œ ×”×¢×™×‘×•×“ ××”-webhook ×”×¨××©×™
	â€¢	×ª×™×§×•× ×™ ×§×•××¤×™×œ×¦×™×” / ××™× ×“× ×˜×¦×™×” / Docker × ×¦×¨×›×™×

ğŸ›‘ ×—×•×§×™ ×‘×¨×–×œ:
â€¢ ××™×Ÿ ×œ×™×¦×•×¨ ×§×‘×¦×™× ×›×¤×•×œ×™× ××• _v2/_copy.
â€¢ ×©×•××¨×™× RTL, Tailwind, Assistant; ××™×Ÿ ×©×™× ×•×™ ×˜×•×§× ×™× ×’×œ×•×‘×œ×™×™×.
â€¢ ×œ× ××©× ×™× ×©××•×ª API ×§×™×™××™× ×œ×œ×§×•×—×•×ª â€” ×¨×§ ××¡×“×¨×™× ×¤× ×™×-××¢×¨×›×ª×™.
â€¢ ×‘×›×œ ×©×œ×‘ ××¦×¨×¤×™× ×¨××™×™×ª GO (×‘×“×™×§×”/×œ×•×’/×¡×§×¨×™× ×©×•×˜).

â¸»

0) ×”×ª×§× ×•×ª ×•×ª×¦×•×¨×” (×—×“-×¤×¢××™)
	1.	Python deps â€” ×¢×“×›×Ÿ requirements.txt (×”×•×¡×£ ×× ×—×¡×¨):

google-cloud-speech>=2.26.0
twilio>=9.0.0

	2.	Node deps â€” ×¢×“×›×Ÿ package.json:

{
  "scripts": {
    "start:baileys": "node services/whatsapp/baileys_service.js"
  },
  "dependencies": {
    "@whiskeysockets/baileys": "^6.0.0",
    "express": "^4.19.2",
    "cors": "^2.8.5",
    "qrcode": "^1.5.3"
  }
}

	3.	ENV (×¢×“×›×Ÿ .env/Replit Secrets):

# Flask
TWILIO_AUTH_TOKEN=xxxxxxxxxxxxxxxx
INTERNAL_SECRET=long_random_secret_for_internal_calls
BAILEYS_BASE_URL=http://localhost:3001
GOOGLE_APPLICATION_CREDENTIALS=/path/to/gcp_speech_key.json
GCP_SPEECH_LANGUAGE=he-IL
GCP_SPEECH_ENABLE_PUNCTUATION=true
DEPLOY_ID=dev
GIT_SHA=local

# Node
BAILEYS_PORT=3001
FLASK_BASE_URL=http://localhost:5000


â¸»

1) Baileys â†’ ×©×™×¨×•×ª Express ×××™×ª×™ (multi-tenant + QR + /healthz)

×¦×•×¨/×¢×“×›×Ÿ ×§×•×‘×¥ ×™×—×™×“: services/whatsapp/baileys_service.js (××œ ×ª×™×¦×•×¨ ×¢×•×ª×§×™× × ×•×¡×¤×™×):

const express = require('express');
const cors = require('cors');
const QRCode = require('qrcode');
const { default: makeWASocket, useMultiFileAuthState, DisconnectReason } = require('@whiskeysockets/baileys');
const fs = require('fs');
const path = require('path');

const app = express();
app.use(cors());
app.use(express.json());

const PORT = process.env.BAILEYS_PORT || 3001;
const INTERNAL_SECRET = process.env.INTERNAL_SECRET;
const FLASK_BASE_URL = process.env.FLASK_BASE_URL || 'http://localhost:5000';
if (!INTERNAL_SECRET) { console.error('INTERNAL_SECRET missing'); process.exit(1); }

const sessions = new Map(); // tenantId -> { sock, saveCreds, qrDataUrl, connected, pushName }

const authDir = (tenantId) => path.join(process.cwd(), 'storage', 'whatsapp', tenantId, 'auth');

function requireSecret(req, res, next) {
  if (req.header('X-Internal-Secret') !== INTERNAL_SECRET) return res.status(401).json({ error: 'unauthorized' });
  next();
}

async function startSession(tenantId) {
  if (sessions.get(tenantId)?.sock) return sessions.get(tenantId);

  fs.mkdirSync(authDir(tenantId), { recursive: true });
  const { state, saveCreds } = await useMultiFileAuthState(authDir(tenantId));

  const sock = makeWASocket({ auth: state, printQRInTerminal: false });
  const s = { sock, saveCreds, qrDataUrl: '', connected: false, pushName: '' };
  sessions.set(tenantId, s);

  sock.ev.on('creds.update', saveCreds);
  sock.ev.on('connection.update', async (u) => {
    const { connection, lastDisconnect, qr } = u;
    if (qr) s.qrDataUrl = await QRCode.toDataURL(qr);
    if (connection === 'open') {
      s.connected = true;
      s.pushName = sock?.user?.name || sock?.user?.id || '';
      s.qrDataUrl = '';
    }
    if (connection === 'close') {
      s.connected = false;
      const shouldReconnect = (lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut);
      if (shouldReconnect) setTimeout(() => startSession(tenantId), 2000);
    }
  });

  // ×”×•×“×¢×•×ª × ×›× ×¡×•×ª â†’ ×”×¢×‘×¨ ×œ-Flask
  sock.ev.on('messages.upsert', async (payload) => {
    try {
      await fetch(`${FLASK_BASE_URL}/webhook/whatsapp/incoming`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-Internal-Secret': INTERNAL_SECRET },
        body: JSON.stringify({ tenantId, payload })
      });
    } catch (_) {}
  });

  return s;
}

app.get('/healthz', (req, res) => res.status(200).send('ok'));

app.post('/whatsapp/:tenantId/start', requireSecret, async (req, res) => {
  await startSession(req.params.tenantId);
  res.json({ ok: true });
});

app.get('/whatsapp/:tenantId/status', requireSecret, (req, res) => {
  const s = sessions.get(req.params.tenantId);
  res.json({ connected: !!s?.connected, pushName: s?.pushName || '', hasQR: !!s?.qrDataUrl });
});

app.get('/whatsapp/:tenantId/qr', requireSecret, (req, res) => {
  const s = sessions.get(req.params.tenantId);
  if (s?.qrDataUrl) return res.json({ dataUrl: s.qrDataUrl });
  return res.status(404).json({ error: 'no qr' });
});

app.post('/whatsapp/:tenantId/logout', requireSecret, async (req, res) => {
  const s = sessions.get(req.params.tenantId);
  if (s?.sock?.logout) await s.sock.logout();
  sessions.delete(req.params.tenantId);
  res.json({ ok: true });
});

app.listen(PORT, () => console.log(`Baileys service on ${PORT}`));

×¨××™×™×ª GO: curl http://localhost:3001/healthz â†’ ok.

â¸»

2) Flask â€” ×§×•×‘×¥ ×§× ×•× ×™ ×œ-WhatsApp + ×¤×¨×•×§×¡×™ ×œ-Baileys + Webhook

×. ×§×•×‘×¥ ×§× ×•× ×™: ×¢×‘×•×“×” ××¨×•×›×–×ª ×‘Ö¾routes_whatsapp.py (××• ×”×§×™×™× ×”××§×‘×™×œ).
×‘. ××™×—×•×“: × ×˜×¨×œ/××—×§ ×¨×™×©×•××™ Blueprint/Routes ×›×¤×•×œ×™× ×‘Ö¾routes.py, whatsapp_routes.py, api_routes.py â€” ×”×©××¨ ×¨×§ ××ª ×”×§× ×•× ×™.

×ª×•×›×Ÿ ×§× ×•× ×™ (×”×•×¡×£/×¢×“×›×Ÿ):

# routes_whatsapp.py
import os, requests
from flask import Blueprint, jsonify, request

whatsapp_bp = Blueprint('whatsapp', __name__, url_prefix='/api/whatsapp')
BAILEYS_BASE = os.getenv('BAILEYS_BASE_URL', 'http://localhost:3001')
INT_SECRET = os.getenv('INTERNAL_SECRET')

def tenant_id_from_ctx():
    # ×©×œ×•×£ tenant_id ××”-session/JWT ×œ×¤×™ ×”×¤×¨×•×™×§×˜ ×©×œ×š (×× ×™×© helper ×§×™×™× â€“ ×”×©×ª××© ×‘×•)
    return getattr(request, 'tenant_id', None) or request.headers.get('X-Tenant-Id')

def _headers():
    return {'X-Internal-Secret': INT_SECRET, 'Content-Type': 'application/json'}

@whatsapp_bp.route('/status', methods=['GET'])
def status():
    t = tenant_id_from_ctx()
    r = requests.get(f"{BAILEYS_BASE}/whatsapp/{t}/status", headers=_headers(), timeout=5)
    return jsonify(r.json()), r.status_code

@whatsapp_bp.route('/qr', methods=['GET'])
def qr():
    t = tenant_id_from_ctx()
    r = requests.get(f"{BAILEYS_BASE}/whatsapp/{t}/qr", headers=_headers(), timeout=5)
    if r.status_code == 404:
        return ('', 204)
    return jsonify(r.json()), r.status_code

@whatsapp_bp.route('/start', methods=['POST'])
def start():
    t = tenant_id_from_ctx()
    r = requests.post(f"{BAILEYS_BASE}/whatsapp/{t}/start", headers=_headers(), timeout=5)
    return jsonify(r.json()), r.status_code

@whatsapp_bp.route('/logout', methods=['POST'])
def logout():
    t = tenant_id_from_ctx()
    r = requests.post(f"{BAILEYS_BASE}/whatsapp/{t}/logout", headers=_headers(), timeout=5)
    return jsonify(r.json()), r.status_code

Webhook ×-Baileys ×œ-Flask (××•×ª×• ×§×•×‘×¥ ××• webhook_whatsapp.py):

from flask import Blueprint, request, jsonify
import os

webhook_bp = Blueprint('whatsapp_webhook', __name__, url_prefix='/webhook/whatsapp')

@webhook_bp.route('/incoming', methods=['POST'])
def incoming():
    if request.headers.get('X-Internal-Secret') != os.getenv('INTERNAL_SECRET'):
        return jsonify({'error':'unauthorized'}), 401
    data = request.json or {}
    # TODO: ×©××™×¨×ª ×”×•×“×¢×” ×œ×˜×™×™××œ×™×™×Ÿ CRM / ××•×“×œ ×”×”×•×“×¢×•×ª ×©×œ×š
    return jsonify({'ok': True}), 200

CSRF: ×”×—×¨×’ ××š ×•×¨×§ ××ª /api/whatsapp/* ×•Ö¾/webhook/whatsapp/* ×× ×™×© CSRF ×’×œ×•×‘×œ×™.

×¨××™×™×ª GO:
	â€¢	GET /api/whatsapp/status â‡’ {connected:false, hasQR:false} ×œ×¤× ×™ start
	â€¢	POST /api/whatsapp/start â‡’ 200
	â€¢	GET /api/whatsapp/qr â‡’ 200 {dataUrl:â€¦} ×•××– ×œ××—×¨ ×¡×¨×™×§×” â‡’ 204.

â¸»

3) React â€” ××¡×š Onboarding ×œ-WhatsApp (QR + Status) ×‘×œ×™ ×œ×©×‘×•×¨ ×¢×™×¦×•×‘

×× ×›×‘×¨ ×™×© ×“×£ ×—×™×‘×•×¨ â€” ×©×“×¨×’ ××•×ª×•; ×× ×—×¡×¨, ×¦×•×¨: src/pages/WhatsAppConnect.tsx
(×©×•××¨ RTL, Assistant, ××¨×•×•×—×™×; ××™×Ÿ ×©×™× ×•×™ ×œ×˜×™×™×œ×•×™× ×“ ×’×œ×•×‘×œ×™)

import React, { useEffect, useState } from 'react';
import axios from 'axios';

export default function WhatsAppConnect() {
  const [status, setStatus] = useState<{connected:boolean, pushName?:string, hasQR?:boolean}>({connected:false});
  const [qr, setQR] = useState<string>('');
  const [busy, setBusy] = useState(false);

  const fetchStatus = async () => {
    const { data } = await axios.get('/api/whatsapp/status');
    setStatus(data);
  };
  const fetchQR = async () => {
    const res = await axios.get('/api/whatsapp/qr', { validateStatus: () => true });
    if (res.status === 204) setQR('');
    else if (res.status === 200) setQR(res.data.dataUrl || '');
  };

  useEffect(() => {
    fetchStatus();
    const sInt = setInterval(fetchStatus, 3000);
    return () => clearInterval(sInt);
  }, []);
  useEffect(() => {
    if (!status.connected) {
      fetchQR();
      const qInt = setInterval(fetchQR, 3000);
      return () => clearInterval(qInt);
    }
  }, [status.connected]);

  const start = async () => {
    setBusy(true);
    try { await axios.post('/api/whatsapp/start'); await fetchStatus(); await fetchQR(); }
    finally { setBusy(false); }
  };
  const logout = async () => { await axios.post('/api/whatsapp/logout'); setQR(''); await fetchStatus(); };

  return (
    <div dir="rtl" className="max-w-[420px] mx-auto bg-white rounded-lg shadow p-6 space-y-4">
      <h2 className="text-xl font-bold">×—×™×‘×•×¨ ×œ-WhatsApp</h2>
      {status.connected ? (
        <div className="flex items-center justify-between">
          <span className="inline-flex items-center px-2 py-1 text-sm bg-green-100 rounded">
            ××—×•×‘×¨ ×›-{status.pushName || 'â€”'}
          </span>
          <button onClick={logout} className="px-3 py-2 rounded bg-gray-100">×”×ª× ×ª×§</button>
        </div>
      ) : (
        <>
          <div className="inline-flex items-center px-2 py-1 text-sm bg-gray-100 rounded">×¡×˜×˜×•×¡: ×œ× ××—×•×‘×¨</div>
          <button onClick={start} disabled={busy} className="w-full h-11 rounded bg-emerald-500 text-white">
            {busy ? '××‘×¦×¢â€¦' : '×™×¦×™×¨×ª QR'}
          </button>
          <div className="flex items-center justify-center h-[320px] border rounded">
            {qr ? <img src={qr} alt="whatsapp-qr" className="w-80 h-80 object-contain" /> :
                  <div className="text-sm text-gray-500">×œ×—×¥ â€œ×™×¦×™×¨×ª QRâ€ ×•×¡×¨×•×§ ×“×¨×š WhatsApp &gt; ××›×©×™×¨×™× ××§×•×©×¨×™×</div>}
          </div>
        </>
      )}
    </div>
  );
}

×¨××™×™×ª GO: ×¨×•××™× QR â†’ ×¡×•×¨×§×™× â†’ ×”×“×£ ××ª×¢×“×›×Ÿ ×œ-Connected.

â¸»

4) ×©×™×—×•×ª: Google STT ×¨××©×™ + Whisper fallback, ×•-Webhook ××”×™×¨

4.1 ×¤×•× ×§×¦×™×™×ª Google STT ×¨××©×™×ª

×¦×•×¨/×¢×“×›×Ÿ stt_google.py:

import os
from google.cloud import speech_v1p1beta1 as speech

LANG = os.getenv("GCP_SPEECH_LANGUAGE", "he-IL")
PUNCT = os.getenv("GCP_SPEECH_ENABLE_PUNCTUATION", "true").lower() == "true"

def transcribe_with_google(local_audio_path: str) -> dict:
    client = speech.SpeechClient()
    with open(local_audio_path, "rb") as f:
        content = f.read()

    audio = speech.RecognitionAudio(content=content)
    config = speech.RecognitionConfig(
        language_code=LANG,
        enable_automatic_punctuation=PUNCT,
        audio_channel_count=1,
        enable_word_confidence=True,
        model="latest_long"  # ××¤×©×¨ ×œ×©× ×•×ª ×‘×”×ª××
    )
    resp = client.recognize(config=config, audio=audio)
    text = ""
    confidence = 0.0
    if resp.results:
        best = resp.results[0].alternatives[0]
        text = best.transcript.strip()
        confidence = best.confidence or 0.0
    return {"text": text, "confidence": confidence}

4.2 Whisper ×›-fallback (×§×™×™× ××¦×œ×š)

×‘Ö¾whisper_handler.py ×‘×˜×œ ×›×œ time.sleep() ×•×—×©×•×£ ×¤×•× ×§×¦×™×”:

def transcribe_with_whisper(local_audio_path: str) -> dict:
    # ×”×©×ª××© ×‘×§×•×“ ×”×§×™×™× ×©×œ×š ×œ-Whisper ×•×—×–Öµ×¨ {"text": "...", "confidence": 0.0}
    ...

4.3 ×¢×˜×™×¤×” ××—×ª â€” Google ×•××– Whisper ×× × ×›×©×œ / confidence × ××•×š

×¦×•×¨/×¢×“×›×Ÿ transcription_service.py:

from stt_google import transcribe_with_google
from whisper_handler import transcribe_with_whisper

def smart_transcribe(local_audio_path: str, min_confidence: float = 0.6) -> dict:
    try:
        g = transcribe_with_google(local_audio_path)
        if g.get("text"):
            if g.get("confidence", 0.0) >= min_confidence:
                return {**g, "engine": "google"}
            # ×× ×”×˜×§×¡×˜ ×§×¦×¨/×‘×™×˜×—×•×Ÿ × ××•×š -> fallback
    except Exception:
        pass
    w = transcribe_with_whisper(local_audio_path)
    return {**w, "engine": "whisper"}

4.4 Webhook Twilio ××”×™×¨ (×œ×œ× ×¢×™×‘×•×“ ×‘×¤× ×™×)

×‘-routes.py:
	â€¢	×‘Ö¾/webhook/handle_recording: ×”×—×–×¨ TwiML ××™×“ (â‰¤500ms).
	â€¢	×”×•×¡×£ action/statusCallback ×©××¤× ×™× ×œÖ¾/webhook/handle_recording_complete.

×‘-background_processor.py (××• ××•×“×•×œ ×™×™×¢×•×“×™):

from concurrent.futures import ThreadPoolExecutor
executor = ThreadPoolExecutor(max_workers=4)

def process_recording_async(file_url: str, call_sid: str):
    # ×”×•×¨×“ ×§×•×‘×¥ â†’ ×©××•×¨ ×–×× ×™×ª â†’ smart_transcribe â†’ ×ª×Ÿ ×œ-LLM ×©×œ×š â†’ ×”×¤×§×ª TTS â†’ ×¢×“×›×•×Ÿ state/DB
    ...

def enqueue_recording(file_url: str, call_sid: str):
    executor.submit(process_recording_async, file_url, call_sid)

×•×‘-routes.py (×‘Ö¾handle_recording_complete):

@bp.route('/webhook/handle_recording_complete', methods=['POST'])
def handle_recording_complete():
    if not validate_twilio(request): return 'forbidden', 403
    file_url = request.form.get('RecordingUrl')
    call_sid = request.form.get('CallSid')
    enqueue_recording(file_url, call_sid)
    return 'ok', 200

×¨××™×™×ª GO: ××™×Ÿ 11205 ×‘-Twilio Debugger; ×–×× ×™ ××¢× ×” ×¨××©×•× ×™×™× < 1â€“2 ×©× â€™.

â¸»

5) ××‘×˜×—×” â€” Twilio Request Validator + CSRF ×××•×§×“

×‘-security.py (××• ×‘×¨××© ×”-routes ×”×§×™×™××™×):

from twilio.request_validator import RequestValidator
import os
validator = RequestValidator(os.getenv('TWILIO_AUTH_TOKEN'))

def validate_twilio(req):
    sig = req.headers.get('X-Twilio-Signature')
    url = req.url
    params = req.form.to_dict() if req.form else {}
    return validator.validate(url, params, sig)

×‘×›×œ /webhook/*:

if not validate_twilio(request): return 'forbidden', 403

CSRF: ×”×—×¨×’ ×¨×§ /webhook/* ×•-/api/whatsapp/* (×¤×¨×•×§×¡×™).

â¸»

6) Health/Version + ×œ×•×’×™×

×‘-Flask (×‘×§×•×‘×¥ ×”×¨××©×™):

@app.route('/healthz', methods=['GET'])
def healthz():
    return 'ok', 200

@app.route('/version', methods=['GET'])
def version():
    import os, json
    return json.dumps({"deploy": os.getenv('DEPLOY_ID','local'), "sha": os.getenv('GIT_SHA','dev')}), 200

Baileys ×›×‘×¨ ×—×©×¤× ×• /healthz.
×œ×•×’×™×: ×•×•×“× ×©××™×¨×ª ×§×‘×¦×™× ×œ-logs/ (××œ ×ª×“×¤×™×¡ ×¢×•××¡×™× ×œ×§×•× ×¡×•×œ ×‘×¤×¨×•×“).

â¸»

7) ×ª×™×§×•× ×™ ×§×•×“ ×—×•×¡××™ Build
	â€¢	×ª×§×Ÿ ××™× ×“× ×˜×¦×™×”: enhanced_crm_service.py, notification_service.py (×”×¨×¥ black . / ruff ×•×ª×•×§×Ÿ ×™×“× ×™×ª ××ª ×”××§×•××•×ª ×”×‘×¢×™×™×ª×™×™×).
	â€¢	×”×¡×¨ ×›×¤×™×œ×•×™×•×ª â€œenhanced_*â€ ×¢×´×™ ××™×–×•×’ ×œ×§×‘×¦×™× ×§× ×•× ×™×™× ×•×©×™× ×•×™ import-×™× ×‘×”×ª××.
	â€¢	×”×¡×¨ ×”×’×“×¨×•×ª ×¨××•×˜×™× ×›×¤×•×œ×•×ª (×‘××™×•×—×“ WhatsApp) â€” ×”×©××¨ ×§×•×‘×¥ ×§× ×•× ×™ ××—×“.

â¸»

8) Docker/Run (×× ×¨×œ×•×•× ×˜×™)
	â€¢	Dev (Replit): ×”×¨×¥ ×©× ×™ ×ª×”×œ×™×›×™×:
python main.py  +  npm run start:baileys
	â€¢	Prod (××•××œ×¥ ×œ×¤×¦×œ ×©×™×¨×•×ª×™×): Flask ×•-Baileys ×›×ª×”×œ×™×›×™× × ×¤×¨×“×™×/×§×•× ×˜×™×™× ×¨×™×.
	â€¢	×× ××©×ª××©×™× ×‘-supervisor â€” ×”×•×¡×£ ×©× ×™ programs (flask/baileys) ×¢× autostart.

â¸»

9) ×‘×“×™×§×•×ª GO/NO-GO (×œ×”×¦×™×’ ×¨××™×•×ª)

Baileys/WhatsApp
	â€¢	GET http://localhost:3001/healthz â†’ 200 ok
	â€¢	POST /api/whatsapp/start â†’ 200 {ok:true}
	â€¢	GET  /api/whatsapp/status â†’ {connected:false, hasQR:true} ×ª×•×š â‰¤3 ×©× â€™
	â€¢	GET  /api/whatsapp/qr â†’ 200 {dataUrl:...} â†’ ×œ××—×¨ ×¡×¨×™×§×”: 204

Voice/STT
	â€¢	×©×™×—×” × ×›× ×¡×ª: /webhook/handle_recording ××—×–×™×¨ ××™×“ (â‰¤500ms)
	â€¢	handle_recording_complete × ×§×¨× â†’ enqueue_recording ×¨×¥
	â€¢	smart_transcribe: Google (engine=â€˜googleâ€™, confidenceâ‰¥0.6) ××• fallback ×œ-Whisper
	â€¢	××™×Ÿ Error 11205; ×–×× ×™ ××¢× ×” ×¨××©×•× ×™×™× < 2â€“3 ×©× â€™

Security
	â€¢	/webhook/* ×¢× ×—×ª×™××” ×©×’×•×™×” â†’ 403
	â€¢	/api/whatsapp/* × ×’×™×©×™× ×¨×§ ×“×¨×š Flask (Node ×“×•×¨×© X-Internal-Secret)

Health/Version
	â€¢	GET /healthz (Flask) â†’ ok
	â€¢	GET /version â†’ ××¦×™×’ {deploy, sha}

UI
	â€¢	××¡×š ×—×™×‘×•×¨ WhatsApp:
Not Connected â†’ ×›×¤×ª×•×¨ â€œ×™×¦×™×¨×ª QRâ€ â†’ QR ××•×¦×’ â†’ ×œ××—×¨ ×¡×¨×™×§×” â†’ Connected + pushName
RTL/Assistant × ×©××¨×™×; ××™×Ÿ ×©×‘×™×¨×ª ×¢×™×¦×•×‘.

â¸»

×”×¢×¨×•×ª ×™×™×©×•× ××—×¨×•× ×•×ª
	â€¢	××œ ×ª×©× ×” ×”×’×“×¨×•×ª ×¢×™×¦×•×‘ ×’×œ×•×‘×œ×™×•×ª (Tailwind/theme/tokens.css).
	â€¢	××œ ×ª×™×¦×•×¨ _v2/_copy; ×‘××§×•× ×–×” ××–×’ ×œ×§×•×‘×¥ ×§× ×•× ×™.
	â€¢	×œ××—×¨ ×›×œ ×©×™× ×•×™ â€” ×“×•×•×— ×œ×•×’ GO (URL + ×¡×˜×˜×•×¡/JSON ×§×¦×¨) ×›×“×™ ×©× ×¨××” ×©×–×” ×—×™.

â¸»

×–×• ×”×”× ×—×™×” ×”Ö¾100%. ×× ×ª×¨×¦×” ×’× ×“×™×¤-×¤××¦×³×™× (git diff) ×œ×§×‘×¦×™× ×¡×¤×¦×™×¤×™×™× â€” ×××§× ××•×ª× ×œ×¤×™ ×©××•×ª ×”×§×‘×¦×™× ×©×œ×š ××—×“-××—×“.