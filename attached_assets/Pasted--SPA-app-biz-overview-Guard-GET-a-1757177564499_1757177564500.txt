הבנתי את הסימפטום: לוחצים “התחזות לעסק”, ה-SPA נודד ל־/app/biz/overview, אבל ה-Guard מיד קורא GET /api/auth/me ומקבל 401, ולכן מפנה חזרה ל־/login. זה כמעט תמיד אומר: קוקית ההתחזות לא נשמרה/לא נשלחת, או שה-/me לא מכבד מצב התחזות.

תן למפתח את זה (באנגלית), אחד-לאחד:

⸻

Fix “Impersonate business” → redirects to /login (cookie/session not sticking)

TL;DR

You’re navigating to /app/biz/overview before the server-side impersonation state is actually visible to the client. Either the Set-Cookie from POST /impersonate is being ignored (flags/mode), or /api/auth/me doesn’t honor the impersonation session. Do the steps below.

⸻

1) Backend — make impersonation live in the same session

In POST /api/admin/businesses/:id/impersonate:
	•	After validating admin permission (and optional re-auth), switch the Flask session:
	•	session['original_user'] = current_admin_serialized
	•	session['user'] = tenant_user_serialized  // must include role: 'business' and tenant id
	•	session['tenant_id'] = tenant.id
	•	session['impersonating'] = True
	•	Do not redirect. Return 200 { ok:true, tenantUser, tenant }.

In POST /api/admin/impersonate/exit:
	•	Restore:
	•	session['user'] = session['original_user']
	•	session.pop('original_user', None)
	•	session.pop('tenant_id', None)
	•	session['impersonating'] = False
	•	Return 200 { ok:true }.

In GET /api/auth/me:
	•	If session.get('user') is present → return it (include role, tenant_id, and impersonating: bool(session.get('impersonating'))).
	•	Optionally set header X-Impersonating: 1 when impersonating.

Important: don’t check session['user_id'] in /me while login stores session['user']. Use one single key (session['user']) everywhere.

⸻

2) Backend — cookie flags per environment

If the impersonation (or session) cookie is set with flags that the browser rejects, the client will see 401 right after:
	•	Preview/local (HTTP):
	•	SESSION_COOKIE_SECURE = False
	•	SESSION_COOKIE_SAMESITE = 'Lax'
	•	Production (HTTPS):
	•	SESSION_COOKIE_SECURE = True
	•	SESSION_COOKIE_SAMESITE = 'Lax' (or 'None' only if truly cross-site)
	•	Always set Path=/. Do not set a mismatching Domain. Let the browser default (host-only) unless you really need subdomain sharing.

Symptom of wrong flags: Network shows Set-Cookie on the response, but a follow-up GET /api/auth/me still returns 401.

⸻

3) Frontend — call with credentials, then refetch /me before navigating

Make the impersonation handler central and always use it:

// pseudo
await api.post(`/api/admin/businesses/${id}/impersonate`, body, {
  credentials: 'include'
})
// IMPORTANT: wait until cookie is stored:
const me = await api.get('/api/auth/me', { credentials: 'include' })
if (me.ok && (me.data.impersonating || me.data.user?.role === 'business')) {
  navigate('/app/business/overview')
} else {
  toast.error('Impersonation failed'); return
}

Rules:
	•	All fetches to your API must use credentials: 'include'.
	•	Only navigate after /me returns 200 with the impersonated user.
	•	Show a global banner when me.impersonating === true with an “Exit impersonation” button that calls /api/admin/impersonate/exit, refetches /me, and sends you back to /app/admin/overview.

⸻

4) Role guards — accept the impersonated role

Your <RoleGuard> for business pages must pass when impersonating:
	•	If me.impersonating === true, treat me.user.role as 'business' (or whatever the impersonated user is).
	•	Don’t cache stale me—refetch after impersonation/exit.

⸻

5) 3 quick checks in the browser (DevTools)
	1.	Network → POST /impersonate:
	•	Response 200
	•	Has Set-Cookie (no Secure in HTTP preview; Path=/; SameSite=Lax).
	2.	Immediately GET /api/auth/me (same tab):
	•	Status 200
	•	JSON includes impersonating: true and user.role: 'business'.
	3.	Only then navigate to /app/biz/overview.

If (1) has Set-Cookie but (2) is 401 → flags/env mismatch or request didn’t include credentials.
If (2) is 200 but guard still kicks you to /login → your guard uses a stale store; ensure you await the /me refetch before navigating, and invalidate any cached me.

⸻

6) Common pitfalls to avoid
	•	Setting the cookie with Secure in HTTP preview → browser ignores it.
	•	SameSite=None without Secure → modern browsers reject.
	•	Using two different session keys (user_id vs user). Use only session['user'].
	•	Redirecting server-side after setting the cookie—FE navigates but the SPA fires /me before cookie is committed (rare, but avoid server redirects here).
	•	Different origin (port/host) between FE and API without proper credentials: and CORS.

⸻

7) (Optional) Tiny debug endpoint (dev-only)

Add GET /__whoami (dev) to print a safe snapshot of the session: { user, tenant_id, impersonating }. Never expose in prod.

⸻

Outcome
	•	“Impersonate” will switch the same session, /api/auth/me will reflect the impersonated user, the FE will await /me and then navigate, and the business guard will pass. No more bounce to /login.

אם אחרי זה עדיין נופל ל־/login—צלם לי:
	•	ה־Headers של POST /impersonate (בעיקר Set-Cookie)
	•	ה־Response של GET /api/auth/me מיד אחרי
	•	ה־RoleGuard/flow של הניווט (כדי לזהות קאש/רענון חסר)