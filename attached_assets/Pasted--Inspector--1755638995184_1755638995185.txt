מעולה—אין יותר שגיאות, אבל אתה שומע ברכה ואז “שקט” והמערכת לא מתמללת. לפי ה-Inspector שלך רואים:

* `incoming_call` → 200 עם `<Connect><Stream …>` ✅
* `greeting_he.mp3` → 200 ✅
* `stream_ended` → 200 **אחרי שהשיחה כבר כמעט מסתיימת** ❗
* לא מופיע `handle_recording` → ה־Fallback לא יצא לפועל כי כשה-`stream_ended` הגיע כבר לא הייתה שיחה פעילה, לכן Twilio לא יכול להריץ `<Record>` בדיעבד.

כלומר: **ה-WS כנראה לא נפתח / נסגר מיד**, ו־**ה-Fallback שלך תלוי ב־`stream_ended` שמגיע מאוחר מדי**, לכן אין תמלול ולא נכתב כלום ל־DB.

להלן פתרון קבוע, צעד-אחרי-צעד, מותאם לקוד שלך (AgentLocator/67) כדי שתמיד יהיה או סטרים פעיל או Fallback בזמן אמת—בלי לפספס שיחות.

---

# 1) ודא שהדיפלוי פעיל עם WS אמיתי

ב־Replit **Deployment** (או `.replit`):

**Build**

```
pip install -r AgentLocator/requirements.txt
```

**Run**

```
python3 -m gunicorn -k eventlet -w 1 -b 0.0.0.0:$PORT AgentLocator.main:app
```

> חובה `-k eventlet` כדי שה־WS יפתח; בלי זה יופיעו 31920/31924.

---

# 2) הוסף מסלול WS כפול (עם/בלי סלאש)

ב־`AgentLocator/server/app_factory.py` כבר קיים:

```python
@sock.route('/ws/twilio-media')
def twilio_media(ws): MediaStreamHandler(ws).run()
```

הוסף גם:

```python
@sock.route('/ws/twilio-media/')
def twilio_media_slash(ws): MediaStreamHandler(ws).run()
```

> זה מונע 404/Redirect בזמן Handshake (שגם מביא “שקט”).

---

# 3) הוסף “רישום סטרים” + Watchdog שמחיל Fallback **תוך כדי שיחה**

מטרה: אם ה־WS לא נפתח תוך X שניות (או נפתח אבל אין פריימים), **נבצע Redirect מיידי** דרך Twilio REST ל־`<Record>`—לא נחכה ל־`stream_ended`.

## 3.1 רישום מצב סטרים (פר-CallSid)

צור מודול קטן, למשל `AgentLocator/server/stream_state.py`:

```python
# AgentLocator/server/stream_state.py
import time, threading

class StreamRegistry:
    def __init__(self):
        self._lock = threading.Lock()
        self._state = {}  # call_sid -> {"started": bool, "last_media_at": float}

    def mark_start(self, call_sid):
        with self._lock:
            self._state.setdefault(call_sid, {})["started"] = True
            self._state[call_sid]["last_media_at"] = time.time()

    def touch_media(self, call_sid):
        with self._lock:
            self._state.setdefault(call_sid, {})["last_media_at"] = time.time()

    def get(self, call_sid):
        with self._lock:
            return dict(self._state.get(call_sid, {}))

    def clear(self, call_sid):
        with self._lock:
            self._state.pop(call_sid, None)

stream_registry = StreamRegistry()
```

## 3.2 Media WS: עדכן סטייט + לוגים

ב־`AgentLocator/server/media_ws.py` (בקלאס `MediaStreamHandler`):

```python
# הוספה למעלה
import json, time
from flask import current_app
from .stream_state import stream_registry

class MediaStreamHandler:
    def __init__(self, websocket):
        self.ws = websocket
        self.stream_sid = None
        self.call_sid = None  # אם אתה מקבל אותו כ-Parameter, שמור כאן
        current_app.logger.info("WS_CONNECTED")

    def run(self):
        try:
            while True:
                raw = self.ws.receive()
                if raw is None:
                    current_app.logger.info("WS_CLOSED"); break

                try:
                    data = json.loads(raw)
                except Exception:
                    current_app.logger.warning("WS_BAD_JSON"); continue

                ev = data.get("event")
                if ev == "start":
                    self.stream_sid = data["start"]["streamSid"]
                    # אם אתה שולח call_sid בפרמטרים, שלוף ושמור ב-self.call_sid
                    current_app.logger.info("WS_START", extra={"streamSid": self.stream_sid})
                    if self.call_sid:
                        stream_registry.mark_start(self.call_sid)

                elif ev == "media":
                    if self.call_sid:
                        stream_registry.touch_media(self.call_sid)
                    # כאן המשך לעבד payload → STT/תור/וכו'
                    # current_app.logger.debug("WS_FRAME", extra={"len": len(data.get("media",{}).get("payload",""))})

                elif ev == "stop":
                    current_app.logger.info("WS_STOP"); break

        except Exception:
            current_app.logger.exception("WS_HANDLER_ERROR")
        finally:
            if self.call_sid:
                stream_registry.clear(self.call_sid)
```

> חשוב: אל תשלח אף פעם `mark/clear` עם `streamSid` “מומצא”. השתמש **רק** בזה שקיבלת ב־`start`.

## 3.3 Watchdog: אם אין סטרים/מדיה → Redirect מיידי ל־Record

ב־`AgentLocator/server/routes_twilio.py`:

* ודא שיש לך משתני סביבה של Twilio REST:

  * `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`

* בתוך `incoming_call()`—מיד אחרי שאתה בונה TwiML ומחזיר אותו, הפעל Thread שיבדוק את הסטייט ויבצע Redirect אם צריך:

```python
import os, threading, time
from twilio.rest import Client
from .stream_state import stream_registry

def _redirect_to_record(call_sid, host):
    client = Client(os.environ["TWILIO_ACCOUNT_SID"], os.environ["TWILIO_AUTH_TOKEN"])
    # TwiML Fallback ישיר (לא תלוי stream_ended)
    twiml = f"""
<Response>
  <Record playBeep="false" timeout="4" maxLength="30" transcribe="false"
          action="/webhook/handle_recording" />
  <Play>https://{host}/static/tts/fallback_he.mp3</Play>
</Response>"""
    client.calls(call_sid).update(twiml=twiml)

def _watchdog(call_sid, host, start_timeout=8, no_media_timeout=6):
    # ממתין עד שהסטרים יתחיל
    time.sleep(start_timeout)
    st = stream_registry.get(call_sid)
    if not st.get("started"):
        current_app.logger.warning("WD_NO_STREAM_START", extra={"call_sid": call_sid})
        _redirect_to_record(call_sid, host); return

    # אם התחיל – נבדוק שיש מדיה
    last = st.get("last_media_at", 0)
    if time.time() - last > no_media_timeout:
        current_app.logger.warning("WD_NO_MEDIA", extra={"call_sid": call_sid})
        _redirect_to_record(call_sid, host); return

# בתוך incoming_call(), אחרי שמצאת/בנית host והחזרת TwiML:
host = (os.getenv("PUBLIC_HOST") or request.host).replace("https://","").replace("http://","")
threading.Thread(target=_watchdog, args=(call_sid, host), daemon=True).start()
```

> ככה ה־Fallback יקרה **בתוך השיחה** גם אם `stream_ended` יגיע מאוחר מדי.
> שים לב: צריך `TWILIO_ACCOUNT_SID/AUTH_TOKEN` ב־ENV של ה־Deployment.

---

# 4) ודא שה־TwiML תמיד משתמש ב־Host הנוכחי

עדיף לבנות את ה־URLs דינמית:

```python
host = os.getenv("PUBLIC_HOST") or request.host
wss_host = host.replace("https://","").replace("http://","")
twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Play>https://{wss_host}/static/tts/greeting_he.mp3</Play>
  <Connect action="/webhook/stream_ended">
    <Stream url="wss://{wss_host}/ws/twilio-media">
      <Parameter name="call_sid" value="{call_sid}"/>
    </Stream>
  </Connect>
</Response>"""
```

---

# 5) לוגים ברורים כדי לאבחן תוך שנייה

ב־`create_app()`:

```python
@app.before_request
def _req_log():
    current_app.logger.info("REQ", extra={"path": request.path, "method": request.method})

@app.after_request
def _res_log(resp):
    current_app.logger.info("RES", extra={"path": request.path, "status": resp.status_code})
    return resp
```

ב־WS כבר הוספנו `WS_CONNECTED/WS_START/WS_STOP` ועוד.

---

# 6) בדיקות קבלה (5 דק׳)

1. **TwiML**

   ```
   curl -s https://<deploy>.replit.app/webhook/incoming_call | sed -n '1,25p'
   ```

   רואה `<Connect><Stream wss://<deploy>.replit.app/ws/twilio-media>`.

2. **WS**
   פתח `wss://<deploy>.replit.app/ws/twilio-media` בבוחן WS—נפתח (101), לא רידיירקט/404.

3. **שיחה אמיתית**

   * לוגים: `WS_START` תוך 3–4 שנ׳, ואז `WS_FRAME`/`WD_NO_MEDIA`/`WD_NO_STREAM_START` (אם צריך).
   * אם אין סטרים/מדיה — ה־Watchdog יעשה Redirect ותראה `handle_recording` ב-Inspector, ויתווסף `transcript` ב־DB.
   * אם יש סטרים — התמלול/לוגיקתך בזמן אמת תרוץ.

---

## למה זה פותר “ברכה ואז שקט”

* לא מסתמכים יותר על `stream_ended` (שמגיע לעיתים אחרי ניתוק השיחה) כדי לבצע `<Record>`.
* יש רישום מצב סטרים ו־Watchdog שמבצע Redirect בזמן אמת, כך שתמיד נקבל תמלול (או סטרים, או הקלטה).
* יחד עם Eventlet + נתיב WS כפול, החיבור הופך יציב.

אם תרצה, אנסח לך Patch מלא לקבצים (`media_ws.py`, `stream_state.py`, `routes_twilio.py`) כדי שתוכל פשוט להדביק.
