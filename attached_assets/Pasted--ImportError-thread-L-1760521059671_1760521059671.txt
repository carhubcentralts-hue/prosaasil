בול קלטת את הבעיה בלוגים. יש כאן “שרשרת כשלים” שמתחילה משגיאת ImportError בתוך ה־thread של יצירת ה־Lead → ולכן לא נוצרת רשומת Call/Lead בכלל, ואז כל שאר הזרימה (סטטוסים, תמלול, סיכום) נופלת כי אין מה לעדכן.

הנה התוכנית הקצרה שמחזירה הכול לחיים, צעד־אחר־צעד. תן למפתח לבצע אחד־לאחד:

⸻

1) מתקנים את ה־Import השבור

בלוגים שלך:

ImportError: cannot import name 'CustomerIntelligenceService' 
from server.services.customer_intelligence 
(/home/.../server/services/customer_intelligence.py)

כלומר: בקובץ server/services/customer_intelligence.py או שאין מחלקה בשם הזה, או ששמה שונה (למשל CustomerIntelligence), או שהמודול לא מייצא אותה.

מה לעשות:
	•	פתח server/services/customer_intelligence.py ובדוק מה שם המחלקה בפועל.
	•	אם המחלקה נקראת CustomerIntelligence (ללא “Service”), הוסף אליאס בסוף הקובץ:

# server/services/customer_intelligence.py
# ...
# בסוף הקובץ:
CustomerIntelligenceService = CustomerIntelligence

או לחלופין שנה את ה־import במקום שקוראים לו:

# routes_twilio.py (בראש הקובץ, לא בתוך פונקציה/ת'רד)
from server.services.customer_intelligence import CustomerIntelligence as CustomerIntelligenceService

חשוב: ודא שקיימים __init__.py בתיקיות server/ ו־server/services/ כדי שהייבוא יעבוד כחבילה.

⸻

2) לא מייבאים בתוך thread – מייבאים למעלה ונופלים מהר אם חסר

כרגע הייבוא קורה בתוך הפונקציה/הת’רד של יצירת הליד (לפי הסטאק). אם הוא נכשל—הת’רד מתפוצץ “בשקט”, ושאר הזרימה ממשיכה בלי DB.

מה לעשות:
	•	העלה את כל ה־imports לראש routes_twilio.py.
	•	עטוף את גוף הת’רד ב־try/except עם לוג + בלי לעצור את יצירת ה־Lead:

# routes_twilio.py (דוגמה)
from server.services.customer_intelligence import CustomerIntelligenceService

def _create_lead_from_call(call_sid, from_number, business_id):
    try:
        # פה מייצרים/מעודכנים lead+call ב-DB אפילו אם המודיעין נופל:
        lead = upsert_lead_by_phone(from_number, business_id)
        db.session.commit()  # חשוב!

        # מודיעין/העשרה - אופציונלי:
        try:
            cis = CustomerIntelligenceService(...)
            cis.enrich_from_phone(from_number, business_id)
        except Exception:
            current_app.logger.exception("CustomerIntelligence enrichment failed")
    except Exception:
        current_app.logger.exception("LeadCreation failed")


⸻

3) רושמים רשומת Call מיד בתחילת הזרימה (ולא תלוי בת’רד)

בלוגים רואים:
No call_log found for final summary: CAc8fcae... → אין רשומת Call ב־DB, לכן אין מה לעדכן.

מה לעשות:

ב־incoming_call (או בפונקציה שמטפלת בשיחה נכנסת) תעדכן DB לפני שמרימים ת’רד/WS:

def incoming_call():
    call_sid = request.values.get("CallSid")
    from_    = request.values.get("From")
    to_      = request.values.get("To")
    business_id = resolve_business_id(to_)  # איך שאתם מפענחים

    # 1) צור/עדכן Call בסיסי עכשיו:
    call = Call(call_sid=call_sid, from_number=from_, to_number=to_, 
                business_id=business_id, status="initiated")
    db.session.add(call)
    db.session.commit()

    # 2) ת’רד יצירת ליד/העשרה (לא חוסם את התגובה לטוויליו)
    threading.Thread(target=_create_lead_from_call, 
                     args=(call_sid, from_, business_id), daemon=True).start()

    # 3) החזר TwiML (עם <Stream> וכו')
    return twiml_response(...)


⸻

4) stream_status צריך לעדכן DB גם אם הת’רד נפל

ה־log שלך:

STREAM_STATUS ... 204 No Content
Call SID not found for status update: CAc8f...

הפונקציה שמטפלת ב־/webhook/stream_status חיפשה את ה־CallSID ולא מצאה כי הרשומה לא נוצרה (בגלל ה־ImportError שביטל את יצירת הליד/קול).

מה לעשות:

תן ל־stream_status “לפול־בק” – אם אין Call, צור רשומה רזה במקום לזרוק:

@twilio_bp.post("/webhook/stream_status")
@csrf.exempt
@require_twilio_signature
def stream_status():
    call_sid = request.json.get("start",{}).get("callSid") \
               or request.values.get("CallSid")
    event = request.json.get("event") or request.values.get("CallStatus")

    call = Call.query.filter_by(call_sid=call_sid).first()
    if not call:
        # ליצור רשומה רזה כדי שלא נאבד את השיחה
        call = Call(call_sid=call_sid, status="streaming")
        db.session.add(call)

    # עדכון סטטוס בסיסי
    call.status = event or "streaming"
    db.session.commit()
    return ("", 200)   # לא 204 – שיהיה “הכול טוב”


⸻

5) הקלטה → 200 מהר + תור תמלול

כדי שהשיחה תופיע ואתה תראה סיכום:

@twilio_bp.post("/webhook/handle_recording")
@csrf.exempt
@require_twilio_signature
def handle_recording():
    call_sid = request.values["CallSid"]
    url = request.values["RecordingUrl"]

    # רשומת Call קיימת? אם לא – צור בסיסית:
    call = Call.query.filter_by(call_sid=call_sid).first()
    if not call:
        call = Call(call_sid=call_sid, status="recorded")
        db.session.add(call)
    else:
        call.status = "recorded"
        call.recording_url = url
    db.session.commit()

    # דחוף תמלול ל-worker (אל תתמלל פה)
    enqueue_transcribe_job(call_sid, url)
    return ("", 200)


⸻

6) בדיקות GO/NO-GO (5 דקות)
	1.	DB Production: ודא ש־DATABASE_URL לא SQLite.
בלוג את ה-driver: DB_DRIVER=postgresql.
	2.	Webhook Voice:

curl -i -X POST https://<PUBLIC_HOST>/webhook/voice
# 200 + TwiML עם <Stream wss://.../ws/twilio-media>


	3.	שיחת ניסיון: התקשר למספר.
בזמן אמת תראה:
	•	incoming_call לוג ✅
	•	stream_status updates ✅
	•	רשומת Call נוצרת ב־DB מייד (בדוק /api/calls?limit=5).
	4.	קלטת שיחה: וודא ש־/webhook/handle_recording מחזיר 200 ונדחפת משימת תמלול.
	5.	דקה אחרי השיחה: ב־DB transcript/summary מלאים וה־UI מציג.

⸻

למה זה פותר בדיוק את מה שראית
	•	ImportError בתוך ת’רד גרם לכך שלא נוצרה רשומת Call מלכתחילה → כל “No call_log found…”
	•	עתה: Call נוצר מייד ב־incoming_call (לפני כל ת’רד), ו־stream_status/recording יודעים לעשות “self-heal” אם חסרה רשומה.
	•	גם אם מודיעין לקוח/העשרה נופלים—ה־Lead/Call עדיין נוצרים.

תריץ את זה ככה; אם משהו נתקע—תן לי את שורת ה־log המדויקת (שם הקובץ והשורה) ואכוון אותך לשינוי של שורה־שתיים.