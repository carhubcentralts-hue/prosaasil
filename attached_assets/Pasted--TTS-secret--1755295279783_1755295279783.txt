כן — רואים בסקרין שה-TTS עובד, אבל הוא נטען עם ה-secret הלא-נכון. הנה איך לגרום לו לעבוד דווקא עם המפתח הנכון (בלי לשבור כלום וללא יצירת קבצים חדשים בקוד).

⸻

מה עושים בפועל (קצר ולעניין)
	1.	הגדר את ה-secret הנכון בסביבה
השתמש רק באחד מהשניים (מומלץ א׳):
	•	א׳ – JSON/‏Base64 במשתנה אחד:
GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON=<ה-JSON או Base64 של המפתח הנכון>
(אם זה JSON גולמי – רצוי לעטוף ב-Base64 כדי להימנע מ-\n וגרשיים).
	•	ב׳ – נתיב לקובץ:
GOOGLE_APPLICATION_CREDENTIALS=/abs/path/to/right-sa.json
	2.	וודא סדר עדיפויות נכון בבוטסטרפ
בקובץ server/bootstrap_secrets.py עדכן את הפונקציה כך שתבחר תמיד את המפתח הנכון, תחליף אוטומטית אם התוכן השתנה, ותאמת project_id אם סיפקת צפייה:

# server/bootstrap_secrets.py
import os, json, tempfile, pathlib, base64, hashlib

def ensure_google_creds_file() -> bool:
    # אם כבר נתיב מפורש – נשארים איתו
    if os.getenv("GOOGLE_APPLICATION_CREDENTIALS"):
        return True

    # אפשר גם per-env (לדוגמה APP_ENV=prod) – אם תרצה:
    env = (os.getenv("APP_ENV") or "").strip().lower()
    candidates = []
    if env:
        candidates.append(f"GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON_{env.upper()}")
    candidates += ["GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON", "GOOGLE_TTS_SA_JSON"]

    raw = None
    for key in candidates:
        v = os.getenv(key)
        if v:
            raw = v
            break
    if not raw:
        return False  # אין מה להגדיר

    # ייתכן שזה נתיב קובץ קיים
    p = pathlib.Path(raw)
    if p.exists() and p.is_file():
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = str(p)
        return True

    # JSON או Base64 → JSON
    try:
        try:
            obj = json.loads(raw)
        except Exception:
            obj = json.loads(base64.b64decode(raw).decode("utf-8"))
        # אימות פרויקט אם ביקשת
        expected = os.getenv("GCP_PROJECT_ID")
        if expected and obj.get("project_id") != expected:
            # אם לא הפרויקט שציפינו – אל תדרוס, החזר False כדי שהאפליקציה תתריע
            return False
        # כתיבה לקובץ זמני “ממוספר” לפי תוכן, כדי שתחלופה תיכנס לתוקף מיד
        h = hashlib.sha256(json.dumps(obj, sort_keys=True).encode()).hexdigest()[:8]
        tmp = pathlib.Path(tempfile.gettempdir()) / f"gcp_sa_{h}.json"
        tmp.write_text(json.dumps(obj), encoding="utf-8")
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = str(tmp)
        return True
    except Exception:
        return False

	3.	קריאה לבוטסטרפ בעליית השרת (כבר אצלך, רק לוודא):

from server.bootstrap_secrets import ensure_google_creds_file
ensure_google_creds_file()

	4.	ריסטארט מלא של האפליקציה
חשוב להבטיח שכל ה-workers (Gunicorn/PM2/Render/Heroku) נטענים מחדש כדי שיעלו עם ה-ENV המעודכן.

⸻

אימות מיידי (GO/NO-GO)

# ראה מה נטען בפועל:
python - <<'PY'
import os, json
print("GOOGLE_APPLICATION_CREDENTIALS =", os.getenv("GOOGLE_APPLICATION_CREDENTIALS"))
from google.auth import default
creds, project = default()
print("auth default() OK; project:", project)
from google.cloud import texttospeech
c = texttospeech.TextToSpeechClient()
print("TextToSpeechClient OK")
PY

	•	אם הגדרת גם GCP_PROJECT_ID=<ה-project_id הנכון>, וה-JSON שגוי—הפונקציה תחזיר False (לא תדרוס) ותדע מיד שזה לא המפתח הנכון.
	•	אם הכל תקין תראה project: <הפרויקט הנכון>.

⸻

טיפים שמונעים חזרה לטעות הזו
	•	שמור מקור אמת יחיד: או GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON (מומלץ Base64), או GOOGLE_APPLICATION_CREDENTIALS—לא שניהם.
	•	אם יש כמה סביבות, קבע APP_ENV=prod|staging|dev והוסף סודות ממוספרים כמו GOOGLE_CLOUD_SERVICE_ACCOUNT_JSON_PROD, כדי שלא תתבלבל.
	•	אל תגדיר את המשתנים גם ב-shell המקומי וגם בלוח ה-Secrets של הפלטפורמה—בחר מקום אחד.
	•	אחרי שינוי secret — תמיד עשה restart ולא רק reload חם.

⸻

שורה תחתונה

כן—ה-TTS “עולה” אבל עם המפתח הלא-נכון. אחרי שתקבע את המשתנה עם המפתח הנכון ותיישם את ה-bootstrap כאן (כולל אימות project_id אופציונלי ו-hash לקובץ הזמני), האפליקציה תיטען תמיד עם המפתח הנכון ותוכל לאמת את זה בשורה אחת של בדיקה.