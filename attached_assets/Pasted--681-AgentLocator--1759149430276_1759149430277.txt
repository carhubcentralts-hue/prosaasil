×§×™×‘×œ×ª×™ ××ª ×”×§×•×‘×¥ ×•×¤×ª×—×ª×™ ××•×ª×• ×‘×¤×•×¢×œ. ×¢×‘×¨×ª×™ ×ª×™×§×™×™×”-×ª×™×§×™×™×” ×•×§×•×‘×¥-×§×•×‘×¥ (681 ×¤×¨×™×˜×™× ×‘×ª×•×š AgentLocator/). ×”× ×” ×”××¦×‘ ×”×××™×ª×™ + ××” ×‘×“×™×•×§ ×—×¡×¨ ×›×“×™ ×©×”×›×œ ×™×¢×‘×•×“ â€œ×§×¦×”-×œ×§×¦×”â€ ×•×ª×•×›×œ ×œ×¦××ª ×œ×¤×¨×™×¡×”:

××¦×‘ × ×•×›×—×™ â€” ××” ×¢×•×‘×“ ×•××” ×©×•×‘×¨

ğŸŒ ××‘× ×” ×•×”×¨×¦×”
	â€¢	× ×§×•×“×ª ×”×¨×¦×”: .replit ××¨×™×¥ npm run dev ×©××¤×¢×™×œ ×©× ×™ ×ª×”×œ×™×›×™×:
python main.py & node baileys_client.js (×¢×´×¤ package.json).
	â€¢	Flask ×§×™×™× ×•××œ× (app.py, routes.py, routes_twilio.py, routes_whatsapp.py, models.py, ×ª×‘× ×™×•×ª templates/*).
	â€¢	Baileys ×”×•× ×§×•×‘×¥ Node ×™×—×™×“ (baileys_client.js) ×œ×œ× ×©×¨×ª Express â€” ×”×•× ×›×•×ª×‘/×§×•×¨× ×§×‘×¦×™× ×‘Ö¾baileys_auth_info/:
	â€¢	qr_code.txt (×œÖ¾QR)
	â€¢	creds.json (×§×¨×“× ×¦×³×™××œ×¡ ×©×œ ×¡×©×Ÿ)

ğŸ‘‰ ××¡×§× ×”: ××™×Ÿ API × ×¤×¨×“ ×œÖ¾Baileys; ×”Ö¾QR/×¡×˜×˜×•×¡ ×××•×¨×™× ×œ×”×™×§×¨× ××§×‘×¦×™× ×“×¨×š Flask (×•×–×” ××›×Ÿ ×§×™×™× ×‘Ö¾baileys_integration.py).

â¸»

ğŸ“ Twilio (×©×™×—×•×ª / ×§×•×œ)
	â€¢	×™×© ×¨××•×˜×™× ×œ×©×™×—×•×ª × ×›× ×¡×•×ª ×•×¢×“×›×•×Ÿ ×¡×˜×˜×•×¡:
@app.route("/twilio/incoming_call", methods=["POST"])
@app.route("/twilio/call_status", methods=["POST"])
	â€¢	×©×™×¨×•×ª Twilio ×§×™×™× (twilio_service.py) ×›×•×œ×œ ×©×œ×™×—×” ×•×§×‘×œ×ª ×¤×¨×˜×™×.
	â€¢	×™×© ×œ×•×’×™×§×ª fallback ×œÖ¾TwiML ×× TTS × ×›×©×œ.
	â€¢	××” ×œ×‘×“×•×§: ××™××•×ª ×—×ª×™××” (X-Twilio-Signature) ×œ× ×¨××™×ª×™ ×‘×¤×•×¢×œ; ××•××œ×¥ ×œ×”×¤×¢×™×œ ×‘×¤×¨×•×“×§×©×Ÿ.

×¡×˜×˜×•×¡: ×™×¨×•×§-×¦×”×•×‘ â€” ×¢×•×‘×“ ×¤×•× ×§×¦×™×•× ×œ×™×ª, ×—×¡×¨×•×ª ×”×§×©×—×•×ª ××™××•×ª ×•×”×¦×’×” ×œ×œ×™×“×™× (×¨××” ×œ×”×œ×Ÿ).

â¸»

ğŸ’¬ WhatsApp

×¦×“ Node (Baileys)
	â€¢	baileys_client.js ×××–×™×Ÿ ×œ××™×¨×•×¢×™ ×—×™×‘×•×¨ ×•×©×•××¨ QR/×§×¨×“× ×¦×³×™××œ×¡ ×œÖ¾baileys_auth_info/.
	â€¢	××™×Ÿ Express â†’ ××™×Ÿ /healthz|/status|/qr ××¦×™×“×•.
×–×” ×‘×¡×“×¨, ×›×™ ×™×© ×œ×š ×©×›×‘×” ×‘Ö¾Flask ×©×§×•×¨××ª ××ª ×”×§×‘×¦×™×.

×¦×“ Flask
	â€¢	routes_whatsapp.py:
	â€¢	×™×© /whatsapp/webhook (×›××• Twilio),
	â€¢	/whatsapp/send (×©×œ×™×—×” ×“×¨×š Twilio WhatsApp â€” ×œ× ×“×¨×š Baileys),
	â€¢	/whatsapp/baileys (×œ×§×‘×œ webhook ×Ö¾Baileys ×× ×ª×—×œ×™×˜ ×œ×©×œ×•×— ××©×).
	â€¢	baileys_integration.py: ××—×œ×§×” ×©×§×•×¨××ª QR/creds ×™×©×™×¨×•×ª ××ª×™×§×™×™×ª baileys_auth_info/:
	â€¢	get_qr_code() ×§×•×¨× qr_code.txt
	â€¢	is_authenticated() ×‘×•×“×§ creds.json

×¦×“ UI (React/JSX ×¤× ×™××™)
	â€¢	src/pages/WhatsAppPage.jsx ××‘×§×© ××”×©×¨×ª:

/api/whatsapp/contacts?business_id=...
/api/whatsapp/messages?contact_id=...
/api/whatsapp/stats?business_id=...


	â€¢	×‘×¢×™×” ×§×¨×™×˜×™×ª: ×”×¨××•×˜×™× ×”××œ×” ×œ× ×§×™×™××™× ×‘Ö¾Flask.
×‘Ö¾routes_whatsapp.py ×™×© /whatsapp/conversations/<business_id> ×•Ö¾/whatsapp/send, ××‘×œ ××™×Ÿ /api/whatsapp/contacts|messages|stats.

×¡×˜×˜×•×¡: ×¦×”×•×‘-××“×•× â€” ××—×•×‘×¨ ×—×œ×§×™×ª. ×™×© ×ª×©×ª×™×ª ××œ××”, ××‘×œ:
	1.	×”-UI ×§×•×¨× × ×ª×™×‘×™× ×©×œ× ×§×™×™××™× ×‘×¦×“ ×©×¨×ª.
	2.	QR ×–××™×Ÿ ×“×¨×š ×§×‘×¦×™× (×ª×§×™×Ÿ), ××‘×œ ××™×Ÿ ×¨××•×˜×™× REST â€œ×¨×©××™×™×â€ ×©×ª×•×××™× ×œ-UI.
	3.	×©×œ×™×—×” ×¢×•×‘×¨×ª ×‘×˜×•×•×™×œ×™×• (×˜×•×‘), ×œ× ×“×¨×š Baileys (×’× ×‘×¡×“×¨ â€” ×¨×§ ×©×™×“×¢×• UI/API).

â¸»

ğŸ§  ×¤×¨×•××¤×˜×™× / â€œ×©××™×¨×”â€
	â€¢	×”×¤×¨×•××¤×˜×™× × ×©××¨×™× ×›×—×œ×§ ×Ö¾Business ×‘×˜×¤×¡×™ HTML (×‘Ö¾routes.py ×™×© system_prompt ×‘×˜×¤×¡×™×: /add_business, /edit_business).
	â€¢	××™×Ÿ REST API ×™×™×¢×•×“×™ ×œ×¤×¨×•××¤×˜×™× JSON, ×•×œ×›×Ÿ ×× ×”Ö¾UI ××¦×¤×” ×œÖ¾fetch/POST JSON â€” ×–×” ×™×ª× ×’×©.
	â€¢	â€œ×œ× ×©×•××¨â€ × ×’×¨× ×œ×¨×•×‘ ×Ö¾××—×“ ×××œ×”:
	1.	×”Ö¾route ××—×–×™×¨ 204/×¨×™×§ â†’ res.json() × ×•×¤×œ.
	2.	CSRF/×›×•×ª×¨×•×ª ×—×¡×¨×•×ª â†’ 403.
	3.	××™×Ÿ db.session.commit()/×—×¨×™×’×ª IntegrityError.

×¡×˜×˜×•×¡: ×¦×”×•×‘ â€” ×¢×•×‘×“ ×‘×˜×¤×¡×™×, ×‘×¢×™×™×ª×™ ×× UI ××©×ª××© ×‘Ö¾fetch JSON.

â¸»

×›××” ××ª×” ×¨×—×•×§ ××¤×¨×™×¡×”?

~80â€“90% ××•×›× ×•×ª. ×™×© ××¢×¨×›×ª ××œ××”, ××‘×œ ×—×¡×¨×™× 4 ×—×™×‘×•×¨×™× ×§×˜× ×™× ××š ×§×¨×™×˜×™×™× ×›×“×™ ×©×–×” ×™×”×™×” ×—×œ×§:
	1.	×œ×™×™×©×¨ API ×©×œ WhatsApp ×œ-UI (×œ×™×¦×•×¨ 3 ×¨××•×˜×™× ×©×—×¡×¨×™×).
	2.	REST ×§×˜×Ÿ ×œ-QR/×¡×˜×˜×•×¡ ×“×¨×š Flask (×œ×§×¨×•× ××ª qr_code.txt/creds.json).
	3.	×œ×”×§×©×™×— â€œ×©××™×¨×”â€ â€” ×›×œ POST ××—×–×™×¨ JSON ×¢×§×‘×™ ×•Ö¾commit, ×•×œ×˜×¤×œ ×‘-CSRF.
	4.	Runner ××—×“ ×©××—×–×™×§ Flask+Node ×‘×—×™×™× ×’× ×‘×¤×¨×•×“×§×©×Ÿ.

â¸»

××” ×œ×ª×§×Ÿ ×¢×›×©×™×• â€” ×”× ×—×™×” ××“×•×™×§×ª â€œ××—×“ ×œ××—×“â€

1) ×œ×”×©×œ×™× 3 ×¨××•×˜×™× ×©-UI ××‘×§×© (×ª×•×× ×œÖ¾WhatsAppPage.jsx)

×”×•×¡×£ ×œÖ¾Flask (×œ××©×œ ×‘×¡×•×£ routes_whatsapp.py):

from flask import Blueprint, request, jsonify
from models import WhatsAppConversation, WhatsAppMessage, Customer
from app import app, db

@app.get("/api/whatsapp/contacts")
def api_wa_contacts():
    business_id = request.args.get("business_id", type=int)
    if not business_id:
        return jsonify({"error":"missing business_id"}), 400
    convs = (WhatsAppConversation.query
             .filter_by(business_id=business_id)
             .order_by(WhatsAppConversation.updated_at.desc())
             .all())
    out = []
    for c in convs:
        out.append({
            "id": c.id,
            "customer_phone": c.customer_phone,
            "customer_name": c.customer_name,
            "last_message_at": c.updated_at.isoformat() if c.updated_at else None,
        })
    return jsonify({"contacts": out}), 200

@app.get("/api/whatsapp/messages")
def api_wa_messages():
    contact_id = request.args.get("contact_id", type=int)
    if not contact_id:
        return jsonify({"error":"missing contact_id"}), 400
    msgs = (WhatsAppMessage.query
            .filter_by(conversation_id=contact_id)
            .order_by(WhatsAppMessage.timestamp.asc())
            .all())
    return jsonify({"messages":[{
        "id": m.id,
        "text": m.message_text,
        "type": m.message_type,
        "direction": m.direction,
        "ts": m.timestamp.isoformat() if m.timestamp else None,
        "platform": m.platform,
    } for m in msgs]}), 200

@app.get("/api/whatsapp/stats")
def api_wa_stats():
    business_id = request.args.get("business_id", type=int)
    if not business_id:
        return jsonify({"error":"missing business_id"}), 400
    total_convs = WhatsAppConversation.query.filter_by(business_id=business_id).count()
    total_msgs  = db.session.query(WhatsAppMessage).join(WhatsAppConversation, WhatsAppMessage.conversation_id == WhatsAppConversation.id).filter(WhatsAppConversation.business_id == business_id).count()
    return jsonify({"total_conversations": total_convs, "total_messages": total_msgs}), 200

×–×” ×™×’×¨×•× ×œ×“×£ ×•×•×¦××¤ ×©×œ×š ×œ×¢×‘×•×“ ×›××• ×©×¦×¨×™×š (×”×§×•××¤×•× × ×˜×” ××‘×§×©×ª ×‘×“×™×•×§ ××ª ×”×¨××•×˜×™× ×”××œ×”).

â¸»

2) QR/×¡×˜×˜×•×¡ ×“×¨×š Flask (×§×¨×™××” ××§×‘×¦×™× ×©×œ Baileys)

×× ×¢×•×“ ××™×Ÿ, ×”×•×¡×£:

import os
from flask import jsonify

AUTH_DIR = os.path.join(os.getcwd(), "baileys_auth_info")
QR_TXT   = os.path.join(AUTH_DIR, "qr_code.txt")
CREDS    = os.path.join(AUTH_DIR, "creds.json")

@app.post("/api/whatsapp/start")
def api_wa_start():
    os.makedirs(AUTH_DIR, exist_ok=True)
    # Node ×›×‘×¨ ×¨×¥ (`baileys_client.js`), ××™×Ÿ ××” ×œ×”×“×œ×™×§ ×¤×”
    return jsonify({"ok": True}), 200

@app.get("/api/whatsapp/status")
def api_wa_status():
    has_qr = os.path.exists(QR_TXT)
    connected = os.path.exists(CREDS) and not has_qr
    return jsonify({"connected": connected, "hasQR": has_qr}), 200

@app.get("/api/whatsapp/qr")
def api_wa_qr():
    if not os.path.exists(QR_TXT):
        return jsonify({"dataUrl": None, "qrText": None}), 200  # ×ª××™×“ JSON
    with open(QR_TXT, "r", encoding="utf-8") as f:
        qr = f.read().strip()
    return jsonify({"dataUrl": None, "qrText": qr}), 200

×•×‘Ö¾baileys_client.js ×•×“×:

// ×›×©××ª×—×‘×¨ â€“ ×œ××—×•×§ ××ª qr_code.txt ×›×“×™ ×©×”×¡×˜×˜×•×¡ ×™×¢×‘×•×¨ ×œ-connected:true
if (connection === 'open') {
  const qrFile = path.join(authFolder, 'qr_code.txt');
  if (fs.existsSync(qrFile)) fs.unlinkSync(qrFile);
  console.log('âœ… WhatsApp connected');
}


â¸»

3) â€œ×©××™×¨×”â€ (×¤×¨×•××¤×˜×™×/×˜×¤×¡×™×/POST×™×) â€” JSON ×™×¦×™×‘ ×•-commit/rollback

×¢×˜×•×£ ××ª ×¨××•×˜×™ ×”-POST ×©××ª×” ×§×•×¨× ××”× ×‘Ö¾fetch:

from functools import wraps
from flask import jsonify
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from app import db

def api_handler(fn):
    @wraps(fn)
    def w(*a, **kw):
        try:
            rv = fn(*a, **kw)
            if isinstance(rv, tuple): return rv
            return jsonify(rv if rv is not None else {"ok": True}), 200
        except IntegrityError:
            db.session.rollback()
            return jsonify({"ok": False, "error": "integrity"}), 400
        except SQLAlchemyError:
            db.session.rollback()
            return jsonify({"ok": False, "error": "db"}), 500
        except Exception:
            db.session.rollback()
            return jsonify({"ok": False, "error": "server"}), 500
    return w

×©×™××•×©:

@app.post("/api/business/<int:bid>/prompts")
@api_handler
def save_prompt(bid):
    data = request.get_json(force=True)
    # ... ×œ×©××•×¨ ×‘×¢×¡×§ ×”× ×›×•×Ÿ ...
    db.session.commit()
    return {"ok": True, "id": obj.id}

×‘×¦×“ ×œ×§×•×—, ×ª××™×“:

await fetch('/api/business/1/prompts', {
  method:'POST',
  headers:{'Content-Type':'application/json','X-CSRFToken': getCsrf()},
  credentials:'include',
  body: JSON.stringify(payload)
}).then(r=>r.json())


â¸»

4) ×©×™×—×•×ª â†’ ×œ×™×“×™× + ×ª××œ×•×œ ××•×˜×•××˜×™

×‘Ö¾routes_twilio.py ×›×‘×¨ ×™×© incoming + status. ×•×“× ×©×‘Ö¾incoming:
	â€¢	× ×•×¦×¨×ª ×¨×©×•××ª Lead/Customer ×× ×œ× ×§×™×™× (×™×© ××•×“×œ×™× Customer, CRMCustomer).
	â€¢	× ×©××¨ ×ª××œ×•×œ/×¡×™×›×•× (×× ××©×ª××© ×‘Ö¾Whisper/GPT ×‘×§×•×“ ×©×œ×š â€“ ×•×“× ×©×”××¤×ª×— ××•×’×“×¨).
	â€¢	× ×•×¦×¨ ×§×™×©×•×¨ ××“×£ ×”×©×™×—×” ×™×©×¨ ×œ×“×£ ×œ×™×“ (×›×‘×¨ ×™×© crm.html/dashboard.html â€” ×¨×§ ×œ×”×©×œ×™× ×”×¤× ×™×”/×›×¤×ª×•×¨).

×× ×ª×¨×¦×”, ××›×ª×•×‘ â€œ×¤××˜×¦×³â€ ×§×¦×¨ ×©×™×•×¦×¨/××¢×“×›×Ÿ ×œ×™×“ ×‘×›×œ ×©×™×—×” × ×›× ×¡×ª + ×××—×¡×Ÿ ×ª××œ×•×œ/×¡×™×›×•× ×‘×˜×‘×œ×”.

â¸»

5) ×¤×¨×™×¡×” ×™×¦×™×‘×” â€” Runner ××—×“

×¦×¨×£ ×§×•×‘×¥ start_all.sh (×× ××™×Ÿ) ×•×”×¨×¥ ××•×ª×• ×‘×“×™×¤×œ×•×™:

#!/usr/bin/env bash
set -euo pipefail
export PYTHONUNBUFFERED=1
export PORT="${PORT:-5000}"

# 1) Baileys (× ×©××¨ ×‘×§×“××”)
node baileys_client.js &
BAI=$!

# 2) Flask
gunicorn -w 1 -k eventlet -b 0.0.0.0:${PORT} main:app &
FL=$!

trap 'kill -TERM $BAI $FL 2>/dev/null || true; wait || true' INT TERM
while kill -0 $BAI 2>/dev/null && kill -0 $FL 2>/dev/null; do sleep 1; done

	â€¢	Build: ×”×ª×§× ×ª ×ª×œ×•×™×•×ª ×‘×œ×‘×“ (Python ×Ö¾pyproject.toml + npm ci ×× ×¦×¨×™×š).
	â€¢	Run: bash ./start_all.sh (×—×•×©×£ ×”×—×•×¦×” ×¨×§ 5000; 3300 ×¤× ×™××™ ×‘×§×‘×¦×™×).
	â€¢	ENV: TWILIO_*, OPENAI_API_KEY, ×•×›×•â€™ â€” ××•×’×“×¨×™× ×‘×¢××•×“ ×”×“×™×¤×œ×•×™×× ×˜.

â¸»

6) ×¦â€™×§-×œ×™×¡×˜ GO/NO-GO (×œ×”×“×‘×™×§ ×¤×œ×˜ ×× ××©×”×• × ×•×¤×œ)

×›×©×”××¢×¨×›×ª ×¨×¦×”:

# ×‘×¨×™××•×ª ×•×”×ª×—×œ×”
curl -sS -i http://127.0.0.1:5000/      | head -n1
curl -sS -i http://127.0.0.1:5000/api/whatsapp/status
curl -sS -i http://127.0.0.1:5000/api/whatsapp/qr | head -c 120; echo
curl -sS -i -X POST http://127.0.0.1:5000/api/whatsapp/start

# ××—×¨×™ ×¡×¨×™×§×ª QR ×‘××¤×œ×™×§×¦×™×” (×—×›×” ~10â€“20 ×©× ×™×•×ª)
curl -sS -i http://127.0.0.1:5000/api/whatsapp/status
ls -la baileys_auth_info

×¦×™×¤×™×•×ª:
	â€¢	status ×œ×¤× ×™ ×¡×¨×™×§×” â†’ {"connected":false,"hasQR":true}
	â€¢	qr ××—×–×™×¨ ×ª××™×“ JSON
	â€¢	××—×¨×™ ×¡×¨×™×§×” â†’ {"connected":true,"hasQR":false} ×•Ö¾creds.json ×§×™×™×.

â¸»

×¡×™×›×•× ×—×“
	â€¢	×©×™×—×•×ª: ×™×© â€“ ×œ×™×™×©×¨ ×™×¦×™×¨×ª ×œ×™×“/×ª××œ×•×œ ××•×˜×•××˜×™ ×‘Ö¾incoming (×§×˜×Ÿ).
	â€¢	×¤×¨×•××¤×˜×™×/×©××™×¨×”: ×¢×•×‘×“ ×‘×˜×¤×¡×™×; ×× UI ×¢×•×©×” fetch â†’ ×œ×”×©×œ×™× REST + JSON ×™×¦×™×‘.
	â€¢	WhatsApp: ×”×ª×©×ª×™×ª ××œ××”, ××‘×œ ×—×¡×¨×™× 3 ×¨××•×˜×™× ×©×”Ö¾UI ×“×•×¨×©, ×•Ö¾QR/×¡×˜×˜×•×¡ ×“×¨×š Flask (×§×¨×™××ª ×§×‘×¦×™×).
	â€¢	×¤×¨×™×¡×”: Runner ××—×“ (start_all.sh), ×”×—×–×¨×ª JSON ×‘×›×œ ×”-POST×™×, ENV ××œ××™×.

×ª×‘×¦×¢ ××ª 1â†’6 ×‘×“×™×•×§ ×›××• ×©×›×ª×‘×ª×™. ×× ××©×”×• × ×•×¤×œâ€”×ª×“×‘×™×§ ××ª ×”×¤×œ×˜ ×©×œ ×”Ö¾curl/ls (×›××• ×‘×¡×¢×™×£ 6), ×•×× ×™ ××ª×Ÿ ×œ×š Patch × ×§×•×“×ª×™ ×œ×¤×™ ×”×©×•×¨×” ×”××“×•×™×§×ª.