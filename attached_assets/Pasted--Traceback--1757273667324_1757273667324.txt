מעולה—הנה ההנחיה המלאה, מסודרת וסופר-מדויקת, עם דגש על החלק שציטטת: “להוציא Traceback באתחול יבש”, כדי לאתר ייבוא מעגלי/כפילויות שהצטברו סביב CSRF. בסוף יש צ’ק-ליסט “Definition of Done” שאי אפשר להתווכח איתו.

⸻

תוכנית תיקון מלאה: CSRF שכבה אחת, אתחול יבש עם Traceback, FE שולח טוקן, והתחזות עובדת

0) עקרונות (לפני קוד)
	•	שכבת CSRF אחת בלבד ל-SPA/JSON → SeaSurf.
	•	אין עקיפה (exempt) ל־impersonate; כן עקיפות רק ל-webhooks/health.
	•	FE שולח X-CSRFToken בכל בקשת שינוי מצב.
	•	מריצים “אתחול יבש” כדי לקבל Traceback אם השרת לא עולה.

⸻

1) ניקוי CSRF כפול והפרדת הרחבות (Extensions)

1.1 צור/עדכן server/extensions.py

# server/extensions.py
from flask_seasurf import SeaSurf

csrf = SeaSurf()  # מופע יחיד של SeaSurf לכל האפליקציה

1.2 עדכן server/app_factory.py

# server/app_factory.py
from flask import Flask
from server.extensions import csrf

def create_app():
    app = Flask(__name__)

    # קונפיג בסיסי (התאם לסביבה שלך)
    app.config.update(
        SECRET_KEY="change-me",
        SESSION_COOKIE_SECURE=False,    # Preview/dev בלבד
        SESSION_COOKIE_SAMESITE='Lax',  # ל-Preview; בפרוד שקול Strict/Lax
        SESSION_COOKIE_PATH='/',
        SEASURF_COOKIE_NAME='XSRF-TOKEN',
        SEASURF_HEADER='X-CSRFToken',
    )

    csrf.init_app(app)  # אתחול יחיד

    # רישום Blueprints/Routes...
    # from server.routes_webhooks import webhooks_bp
    # app.register_blueprint(webhooks_bp)
    # from server.auth_api import auth_api
    # app.register_blueprint(auth_api)

    return app

1.3 מחיקת CSRFProtect (Flask-WTF)
	•	מחק כל:
	•	from flask_wtf.csrf import CSRFProtect
	•	CSRFProtect(app)
	•	בקונפיג: WTF_CSRF_* → להסיר/לכבות.
	•	חפש אתחולי SeaSurf כפולים:

rg -n "SeaSurf\(" -S
rg -n "csrf\.init_app" -S
rg -n "CSRFProtect\(" -S

חייב להישאר רק ב-extensions.py + csrf.init_app(app) פעם אחת ב-app_factory.py.

1.4 עקיפות CSRF (exempt) — רק היכן שחובה

# server/routes_webhooks.py (דוגמה)
from flask import Blueprint, request, jsonify
from server.extensions import csrf

webhooks_bp = Blueprint("webhooks", __name__)
csrf.exempt(webhooks_bp)  # ← עקיפה לכל ה-blueprint של webhooks בלבד

@webhooks_bp.route("/webhook/twilio", methods=["POST"])
def twilio_webhook():
    # אימות חתימה של Twilio כאן...
    return ("", 204)

לא לעשות exempt על /api/admin/businesses/<id>/impersonate.

⸻

2) “אתחול יבש” כדי להוציא Traceback (מה שביקשת להרחיב)

מטרה: לטעון את האפליקציה בלי להריץ שרת, כדי לקבל שגיאה קריאה (Stack Trace) אם יש ייבוא מעגלי/כפילויות.

pkill -f gunicorn || true
pkill -f "python wsgi.py" || true

python - <<'PY'
import traceback
try:
    print("[DRY-INIT] importing create_app() ...")
    from server.app_factory import create_app
    app = create_app()
    print("[DRY-INIT] APP_CREATED_OK")
except Exception as e:
    print("[DRY-INIT] ERROR DURING APP INIT:")
    traceback.print_exc()
PY

איך לפרש את ה-Traceback
	•	ImportError / circular import (ייבוא מעגלי):
מישהו יוצר SeaSurf() שני או קורא csrf.init_app() בקובץ route, או ש־route מייבא את create_app() בחזרה.
פתרון:
	•	את כל ה-extensions (כולל csrf) לעגן ב-extensions.py.
	•	בקבצי routes יש לייבא רק from server.extensions import csrf — לא ליצור מופע חדש.
	•	אין csrf.init_app(app) מחוץ ל-app_factory.py.
	•	אין from server.app_factory import app בתוך routes (אל תיווצר תלות “חוזרת”).
	•	RuntimeError בזמן init:
בד”כ קורה כשעושים csrf.exempt() לפני שקיים app/blueprint, או כשמאתחלים פעמיים.
פתרון: להזיז את הקריאה ל-csrf.exempt(bp) אחרי ההגדרה של ה-Blueprint ולפני register_blueprint.

חוזרים על ה-”אתחול היבש” עד שמקבלים [DRY-INIT] APP_CREATED_OK.

⸻

3) הרצה ידנית (Dev) + בדיקת קשב לפורט

3.1 wsgi.py

# wsgi.py
import os
from server.app_factory import create_app

app = create_app()

if __name__ == "__main__":
    port = int(os.getenv("PORT", "8000"))
    print(f"[WSGI] starting on 0.0.0.0:{port}", flush=True)
    app.run(host="0.0.0.0", port=port, debug=False)

3.2 הרצה ובדיקה

python wsgi.py &
sleep 1
lsof -i -P -n | grep LISTEN || true
curl -i http://127.0.0.1:${PORT:-8000}/version

אם לא מאזין/נופל → חזור ל-שלב 2 להוציא Traceback ולתקן.

⸻

4) API ל-CSRF Token (שרת)

# server/auth_api.py
from flask import Blueprint, jsonify, request
from server.extensions import csrf

auth_api = Blueprint("auth_api", __name__)

@auth_api.route("/api/auth/csrf", methods=["GET"])
def get_csrf():
    token = request.cookies.get('XSRF-TOKEN') or csrf._get_token()  # dev only
    resp = jsonify({"csrfToken": token})
    resp.set_cookie(
        'XSRF-TOKEN', token,
        samesite='Lax', secure=False, httponly=False, path='/'
    )
    return resp, 200


⸻

5) צד-לקוח: שליחה אוטומטית של CSRF בכל שינוי מצב

5.1 utility לקריאת cookie

function getCookie(name: string) {
  return document.cookie
    .split('; ')
    .find(r => r.startsWith(name + '='))
    ?.split('=')[1] ?? '';
}

5.2 עטיפת fetch מרכזית

const needsCsrf = (m:string) => !['GET','HEAD','OPTIONS'].includes(m.toUpperCase());

export async function apiFetch(url: string, options: RequestInit = {}) {
  const method = (options.method ?? 'GET').toUpperCase();
  const headers = new Headers(options.headers ?? {});
  if (needsCsrf(method)) {
    headers.set('Content-Type', 'application/json');
    headers.set('X-CSRFToken', decodeURIComponent(getCookie('XSRF-TOKEN')));
    headers.set('X-Requested-With', 'XMLHttpRequest');
  }
  return fetch(url, {
    ...options,
    method,
    headers,
    credentials: 'include',
  });
}

5.3 זרימת התחזות (Client)

await apiFetch(`/api/admin/businesses/${id}/impersonate`, {
  method: 'POST',
  body: JSON.stringify({}) // אם נדרש payload – הוסף כאן
});
const me = await apiFetch('/api/auth/me');
if (me.ok) {
  const data = await me.json();
  if (data.impersonating === true || data.user?.role === 'business') {
    navigate('/app/business/overview');
  } else {
    toast.error('Impersonation failed');
  }
} else {
  toast.error('Auth check failed');
}


⸻

6) Smoke Tests (שרת, בלי דפדפן)

# 1) Login
curl -i -c /tmp/c.txt -b /tmp/c.txt -X POST \
  http://127.0.0.1:${PORT:-8000}/api/auth/login \
  -H 'Content-Type: application/json' \
  --data '{"email":"admin@your.co.il","password":"<PASS>"}'

# 2) קבלת טוקן (וגם cookie XSRF-TOKEN)
TOKEN=$(curl -s -c /tmp/c.txt -b /tmp/c.txt \
  http://127.0.0.1:${PORT:-8000}/api/auth/csrf \
  | python - <<'PY'
import sys, json; print(json.load(sys.stdin)['csrfToken'])
PY
)

# 3) impersonate בלי header → חייב 400 csrf_token_missing
curl -i -c /tmp/c.txt -b /tmp/c.txt -X POST \
  http://127.0.0.1:${PORT:-8000}/api/admin/businesses/1/impersonate \
  -H 'Content-Type: application/json' \
  --data '{}'

# 4) impersonate עם header → חייב 200
curl -i -c /tmp/c.txt -b /tmp/c.txt -X POST \
  http://127.0.0.1:${PORT:-8000}/api/admin/businesses/1/impersonate \
  -H 'Content-Type: application/json' \
  -H "X-CSRFToken: $TOKEN" \
  --data '{}'

# 5) me → חייב impersonating:true + role 'business'
curl -i -c /tmp/c.txt -b /tmp/c.txt \
  http://127.0.0.1:${PORT:-8000}/api/auth/me


⸻

7) הקשחות משלימות (Prod)
	•	CORS: מקור יחיד, credentials: true, שיטות/כותרות מינימום.
	•	Rate-limit ל־impersonate (למשל 5/דקה/IP).
	•	Idempotency-Key לכל POST רגיש.
	•	Re-auth (Password/OTP) לפני impersonate.
	•	Audit log לכל כניסה/יציאה מהתחזות.
	•	Headers: Content-Security-Policy, Referrer-Policy: same-origin, X-Frame-Options: DENY.

⸻

✅ Definition of Done
	•	rg לא מוצא CSRFProtect( בכלל; SeaSurf( קיים רק פעם אחת (ב-extensions).
	•	“אתחול יבש” מדפיס APP_CREATED_OK (אין Traceback).
	•	/api/auth/csrf מחזיר טוקן ומגדיר cookie XSRF-TOKEN.
	•	curl ל-impersonate:
	•	בלי X-CSRFToken → 400 עם csrf_token_missing.
	•	עם X-CSRFToken → 200.
	•	/api/auth/me אחרי ההתחזות → impersonating:true, user.role:'business'.
	•	ב־FE: ההתחזות מצליחה ומנווטת ל־/app/business/overview בלי 400/קפיצה ל־login.
	•	אין אזהרות אדומות בקונסול.

אם אחד הסעיפים נופל—שלח את ה-Traceback מהשלב “אתחול יבש” או צילום Network (Headers + Payload) של הבקשה שנכשלת, ואכוון לשורת התיקון המדויקת.