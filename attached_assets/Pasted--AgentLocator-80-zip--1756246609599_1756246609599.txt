כן—בדקתי את **AgentLocator (80).zip** בפועל. הנה ממצאים נקודתיים + תיקון ממוקד שיסגור את ה“שקט”:

## מה טוב כבר עכשיו

* `/webhook/incoming_call` מחזיר TwiML תקין (200, `text/xml`) עם `<Connect><Stream>`.
* `/webhook/stream_status` ו־`/webhook/stream_ended` מחזירים 204/200 כמו שצריך.
* ה־WS נקרא מ־`app_factory.py` דרך Flask-Sock ומעביר לטיפול של `server/media_ws.py`.
* ב־`media_ws.py` כבר יש AI-pipeline (ASR→LLM→TTS) ושליחת פריימים µ-law בגודל 20ms (160B).

## למה עדיין שקט

1. ב־**TwiML** יש `<Play>` לפני `<Connect>` → ה־WS נפתח רק אחרי הברכה; זה מקצר חלון הזמן ומבלבל דיבאג.
2. ב־**TTS** (קובץ `server/services/gcp_tts_live.py`) אתם מייצרים **MP3** ואז ממירים עם **ffmpeg** ל־PCM16. בריפליט/דיפלוי לרוב **אין ffmpeg**, ולכן `_convert_mp3_to_pcm16_8k()` נופל → אין PCM → לא נשלחים פריימים → שקט.
3. אין **fallback** (למשל beep) אם TTS כושל, אז גם כש־ASR/LLM עובדים—לא נשמע כלום.

---

# ✅ DIFFים מדויקים לסגירת השקט

## 1) בטלו `<Play>` כברירת־מחדל (פתחו WS מיד)

**קובץ:** `AgentLocator/server/routes_twilio.py`

```diff
@@
-    # TwiML עם ברכה עברית לפני Connect - זה מה שחסר!
-    twiml = (
-        '<?xml version="1.0" encoding="UTF-8"?>'
-        "<Response>"
-        f'  <Play>{base}/static/greeting_he.mp3</Play>'
+    # ברכה אופציונלית: הפכו אותה ל־ENV (ברירת מחדל בלי Play)
+    play_greeting = os.getenv("TWIML_PLAY_GREETING", "false").lower() == "true"
+    parts = [
+        '<?xml version="1.0" encoding="UTF-8"?>',
+        '<Response>',
+    ]
+    if play_greeting:
+        parts.append(f'  <Play>{base}/static/greeting_he.mp3</Play>')
+    parts += [
         f'  <Connect action="{base}/webhook/stream_ended">'
         f'    <Stream url="wss://{host}/ws/twilio-media" '
         f'            statusCallback="{base}/webhook/stream_status">'
         f'      <Parameter name="call_sid" value="{call_sid}"/>'
         f'    </Stream>'
         f'  </Connect>'
-        "</Response>"
-    )
+        '</Response>',
+    ]
+    twiml = "".join(parts)
@@
     resp = make_response(twiml, 200)
     resp.headers["Content-Type"] = "text/xml"
```

> כך ה־Stream נפתח מיד. אם תרצה ברכה—שנה ב־ENV: `TWIML_PLAY_GREETING=true`.

---

## 2) תוציאו את **ffmpeg** מהתמונה: TTS ישיר ל-PCM16 8kHz

ב־Google TTS אפשר לבקש ישירות **LINEAR16** ב־**8000Hz**. אין צורך ב-MP3/ffmpeg.

**קובץ:** `AgentLocator/server/services/gcp_tts_live.py`

```diff
@@
-        self.audio_config = texttospeech.AudioConfig(
-            audio_encoding=texttospeech.AudioEncoding.MP3,
-            speaking_rate=1.1,
-        )
+        self.audio_config_pcm16_8k = texttospeech.AudioConfig(
+            audio_encoding=texttospeech.AudioEncoding.LINEAR16,
+            speaking_rate=1.1,
+            sample_rate_hertz=8000,   # ← PCM16 8kHz מונו
+        )
@@
-    def synthesize_hebrew(self, text, output_path=None):
-        """סינתזה ל-MP3 (לשימוש קבצים סטטיים / UI)"""
+    def synthesize_hebrew(self, text, output_path=None):
+        """סינתזה ל-MP3 (נשאר לצורכי UI/הורדה)"""
         ...
@@
+    def synthesize_hebrew_pcm16_8k(self, text: str) -> bytes | None:
+        """סינתזה ישירה ל-PCM16 8kHz (ל־Media Streams)"""
+        try:
+            if not text.strip():
+                return None
+            self._ensure_client()
+            synthesis_input = texttospeech.SynthesisInput(text=text)
+            response = self.client.synthesize_speech(
+                input=synthesis_input,
+                voice=self.voice,
+                audio_config=self.audio_config_pcm16_8k,
+            )
+            return response.audio_content  # LINEAR16 bytes
+        except Exception as e:
+            log.error(f"TTS_PCM16_ERROR: {e}")
+            return None
```

(את הפונקציות הישנות של MP3 אפשר להשאיר לצרכי UI; ה־AI-stream לא ישתמש בהן יותר.)

---

## 3) תעדכנו את ה־WS Handler להשתמש ב-PCM ישיר + Fallback beep

**קובץ:** `AgentLocator/server/media_ws.py`

```diff
@@
-    def _text_to_speech(self, hebrew_text):
-        """Convert Hebrew text to PCM16 8kHz audio"""
-        try:
-            if HEBREW_REALTIME_ENABLED:
-                # Use Google Cloud TTS
-                from server.services.gcp_tts_live import HebrewTTSLive
-                tts = HebrewTTSLive()
-                mp3_path = tts.synthesize_hebrew(hebrew_text)
-                if mp3_path:
-                    return self._convert_mp3_to_pcm16_8k(mp3_path)
-            return None
-        except Exception as e:
-            print(f"TTS_ERROR: {e}")
-            return None
+    def _text_to_speech(self, hebrew_text):
+        """TTS ישיר ל-PCM16 8kHz (ללא ffmpeg) + פולבאק beep"""
+        try:
+            from server.services.gcp_tts_live import HebrewTTSLive
+            tts = HebrewTTSLive()
+            pcm = tts.synthesize_hebrew_pcm16_8k(hebrew_text)
+            if pcm:
+                return pcm
+            # Fallback: beep אם אין TTS
+            return self._beep_pcm16_8k(600)
+        except Exception as e:
+            print(f"TTS_ERROR: {e}")
+            return self._beep_pcm16_8k(400)
@@
-    def _convert_mp3_to_pcm16_8k(self, mp3_path):
-        """Convert MP3 file to PCM16 8kHz mono"""
-        ...
-        return pcm16_data
+    # לא צריך יותר המרה מ-MP3 → הסירו/השאירו לא בשימוש
@@
+    def _beep_pcm16_8k(self, ms: int) -> bytes:
+        import math
+        SR = 8000
+        samples = int(SR * ms / 1000)
+        amp = 9000
+        out = bytearray()
+        for n in range(samples):
+            val = int(amp * math.sin(2*math.pi*440*n/SR))
+            out.extend(val.to_bytes(2, "little", signed=True))
+        return bytes(out)
```

> חשוב: פונקציית השליחה `_send_pcm16_as_mulaw_frames` אצלכם כבר נכונה (160 בייט לכל פריים; `clear` לפני ההשמעה). תשאירו כמו שהיא.

---

## 4) ודאו שהשרת באמת רץ ב-AI (לא ECHO ישן)

* ב־`start_all.sh` קבעו ברירת־מחדל:

  ```bash
  export WS_MODE=${WS_MODE:-AI}
  ```
* ודאו שה־**Run** מריץ *רק* `bash AgentLocator/start_all.sh` (לא `python main.py` במקביל).
* בלוגים תחפשו: `WS_START sid=... mode=AI` + `TTS_LEN_BYTES: N`.

> **הערה:** בקובץ שצירפת ראיתי ש־`start_all.sh` מכיל `...` (ליטרלי). אם זה לא טעות הדבקה, החליפו לסקריפט מלא ומתפקד—אחרת ENV לא נטענים.

---

# בדיקות GO קצרות (להדביק ולהריץ)

1. **Handshake** (לא עם curl!):

```bash
wscat -c "wss://ai-crmd.replit.app/ws/twilio-media" -s "audio.twilio.com"
# מצופה: connected (subprotocol: audio.twilio.com)
```

2. **שיחה אמיתית**:

* `incoming_call`=200 מהר, `stream_status`=204, `stream_ended`=200.
* באוזן: תשמעו קול: או TTS אמיתי או לפחות **beep** (פולבאק).
* בלוגים:

  * `WS_START ... mode=AI`
  * `ASR_TEXT: ...` (אם דיברתם)
  * `AI_RESPONSE: ...`
  * `TTS_LEN_BYTES: >0`
  * `WS_DONE ... rx>0 tx>0`

3. **אם עדיין שקט**:

* בדקו האם מודפס `TTS_LEN_BYTES: 0` → בעיית הרשאות/קרדנצ'לז ל-GCP; פולבאק beep אמור להישמע. אם אפילו beep לא נשמע—בדקו שהגעתם ל־`_send_pcm16_as_mulaw_frames` ושהפריים נשלח 160-160 בייט.
* אם `rx>0` ו־`tx=0` → TTS לא מחזיר bytes או נזרקת חריגה; עם ה-beep תראו `tx>0`.
* אם `rx=0` → בעיית Handshake/WS (חזרו לבדיקה עם `wscat`).

---

## TL;DR

* בטלו `<Play>` כברירת־מחדל, פתחו Stream מיד.
* העבירו את ה-TTS ל-LINEAR16 8kHz ישיר (בלי ffmpeg).
* הוסיפו beep פולבאק כדי שתמיד ישמע משהו גם בלי מפתחות.
* ודאו שהדיפלוי באמת רץ ב-`WS_MODE=AI`.

תיישמו את שלושת ה-diffים למעלה ותתקשרו שוב — אמור להישמע **קול** בקו (עברית), או הכי גרוע **beep** שמוכיח שהכיוון החוצה עובד.
