מבין אותך. כשחוזרים שוב ל-403 על “שמירת פרומפט” ו“התחזות”, זה כמעט תמיד אחד משלושה: (א) ה-cookie של ה-CSRF לא נקרא בצד לקוח, (ב) הכותרת X-CSRFToken לא נשלחת/לא תואמת, (ג) מחסום הרשאות (guard) חוסם לפני SeaSurf. הנה “קרטיסת חירום” קצרה שתוציא אותך מזה עכשיו — בלי ניחושים.

⸻

10 צעדים שמחזירים כתיבה לעבוד (מדויק וקצר)

1) הרצה אחידה (בלי vite dev)
	•	אותו פקודת run ב-Preview וב-Deploy: Flask מגיש client/dist/ + API באותו דומיין (single-origin).
	•	כל ה-fetch ב-FE עם credentials:'include'.

2) SeaSurf אחד בלבד
	•	השבת לגמרי כל CSRF אחר (Flask-WTF/Decorators מותאמים).
	•	סדר אתחול: קונפיג׳ סשן → SeaSurf(app) → register blueprints.

3) רשימת פטורים מצומצמת
	•	פטורים רק: POST /api/auth/login, POST /api/auth/logout, כל /webhook/**, ו-GET healthz/readyz/livez/version.
	•	התחזות ושמירת פרומפטים לא פטורים.

4) Cookie הגיוני (זה מקור 403 קלאסי)
	•	XSRF-TOKEN (לא HttpOnly) עם:
	•	Preview: SameSite=None; Secure=True
	•	Deploy: SameSite=Lax; Secure=True
	•	Cookie סשן: HttpOnly=True; Secure=True; SameSite כמו למעלה.

5) Endpoint טוקן ברור
	•	GET /api/auth/csrf מחזיר {csrfToken} וגם מציב XSRF-TOKEN.
	•	FE: מיד אחרי login קורא /api/auth/csrf פעם אחת.

6) לקוח FE — בדיקה אחת במקום 100
	•	בקובץ http.ts (או service מרכזי):
	•	בכל POST/PUT/PATCH/DELETE:
	•	credentials:'include'
	•	Content-Type:'application/json'
	•	כותרת X-CSRFToken = הערך של XSRF-TOKEN מ-document.cookie.
	•	אם יש 403: הדפס לקונסול את הערכים של ה-cookie וה-header (לא Error {} ריק).

7) OPTIONS תמיד 204
	•	לכל ראוט כתיבה (כולל /api/admin/businesses/:id/impersonate ו-PUT /api/business/current/prompt) החזר 204 עבור OPTIONS.
(כך ה-preflight לא נתקע על CSRF/Guard.)

8) ה-Guard לא עושה CSRF — רק הרשאות
	•	ב־require_api_auth:
	•	אם OPTIONS → 204.
	•	קבע הקשר:

role = session['user']['role']
tenant = session.get('impersonated_tenant_id') or session['user'].get('tenant_id')
impersonating = bool(session.get('impersonating'))


	•	/api/admin/** → role in {'admin','manager'}.
	•	ראוטים עסקיים → role=='business' או admin/manager כש-impersonating על אותו tenant.
	•	אל תשנה session['user']['role'] בהתחזות; תשתמש רק בשני דגלים:
session.impersonating ו-session.impersonated_tenant_id.
	•	כשחוסם → החזר JSON ברור: {"error":"forbidden","reason":"role_mismatch|no_tenant|scope_fail"}.

9) חוזה נתונים נכון בכתיבה
	•	שמירת פרומפט: הגוף חייב להיות בדיוק
{"calls_prompt":"...","whatsapp_prompt":"..."}.
	•	התחזות: POST /api/admin/businesses/1/impersonate עם ה-CSRF header.
	•	החזרות כתיבה תמיד JSON מלא (לא Error {}).

10) מבחן האמת (3 פקודות — אם זה עובר, סיימת)

BASE=https://<הדומיין-שלך>
# 1) Login (שומר קוקיות)
curl -i -c /tmp/c -b /tmp/c -H 'Content-Type: application/json' \
  -X POST $BASE/api/auth/login --data '{"email":"admin@...","password":"..."}'

# 2) CSRF token + Cookie
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf | python - <<'PY'
import sys,json; print(json.load(sys.stdin)['csrfToken'])
PY
)

# 3) כתיבות אמיתיות (צפוי 200)
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X PUT $BASE/api/business/current/prompt \
  --data '{"calls_prompt":"ok","whatsapp_prompt":"ok"}'

curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" \
  -X POST $BASE/api/admin/businesses/1/impersonate

	•	אם משהו מחזיר 403: זה לא SeaSurf — זה ה-Guard. תקרא את reason מה-JSON ותקן (role/scope/OPTIONS).
	•	אם זה 200 ב-curl אבל נופל בדפדפן → ה-cookie לא נקרא/נשלח (בדוק SameSite/Secure ושה-FE באמת שולח X-CSRFToken).

⸻

שתי בדיקות מהירות שמגלות את השורש בדקה
	•	Application → Cookies: רואה XSRF-TOKEN? הוא לא HttpOnly?
	•	Network → בקשת PUT/POST: רואה header X-CSRFToken עם ערך? אם לא — זו הבעיה. אם כן והשרת עדיין 403 — guard/role/scope.

היצמד לסדר הזה. ברגע שה-cookie וה-header מסונכרנים, ו-guard לא חוסם לפני SeaSurf — שמירת פרומפט, התחזות, “יצירת עסק/ליד” וכל שאר הכתיבות יחזרו לעבוד מיד.