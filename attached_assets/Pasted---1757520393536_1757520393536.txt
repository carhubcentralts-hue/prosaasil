קיבלתי. הנה הנחיה אחת, סגורה וקצרה-לביצוע שתגרום למערכת לעבוד בלי כפילויות, עם נתונים אמיתיים וכל הכפתורים הפועלים. תבצע לפי הסדר, בלי לקפוץ בין שלבים.

⸻

0) “מצב בטוח” – מקור אחד, תהליך אחד

מטרה: להפסיק התנגשויות וקאשינג שמסתירים שינויים.
	1.	הפסק לעבוד מה-Preview (…picard.replit.dev). הכתובת היחידה: https://ai-crmd.replit.app.
	2.	ודא שיש תהליך אחד שמגיש FE+API:
	•	Procfile:

web: gunicorn -k eventlet -w 1 server.wsgi:app --bind 0.0.0.0:${PORT}


	•	מחק/נטרל כל start/serve אחרים (.replit, bash scripts), וכל “שרת עזר” שמאזין על אותו PORT.

	3.	בדפדפן: Clear Storage → רענון קשיח. הוסף תג “BUILD:” בפינה (למשל 29) כדי לראות שאתה על ה־build האחרון.

⸻

1) ניקוי כפילויות – שמור רק מקור אמת אחד לכל שכבה

מטרה: להסיר קבצים שמגדירים אותו דבר פעמיים.
	1.	CSRF (שמור רק SeaSurf אחד):
	•	תשאיר: server/extensions.py (מכיל csrf = SeaSurf()), server/app_factory.py (עושה csrf.init_app(app)).
	•	מחק/נטרל: כל שימוש ב-CSRFProtect (Flask-WTF), כל csrf.exempt_urls() עם פונקציות/קולבקים.
	2.	Routes/Blueprints:
	•	תשאיר רק סט אחד של blueprints: auth_api, admin_api, business_api, whatsapp_api, calls_api, ui.
	•	חפש ומחק כפילויות: routes_*_copy.py, גרסאות ישנות, ו־HTML templates שמוחזרים מ־/api (API חייב להחזיר JSON בלבד).
	3.	Static/FE:
	•	תשאיר: client/ (קוד), client/dist/ (תוצר build).
	•	מחק: client/build/ ישן, public/ לא בשימוש, /assets שהועלו ידנית בעבר.
	4.	דמו/פולבקים:
	•	ב-client חפש ומחק: demo|mock|sample|fallback|FIXME.
אין נתוני דמו, אין ?? demoData.

⸻

2) שירות ה-SPA – נתיב אחד, קאשינג כבוי

מטרה: כל כתובת שאינה /api תחזיר את אותו index.html מה-dist.
	1.	ב־app_factory.py:

@app.route('/assets/<path:filename>')
def assets(filename): return send_from_directory(FE_DIST/'assets', filename)

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def spa(path):
    # אל תיתן לנתיבי /api, /webhook, /static להגיע לכאן
    if path.startswith(('api','webhook','static','assets')):
        abort(404)
    resp = send_from_directory(FE_DIST, 'index.html')
    resp.cache_control.no_store = True
    return resp


	2.	בהפעלה הדפס פעם אחת:

print("FE_DIST =", FE_DIST, "mtime =", FE_DIST.stat().st_mtime)

אם ה-mtime לא משתנה אחרי build — אתה מגיש תיקייה שגויה.

⸻

3) CSRF/Session יציב (בלי לעקוף התחזות)

מטרה: להפסיק 403 בהתחזות ולשמור אבטחה.
	1.	קונפיג SeaSurf (רק אחד):

app.config.update(
  SEASURF_COOKIE_NAME='XSRF-TOKEN',
  SEASURF_HEADER='X-CSRFToken',
  SESSION_COOKIE_SAMESITE='Lax',
  SESSION_COOKIE_SECURE=False,  # בפריוויו/דב בלבד
)


	2.	פטורים (רק): /api/auth/login, /api/auth/logout, ו-webhooks.
התחזות לא פטורה.
	3.	GET /api/auth/csrf קובע קוקי קריא ל-JS ומחזיר {csrfToken}:

token = request.cookies.get('XSRF-TOKEN') or csrf._get_token()
resp.set_cookie('XSRF-TOKEN', token, httponly=False, samesite='Lax', secure=False, path='/')


	4.	דיבוג זמני (מחק אחרי שעובד):

@app.before_request
def _dbg_csrf():
    if request.path.endswith('/impersonate') and request.method=='POST':
        print('CSRF-DBG cookie=', request.cookies.get('XSRF-TOKEN'),
              ' header=', request.headers.get('X-CSRFToken'))



⸻

4) סכימת JSON אחידה (מונע “Business.phone” קריסות)

מטרה: שמות שדות עקביים בין BE↔FE.
	•	טלפון: רק phone_e164.
אם יש קוד ישן עם business.phone, הוסף property ב-Model:

@property
def phone(self): return self.phone_e164
@phone.setter
def phone(self, v): self.phone_e164 = v


	•	מחזירים ב-/api תמיד JSON, לא HTML.

⸻

5) Endpoints מחייבים (שמות, הרשאות, נתונים אמיתיים)

Admin – Businesses
	•	GET /api/admin/businesses?page=&pageSize=&q= → {"items":[...],"total":1,...} (חייב להחזיר את העסק האמיתי).
	•	GET /api/admin/businesses/:id → נתונים לעריכה (עם phone_e164).
	•	PATCH /api/admin/businesses/:id (CSRF) → עדכון ולוג הצלחה.
	•	POST /api/admin/businesses (CSRF) → יצירה; על 200 רענון רשימה.

View vs Impersonate
	•	צפייה (ללא שינוי סשן): GET /api/admin/businesses/:id/overview → קריא-בלבד לעמוד /app/admin/businesses/:id/view.
	•	התחזות (משנה סשן):

@admin_api.post('/api/admin/businesses/<int:id>/impersonate')
def imp(id):
    session['impersonating']=True; session['tenant_id']=id; session['role']='business'
    return jsonify(ok=True, tenant_id=id)

/api/auth/me צריך להחזיר impersonating:true ו-tenant.

Agent Prompts
	•	Admin: GET/PUT /api/admin/businesses/:id/prompt
	•	Business (אחרי התחזות): GET/PUT /api/business/current/prompt
	•	אם אין שורה בטבלה – צור ברירת מחדל והחזר טקסט, לא null.

⸻

6) FE – fetch מרוכז, ללא בסיס חיצוני, שולח CSRF נכון

מטרה: בקשות כתיבה לא יחטפו 403.

export async function apiFetch(url: string, options: RequestInit = {}) {
  const headers = new Headers(options.headers || {})
  headers.set('Accept','application/json')
  const method = (options.method || 'GET').toUpperCase()
  if (!['GET','HEAD','OPTIONS'].includes(method)) {
    headers.set('Content-Type','application/json')
    headers.set('X-Requested-With','XMLHttpRequest')
    const token = document.cookie.match(/(?:^|;\s*)XSRF-TOKEN=([^;]+)/)?.[1]
    if (token) headers.set('X-CSRFToken', decodeURIComponent(token))
  }
  return fetch(url, { ...options, headers, credentials:'include' })
}

	•	לפני התחזות/שמירות: לקרוא פעם אחת GET /api/auth/csrf.
	•	אחרי התחזות (200): קריאה מיידית ל-/api/auth/me לעדכון סטור, ואז ניווט ל-/app/business/overview.

⸻

7) לוגים/שגיאות – שלא נראה עוד “Error {}”

מטרה: לקבל הודעות ברורות.

@app.errorhandler(401)
def e401(e): return jsonify(error="unauthorized"), 401
@app.errorhandler(403)
def e403(e): return jsonify(error="forbidden"), 403
@app.errorhandler(500)
def e500(e): return jsonify(error="server_error"), 500

ב-FE: הדפס res.status ו-await res.text() כשנופל, לא Error {} ריק.

⸻

8) בדיקות קבלה (אל תתקדם לפני שהכול ירוק)

שרת (מה־Shell):

# לוגין (פטור CSRF)
curl -i -c /tmp/c -b /tmp/c -X POST https://ai-crmd.replit.app/api/auth/login \
 -H 'Content-Type: application/json' --data '{"email":"admin@shai-realestate.co.il","password":"*****"}'

# טוקן CSRF
TOKEN=$(curl -s -c /tmp/c -b /tmp/c https://ai-crmd.replit.app/api/auth/csrf \
 | python -c "import sys,json;print(json.load(sys.stdin)['csrfToken'])")

# רשימת עסקים (חייב total=1)
curl -i -c /tmp/c -b /tmp/c https://ai-crmd.replit.app/api/admin/businesses

# התחזות - עם טוקן → 200
curl -i -c /tmp/c -b /tmp/c -X POST https://ai-crmd.replit.app/api/admin/businesses/1/impersonate \
 -H 'Content-Type: application/json' -H "X-CSRFToken: $TOKEN" --data '{}'

# אימות סשן
curl -i -c /tmp/c -b /tmp/c https://ai-crmd.replit.app/api/auth/me

דפדפן (Network):
	•	POST /impersonate מציג גם Cookie XSRF-TOKEN וגם Header X-CSRFToken זהים → Response 200.
	•	עמוד ניהול עסקים מציג את העסק האמיתי (לא דמו), כפתור “עריכה” ממלא נתונים אמיתיים ושומר.
	•	עמוד Agent בעסק – מציג prompt אמיתי; Save עובד; שיחה חדשה משתמשת בפרומפט החדש (לוג טעינה).

⸻

אם משהו עדיין “לא עובד/לא נראה”:
	•	אתה לא על ai-crmd.replit.app (אלא על Preview) או עדיין יש שתי הגדרות לאותו דבר.
	•	שלח 3 דברים מינימליים כדי לנעול:
	1.	צילום מסך עם BUILD: 29 בפינה ב-ai-crmd.replit.app.
	2.	צילום Network של POST /impersonate (Headers+Cookies+Response).
	3.	שורת log של CSRF-DBG cookie=… header=….

ביצוע לפי הסדר הזה מסיר כפילויות, מחזיר את השרת ל-Source of Truth יחיד, מציג נתונים אמיתיים, ומפסיק את 403/“Error {}” אחת ולתמיד.