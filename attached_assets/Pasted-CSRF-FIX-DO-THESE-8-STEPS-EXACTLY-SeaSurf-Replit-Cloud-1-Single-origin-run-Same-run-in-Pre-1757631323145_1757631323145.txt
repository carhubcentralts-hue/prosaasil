CSRF FIX — DO THESE 8 STEPS EXACTLY (SeaSurf, Replit Cloud)
	1.	Single-origin run
	•	Same run in Preview & Deploy: build Vite → Flask serves client/dist/ + API.
	•	No vite dev. All FE fetches use credentials:'include'.
	2.	One CSRF engine
	•	Keep SeaSurf only. Remove any Flask-WTF/CSRFProtect init or second CSRF middleware.
	3.	Exempt list (only these)
	•	POST /api/auth/login, POST /api/auth/logout
	•	All /webhook/**
	•	GET: /healthz, /readyz, /livez, /version
➜ Nothing else is exempt (impersonate, prompts, leads require CSRF).
	4.	Token endpoint + cookies
	•	Add GET /api/auth/csrf that returns {csrfToken} and sets cookie XSRF-TOKEN=<token>.
	•	Cookie flags:
	•	XSRF-TOKEN: HttpOnly=False (JS must read), Path=/,
Preview → SameSite=None; Secure=True,
Deploy → SameSite=Lax; Secure=True.
	•	Session cookie: HttpOnly=True; Secure=True; SameSite like above.
	5.	Frontend client (one place)
	•	On app start and after login: call /api/auth/csrf once.
	•	For every POST/PUT/PATCH/DELETE:
	•	credentials:'include'
	•	Content-Type:'application/json'
	•	Header X-CSRFToken: <value from document.cookie 'XSRF-TOKEN'>
	•	If you see 403 → log the exact cookie & header values to console.
	6.	OPTIONS/CORS (avoid false 403)
	•	Make all JSON routes accept OPTIONS (return 204) so preflight never hits CSRF.
	•	Do not enable cross-origin; we’re single-origin.
	7.	Impersonation & prompts & leads (writes)
	•	Impersonate: POST /api/admin/businesses/:id/impersonate with CSRF header;
set session.impersonating=true & session.impersonated_tenant_id=id (do not change session.user.role).
	•	Prompts save: FE sends exactly { "calls_prompt":"...", "whatsapp_prompt":"..." } with CSRF.
	•	Leads: all create/update/status/reminder/message calls include CSRF header.
	8.	Smoke test (must pass, else stop and report)

# 1) Login (keeps cookies)
curl -i -c /tmp/c -b /tmp/c -H 'Content-Type: application/json' \
  -X POST $BASE/api/auth/login --data '{"email":"admin@...","password":"..."}'

# 2) CSRF token
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf | python - <<'PY'
import sys,json; print(json.load(sys.stdin)['csrfToken'])
PY
)

# 3) Write checks
curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X PUT $BASE/api/business/current/prompt \
  --data '{"calls_prompt":"ok","whatsapp_prompt":"ok"}'

curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" \
  -X POST $BASE/api/admin/businesses/1/impersonate

	•	If any returns 403: print the request headers on FE, verify XSRF-TOKEN cookie exists, X-CSRFToken header is set, flags match (Preview: SameSite=None; Secure=True), and route is not wrongly exempt.

Important gotchas:
	•	If XSRF-TOKEN is HttpOnly=True → FE can’t read it → all writes fail.
	•	If Preview & API are different origins → use SameSite=None; Secure=True for XSRF-TOKEN or unify origin.
	•	Never rely on g.csrf_exempt hacks; keep a short, explicit exempt list only.