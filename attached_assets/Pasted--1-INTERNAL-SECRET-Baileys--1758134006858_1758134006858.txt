מעולה—הגענו לשורש: זו לא בעיית קוד. מהדיווח שלו:
	1.	INTERNAL_SECRET לא היה מוגדר → Baileys יוצא מיד.
	2.	ה־Runner מריץ רק Flask כברירת־מחדל → Baileys בכלל לא עולה.
	3.	כשהרצתם משורת־פקודה, הסשן נסגר אחרי זמן קצר → שני השרתים מתים “בשקט”.
	4.	אין ניהול משותף לשני התהליכים.

הפתרון (4 בעיות ⇒ 4 פעולות) — אחד־לאחד, בלי קיצורים

1) להגדיר סודות/ENV פעם אחת (לשני הצדדים)

ב־Secrets / .env:

INTERNAL_SECRET=<מחרוזת-ארוכה-אקראית-זהה-לשני-הצדדים>
BAILEYS_PORT=3300
BAILEYS_BASE_URL=http://127.0.0.1:3300
FLASK_BASE_URL=http://127.0.0.1:5000

בדיקה:

echo "$INTERNAL_SECRET" | wc -c         # אורך > 20 תווים
echo "$BAILEYS_PORT" "$BAILEYS_BASE_URL" "$FLASK_BASE_URL"

2) מריץ יחיד שמחזיק את שני השרתים (לא מרימים מטאבים!)

אפשרות A (מועדפת): Honcho

pip install honcho

Procfile בשורש:

web: gunicorn -w 1 -k eventlet -b 0.0.0.0:5000 wsgi:app
whatsapp: node services/baileys/server.js

ב־.replit (או ב־Run command):

honcho start -f Procfile

מריצים מהכפתור Run בלבד. לא מטרמינל (שנסגר אחרי דקה).

אפשרות B (אם אי־אפשר לערוך .replit): סקריפט Runner אחד

start_all.sh:

#!/usr/bin/env bash
set -euo pipefail
export PYTHONUNBUFFERED=1
export BAILEYS_PORT="${BAILEYS_PORT:-3300}"
export FLASK_BASE_URL="${FLASK_BASE_URL:-http://127.0.0.1:5000}"
export INTERNAL_SECRET="${INTERNAL_SECRET:?missing}"

node services/baileys/server.js & BAI=$!
gunicorn -w 1 -k eventlet -b 0.0.0.0:5000 wsgi:app & FL=$!

trap 'kill -TERM $BAI $FL 2>/dev/null || true; wait || true' INT TERM
# נשארים חיים כל עוד שני התהליכים חיים
while kill -0 $BAI 2>/dev/null && kill -0 $FL 2>/div/null; do sleep 1; done

ואז שימו את פקודת ה־Run על:

bash ./start_all.sh

3) נקודת כניסה אחת ל-Baileys (כבר כמעט עשיתם, רק לוודא)

services/baileys/server.js

require('../whatsapp/baileys_service').start();

וב־services/whatsapp/baileys_service.js יש module.exports = { start, app } ו־/healthz על אותו app שמבצע listen.

4) יישור כתובות וגריפ שאריות

grep -R --line-number -E "3001|3310" .
# אם קיים → להחליף להפניות דרך BAILEYS_BASE_URL בלבד (3300)


⸻

בדיקות GO (להדביק לו, לבצע ולחזור עם התוצאות אם משהו נופל)

מריצים אך ורק דרך ה-Runner (Honcho/start_all.sh).
בטרמינל נפרד (קריאה בלבד):

# 1) בריאות Baileys (צריך 200 ok)
curl -i -sS http://127.0.0.1:3300/healthz

# 2) התחלת סשן דרך Flask (צריך 200 {"ok":true})
curl -i -sS -X POST http://127.0.0.1:5000/api/whatsapp/start

# 3) סטטוס (צריך 200 JSON; לפני סריקה connected:false, hasQR:true)
curl -i -sS http://127.0.0.1:5000/api/whatsapp/status

# 4) QR (צריך 200 {"dataUrl": "data:image/png;base64,..."} עד הסריקה)
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

אם משהו נכשל — בדיוק מה להחזיר
	•	אם #1 נכשל: תדביק את הלוג המלא של Runner סביב זמן הנפילה (תהיה שם שורת BOOT/EXIT).
	•	אם #2–#4 נכשלות: תדביק את ה־HTTP status וה־body המלאים (מה־curl -i).

⸻

הערות קצרות חשובות
	•	Preview יציג רק את 5000 — זה תקין. ‎3300 פנימי ונגיש דרך /api/whatsapp/*.
	•	Twilio לא נפגע: אותם endpoints על 5000.
	•	הבעיה “עלה ואז מת” הייתה כי הרצתם מטאבים/סשן זמני. הפתרון הוא Runner יחיד שמחזיק את שניהם.

בצעו בדיוק כך. אם אחד הסעיפים (#1–#4) לא עובר—שלח את הפלט כמו שמוגדר, ואכוון אותך נקודתית.