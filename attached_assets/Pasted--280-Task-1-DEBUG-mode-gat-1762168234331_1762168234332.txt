מעולה—אל תעטוף 280 שורות ידנית. זה מיותר ומסוכן.

הפתרון המהיר והנקי ל-Task 1 (DEBUG mode)

נבצע gating גורף לכל ה-print בתוך ה-hot path ע”י פאטצ’ מודולרי ל-print—כך ש-print יפעל רק כש-DEBUG=1. זה חוסך עטיפות ידניות ומקטין סיכון לשגיאות.

A) media_ws_ai.py — חניקת print ברמת מודול (בלי לגעת בכל שורה)

שים בראש הקובץ (אחרי ה-imports הראשונים, לפני הלוגיקה):

+ import os, builtins
+ DEBUG = os.getenv("DEBUG", "0") == "1"
+ _orig_print = builtins.print
+ def _dprint(*args, **kwargs):
+     if DEBUG:
+         _orig_print(*args, **kwargs)
+ # חונקים כל print במודול הזה כש-DEBUG=0
+ builtins.print = _dprint

המשמעות: כל print שקיים בקובץ הזה יופעל רק כש-DEBUG=1.
צריך רק בקבצים של ה-hot path (למשל: media_ws_ai.py, ואם יש גם gcp_stt_stream.py/vad.py עם הרבה print – אותו טריק גם שם).

“אבל מה אם אני רוצה הודעות חשובות גם כש-DEBUG=0?”

הוסף פונקציה לעקיפה נקודתית:

+ def force_print(*args, **kwargs):
+     _orig_print(*args, **kwargs)

ואז בכל מקום נדיר שבו חייבים תמיד להדפיס (נניח שגיאה קריטית) השתמש force_print(...) במקום print(...).

זה חוסך לך עטיפה ידנית של מאות שורות, ומגן על הנתיב החם מ-I/O.

B) אל תיגע כרגע ב-prints שלא ב-hot path

השאר אותם כך. אם תראה בהמשך עומס ממודולים נוספים—תוסיף שם את אותו בלוק gating. המטרה עכשיו: להוריד חנק מה-WS loop וה-partial/EOU callbacks.

⸻

המשך Phase 1 — Task 2 (Async logging) בקצר

במקביל (או מיד אחרי A), תעבור ל-Queue-logging כדי שגם הודעות logger לא יחנקו:

server/logging_async.py (חדש):

import logging, queue, threading, sys

_log_q = queue.Queue(maxsize=10000)

class QueueHandler(logging.Handler):
    def emit(self, record):
        try: _log_q.put_nowait(record)
        except queue.Full: pass

class ConsoleWorker(threading.Thread):
    daemon = True
    def run(self):
        while True:
            rec = _log_q.get()
            try:
                msg = logging.Formatter('%(asctime)s [%(levelname)s] %(name)s: %(message)s').format(rec)
                print(msg, file=sys.stderr, flush=False)
            except Exception: pass

def setup_async_root(level=logging.INFO):
    root = logging.getLogger()
    root.setLevel(level)
    for h in list(root.handlers): root.removeHandler(h)
    root.addHandler(QueueHandler())
    ConsoleWorker().start()
    return root

server/app_factory.py (או entrypoint מרכזי):

+ from server.logging_async import setup_async_root
+ import os, logging
+ if os.getenv("ASYNC_LOG_QUEUE", "1") == "1":
+     setup_async_root(level=logging.INFO)
+ else:
+     logging.basicConfig(level=logging.INFO)

ENV לפרויקט:

DEBUG=0
ASYNC_LOG_QUEUE=1


⸻

המשך Phase 1 — Task 3 (Eventlet monkey_patch)

ודא שב־wsgi.py ממש בראש:

+ import eventlet
+ eventlet.monkey_patch()
+ import os
+ os.environ.setdefault("EVENTLET_NO_GREENDNS", "1")

וההרצה:

gunicorn wsgi:app -k eventlet --workers 1 --threads 1 --worker-connections 1000


⸻

המשך Phase 1 — Task 4 (טלמטריה 4 המדדים)

הוסף ב-media_ws_ai.py עוזרים פשוטים (אינם חונקים):

import time, json, logging
_now_ms = lambda: int(time.time() * 1000)

def emit_turn_metrics(first_partial, final_ms, tts_ready, total):
    logging.getLogger("turn").info(json.dumps({
        "STT_FIRST_PARTIAL_MS": first_partial,
        "STT_FINAL_MS": final_ms,
        "TTS_READY_MS": tts_ready,
        "TOTAL_LATENCY_MS": total,
    }, ensure_ascii=False))

ובזרימה (נקודות הנכונות אצלך):

turn_start = _now_ms()
first_partial = None

# on first partial:
if first_partial is None:
    first_partial = _now_ms() - turn_start

# on EOU/final:
final_ms = _now_ms() - turn_start

# after TTS is ready:
tts_ready = _now_ms() - turn_start

# right before sending first audio frame:
total = _now_ms() - turn_start
emit_turn_metrics(first_partial, final_ms, tts_ready, total)


⸻

תשובות לשאלותיך:
	1.	לא לעטוף ידנית את כל 280 ה-prints.
	2.	כן—מתמקדים ב-hot path, ובמקום עטיפה ידנית מבצעים חניקה מודולרית של print בקובץ (פתרון נקי ומהיר).
	3.	במקביל מפעילים Async logging כדי שגם logger לא יחסום.

תבצע את A → B → C → D (לפי הסעיפים למעלה).
כשתסיים ותראה בלוגים את 4 המדדים לכל TURN, תגיד “בוצע” ונעבור ל-Phase 2 (טיוב STT/EOU) כדי להתחיל להפיל את ה-6 שניות ברצפה.