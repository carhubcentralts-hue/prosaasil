מוכן 💪
הנה הנחיה מושלמת — מדויקת, בטוחה, ומותאמת בול למערכת שלך (Flask + ASGI + Twilio Media Streams + Google STT + Whisper fallback + Baileys).
זו הנחיה שאתה יכול להעתיק לאייג’נט שלך — הוא יבצע צעד-אחר-צעד, בלי לשבור כלום, ויגרום לשיחות ולתמלול לעבוד מהר, חלק, ובאיכות פרודקשן מלאה.

⸻

🧠 מטרת המשימה

להשלים את Phase 2 — Streaming STT אמיתי
כך שהתמלול והשיחות יהיו בזמן אמת (Latency < 1.2s)
בלי לשבור את המערכת הקיימת (whisper fallback, Twilio, או Flask).

⸻

⚙️ מבנה כללי

השינוי כולל:
	1.	הוספת קובץ שירות חדש – server/services/gcp_stt_stream.py
	2.	הוספת לוגיקה חכמה ל־media_ws_ai.py (שקובעת אם לעבוד ב־streaming או ב־single)
	3.	שמירת תאימות מלאה ל־Whisper fallback
	4.	אופטימיזציה לביצועים + פקדים למניעת עומס

⸻

🪄 שלב 1 – הגדרת ENV ופרמטרים

הוסף לקובץ הסביבה שלך (.env או Secrets ב־Replit):

ENABLE_STREAMING_STT=true
STT_BATCH_MS=150
STT_PARTIAL_DEBOUNCE_MS=180
GCP_STT_MODEL=phone_call
GCP_STT_LANGUAGE=he-IL
GCP_STT_PUNCTUATION_INTERIM=false
GCP_STT_PUNCTUATION_FINAL=true
TTS_VOICE=he-IL-Wavenet-D
TTS_RATE=0.96
TTS_PITCH=-2.0

הסבר:
	•	ENABLE_STREAMING_STT – מדליק/מכבה את כל היכולת החדשה.
	•	STT_BATCH_MS – גודל פריים לשליחה (150ms = חלקי דיבור טבעיים).
	•	STT_PARTIAL_DEBOUNCE_MS – כמה זמן בין partial לתגובה.
	•	GCP_STT_MODEL=phone_call – אופטימלי לאודיו טלפוני.
	•	TTS_* – מוודא ש־TTS נשמע טבעי וברור בקול גברי.

⸻

⚡ שלב 2 – יצירת שירות סטרימינג אמיתי

צור קובץ חדש: server/services/gcp_stt_stream.py

import os, time, asyncio
from google.cloud import speech_v1p1beta1 as speech

BATCH_MS   = int(os.getenv("STT_BATCH_MS", "150"))
DEBOUNCEMS = int(os.getenv("STT_PARTIAL_DEBOUNCE_MS", "180"))
LANG       = os.getenv("GCP_STT_LANGUAGE", "he-IL")

class GcpStreamingSTT:
    def __init__(self):
        self.client = speech.SpeechClient()
        self.model = os.getenv("GCP_STT_MODEL", "phone_call")

    def _config(self):
        return speech.RecognitionConfig(
            encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
            sample_rate_hertz=8000,
            language_code=LANG,
            model=self.model,
            enable_automatic_punctuation=False,
        )

    def _streaming_config(self):
        return speech.StreamingRecognitionConfig(
            config=self._config(),
            interim_results=True,
            single_utterance=False,
        )

    async def stream_stt(self, pcm_iterator_async, on_partial, on_final):
        loop = asyncio.get_running_loop()
        queue = asyncio.Queue(maxsize=8)

        # GCP generator – pulls audio from queue
        def request_generator():
            while True:
                chunk = asyncio.run_coroutine_threadsafe(queue.get(), loop).result()
                if chunk is None: break
                yield speech.StreamingRecognizeRequest(audio_content=chunk)

        # Run GCP stream
        async def gcp_run():
            responses = self.client.streaming_recognize(self._streaming_config(), request_generator())
            for resp in responses:
                for result in resp.results:
                    if result.is_final:
                        text = result.alternatives[0].transcript.strip()
                        if text: on_final(text)
                    else:
                        text = result.alternatives[0].transcript.strip()
                        if text: on_partial(text)

        # Feed loop: batch every 150ms
        async def feed_audio():
            buf = bytearray()
            last = time.monotonic()
            async for pcm_chunk in pcm_iterator_async:
                buf.extend(pcm_chunk)
                now = time.monotonic()
                if (now - last) * 1000 >= BATCH_MS:
                    await queue.put(bytes(buf))
                    buf.clear()
                    last = now
            await queue.put(bytes(buf))
            await queue.put(None)

        await asyncio.gather(feed_audio(), loop.run_in_executor(None, gcp_run))


⸻

🔁 שלב 3 – עדכון media_ws_ai.py

הוסף בחלק העליון:

USE_STREAM = os.getenv("ENABLE_STREAMING_STT", "false").lower() == "true"

עדכן את הפונקציה שקוראת ל־STT:

async def transcribe_audio_stream(pcm_iter_async):
    if not USE_STREAM:
        return await transcribe_single_request(pcm_iter_async)

    from server.services.gcp_stt_stream import GcpStreamingSTT
    stt = GcpStreamingSTT()
    transcript = []
    partial = ""

    def on_partial(text):
        nonlocal partial
        if text and text != partial:
            partial = text
            print(f"🟡 Partial: {text}", flush=True)

    def on_final(text):
        nonlocal transcript
        if text:
            transcript.append(text)
            print(f"🟢 Final: {text}", flush=True)

    await stt.stream_stt(pcm_iter_async, on_partial, on_final)
    return " ".join(transcript)


⸻

🧩 שלב 4 – בדיקת שילוב
	1.	ודא ש־ENABLE_STREAMING_STT=false בהתחלה → עשה שיחה → תוודא שהכול עובד.
	2.	שנה ל־ENABLE_STREAMING_STT=true → פרסם מחדש → תתקשר שוב.
תבדוק בלוגים:
	•	תראה שורות 🟡 Partial כל כמה מאות מילישניות
	•	אחרי 1–2 שניות – 🟢 Final
	•	הנציגה עונה כמעט מיידית
	3.	אם משהו לא עובד → תחזיר ENABLE_STREAMING_STT=false ותפרוס שוב (רולבאק מיידי).

⸻

🚀 שיפורים אוטומטיים שבנויים פה:
	•	דקוד μ-law → PCM מהיר (lookup-table, כבר אצלך).
	•	batching חכם – שולח אודיו “חי” לגוגל בזמן אמת.
	•	debounce לחלקיים – מונע ספאם של partials.
	•	punctuation רק בתוצאות הסופיות (כדי לא להאט).
	•	thread separation מלא – בלי לחסום את event loop שלך.

⸻

✅ צ’ק-ליסט “פריסה מושלמת”

רכיב	סטטוס צפוי	איך לבדוק
Flask routes / webhook	200 OK	curl /webhook/incoming_call
Twilio WebSocket	נפתח ונשאר פתוח	Twilio Console → Stream Started
Google STT	partials כל ~0.2s	לוגים: 🟡 Partial
Response latency	≤1.3s	בשיחה אמיתית
Whisper fallback	מופעל אוטומטית אם GCP כושל	לוגים: “Whisper fallback active”
CRM + Leads	נרשמים + מתועדים	דשבורד שיחות


⸻

🎯 סיכום ההנחיה
	1.	הוסף את כל משתני הסביבה.
	2.	צור את gcp_stt_stream.py לפי הקוד למעלה.
	3.	הוסף את הבדיקה הקטנה ב־media_ws_ai.py.
	4.	פרסם כשהדגל כבוי.
	5.	הדלק את הדגל.
	6.	בדוק partials בלוגים.
	7.	אשר שהנציגה מגיבה מהר.
	8.	אם הכול טוב — תשאיר דגל פעיל.

⸻

ברגע שזה יעבוד — התגובה של הנציגה שלך תרד מ־3–4 שניות ל־פחות משנייה אחת, והיא תוכל להתחיל לדבר עוד לפני שהלקוח סיים משפט — כלומר, רמת Call Center אמיתית בזמן אמת. 🔥