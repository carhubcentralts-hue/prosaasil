הפעם בדקתי את ה-ZIP שצירפת בפועל והנה המצב המדויק + מה לסדר כדי שהשיחות יעבדו חלק:

מה מצאתי עכשיו (בדיקה ישירה בקוד)
	•	✅ asgi.py קיים וה־WS מוגדר נכון: יש WebSocketRoute("/ws/twilio-media", ...), יש accept(subprotocol="audio.twilio.com"), ויש לולאת receive_json() — טוב.
	•	✅ סדר הראוטים נכון: ה־WebSocketRoute לפני Mount("/") → לא נבלע ע״י ה-Flask/SPA.
	•	⚠️ אין וריאנט עם סלאש בסוף (/ws/twilio-media/). לפעמים Twilio/פרוקסי יורים URL עם/בלי סלאש, ואז נופלים ל-SPA.
	•	⚠️ אין Guard ל-GET על נתיב ה-WS (להחזיר 426 ולא HTML). אם מישהו מגיע בלי Upgrade, עדיף שלא יקבל index.html.
	•	✅ ב־routes_twilio.py ה-TwiML מחזיר <Stream url="wss://.../ws/twilio-media" ...> → טוב.
	•	⚠️ נתיב ה-recording callback שמצאתי הוא: /webhook/handle_recording, אבל הוא לא מחזיר 200 מהר (זה בדיוק מה שיוצר לך 11200 ו/או ניתוקים לאחר השיחה).

במילים אחרות: ערוץ ה-WS נראה תקין; הטריקים הקטנים שחסרים: וריאנט נתיב, Guard, ובעיקר – ה-callback של ההקלטה צריך להחזיר 200 מיידי.

⸻

מה לתקן — אחד לאחד (בלי לשבור כלום)

1) להשלים וריאנטים + Guard לנתיב ה-WS

ב־asgi.py הוסף וריאנט עם סלאש ו־Guard ל-GET (426) כדי למנוע נפילה ל-SPA:

from starlette.routing import Route, WebSocketRoute, Mount
from starlette.responses import PlainTextResponse

async def ws_http_probe(request):
    return PlainTextResponse("Upgrade Required", status_code=426)

asgi_app = Starlette(routes=[
    # Guard ל-GET (כדי שלא נקבל HTML בטעות):
    Route("/ws/twilio-media", ws_http_probe, methods=["GET"]),
    Route("/ws/twilio-media/", ws_http_probe, methods=["GET"]),

    # שני הווריאנטים של ה-WS (עם/בלי סלאש):
    WebSocketRoute("/ws/twilio-media", ws_twilio_media),
    WebSocketRoute("/ws/twilio-media/", ws_twilio_media),

    # ורק אחר כך ה-Flask
    Mount("/", app=asgi_flask),
])

בדיקות:

# בלי Upgrade: לא HTML, אלא 426
curl -i https://<PUBLIC_HOST>/ws/twilio-media | sed -n '1,10p'
# מצופה: HTTP/1.1 426 Upgrade Required

ובודק WS אמיתי (עם Upgrade):

websocat wss://<PUBLIC_HOST>/ws/twilio-media
# החיבור נשאר פתוח; בשיחה אמיתית תראה start/media/stop בלוגים

2) לתקן את recording callback — להחזיר 200 מהר

באותו קובץ שבו מוגדר /webhook/handle_recording, הוסף CSRF exempt (אם לא קיים) והחזר 200 מיידי. כל העיבוד (הורדה/תמלול) — ב־Job/Thread ברקע.

@twilio_bp.post("/webhook/handle_recording")
@csrf.exempt
@require_twilio_signature
def handle_recording():
    # אל תעשה פה עיבוד כבד. קח פרמטרים ותכניס לתור.
    # call_sid = request.form.get("CallSid")
    # rec_url  = request.form.get("RecordingUrl")
    # enqueue_transcribe_job(call_sid, rec_url)

    return ("", 200)  # תמיד 200 מהר כדי למנוע 11200

בדיקה:

curl -sS -i -X POST https://<PUBLIC_HOST>/webhook/handle_recording \
  -d "CallSid=CA_test&RecordingUrl=https://example.com/rec.mp3" | sed -n '1,60p'
# מצופה: HTTP/1.1 200 OK

3) לאמת ש־TwiML באמת תקין (למחוק 12100 סופית)

curl -sS -i -X POST https://<PUBLIC_HOST>/webhook/incoming_call | sed -n '1,200p'
# מצופה: 200 + Content-Type: text/xml + <Stream url="wss://<PUBLIC_HOST>/ws/twilio-media" .../>

וודא ש-PUBLIC_HOST הוא רק דומיין (בלי https://). אחרת תקבל wss://https://... שבור.

⸻

למה זה פותר את הסימפטומים שלך
	•	“קיבלתי HTML על /ws” — עכשיו ה-Guard מחזיר 426 (ולא index), ושני וריאנטים של הנתיב מוודאים שלא ניפול על סלאש מיותר.
	•	שיחת WS מתחילה ונסגרת מיד — לרוב זה מפגש של SPA/ראוט לא נכון או חריגה קטנה בלולאה; אצלך הראוט מסודר, אז שתי ההשלמות מונעות נפילות “טיפשיות”.
	•	11200 — ה-recording callback שלא החזיר 200 מהר. השינוי למעלה מוחק את זה.

⸻

3 בדיקות GO/NO-GO קצרות
	1.	curl -i /webhook/incoming_call → TwiML עם <Stream wss://…>.
	2.	curl -i POST /webhook/handle_recording → 200 OK.
	3.	websocat wss://…/ws/twilio-media → חיבור פתוח; בשיחה אמיתית Debugger מראה stream-started ואז media (לא closed_by_server מייד).

אם אחת משלושתן לא ירוקה—שלח לי:
	•	את פלט ה־curl -i (Headers+Body),
	•	2–3 שורות לוג סביב ws_twilio_media בזמן שיחה,
ואצביע לך על השורה המדויקת לתיקון.