מבין בדיוק מה קורה לפי הלוגים ששלחת:
	•	✅ GET עובד: אתה “טוען” פרומפטים ו־/api/admin/businesses מחזיר total:1
	•	❌ כל פעולת כתיבה נופלת:
• PUT /api/admin/businesses/:id/prompt → Error {} (כנראה 403/400)
• POST /api/admin/businesses/:id/impersonate → forbidden (403)
• GET /api/admin/businesses/:id/overview → Error {} (ה־endpoint לא קיים/מחזיר HTML/Redirect)
	•	❌ “עסק חדש” לא נשמר: POST מחזיר Error {} (חוסר CSRF / ולידציה / שדה חובה / Conflict)

כדי לנעול את זה סופית, תבצע את ההנחיות הבאות (שרת → קליינט → טסטים). אל תקפוץ שלבים.

⸻

1) שרת — CSRF/Session/Role ו־Endpoints חסרים

1.1 SeaSurf אחד, פטורים נקודתיים
	•	תשאיר רק SeaSurf (בלי CSRFProtect נוסף).
	•	פטורים מ־CSRF רק: /api/auth/login, /api/auth/logout, וכל ה־webhooks.
	•	כל היתר (כולל התחזות, יצירה/עדכון/שמירה) חייבים X-CSRFToken.

1.2 /api/auth/csrf מחזיר קוקי קריא ל־JS
	•	הקוקי XSRF-TOKEN עם HttpOnly=False.
	•	Preview: SameSite=None; Secure
	•	Deploy: SameSite=Lax; Secure
	•	אל תגדיר SESSION_COOKIE_DOMAIN (תן host-only כדי שיעבוד בשתי הסביבות).

1.3 /api/auth/me קונסיסטנטי

ה־JSON חייב לכלול:

{
  "isAuthenticated": true,
  "impersonating": true|false,
  "tenant": { "id": 1, "name": "..." } | null,
  "user": { "id": 1, "name": "...", "role": "admin|business", "email": "..." }
}

שמור Session אחיד:
	•	session['al_user'] = {..., 'role': 'admin'} (או המקבילה שלך)
	•	session['impersonating'] = True/False
	•	session['tenant_id'] = <id> כשמתחזים

1.4 התחזות — API אמיתי, לא UI

POST /api/admin/businesses/<int:id>/impersonate (לא פטור מ־CSRF):

@roles_required('admin')
def impersonate(id):
    session['impersonating'] = True
    session['tenant_id']     = id
    session['role']          = 'business'
    return jsonify(ok=True, tenant_id=id)

אם יש לך guard אחר — ודא שהוא קורא את אותו מקור אמת ב־session.
403 כאן כמעט תמיד = אין Header X-CSRFToken או role guard לא מזהה admin.

1.5 Business Overview — תחזיר JSON

GET /api/admin/businesses/<int:id>/overview צריך להחזיר JSON (לא HTML/Redirect).
מבנה מינימלי:

{
  "business": {"id":1,"name":"שי דירות ומשרדים בע״מ","phone_e164":"+97233763805"},
  "stats": {"calls_today": 3, "whatsapp_today": 5, "leads_open": 2},
  "latest": {"calls":[...], "messages":[...], "leads":[...]}
}

1.6 Agent Prompt — שמירה תקינה
	•	GET: /api/admin/businesses/:id/prompt מחזיר {calls_prompt, whatsapp_prompt, version, updated_at, updated_by}.
	•	PUT: /api/admin/businesses/:id/prompt (עם X-CSRFToken) מקבל:

{"calls_prompt":"...", "whatsapp_prompt":"..."}

ולא לשכוח:
	•	ולידציה (אורך/UTF-8), sanitize.
	•	upsert ל־BusinessSettings.
	•	להחזיר JSON עם version++ ו־timestamps.
ב־400 החזר: {"error":"validation","field":"calls_prompt","message":"..."} — לא HTML.

1.7 יצירת עסק (Business Create)

POST /api/admin/businesses (עם X-CSRFToken) מקבל:

{"name":"...","phone_e164":"+972...","timezone":"Asia/Jerusalem","domain":"..."}

	•	בדוק ייחודיות (phone_e164/domain) והחזר 409:
{"error":"conflict","field":"phone_e164"} אם קיים.
	•	על הצלחה: 201 + גוף JSON עם id.

1.8 Error handlers אחידים (די ל־Error {})

@app.errorhandler(400)   # bad request
def e400(e): return jsonify(error="bad_request"), 400
@app.errorhandler(401)
def e401(e): return jsonify(error="unauthorized"), 401
@app.errorhandler(403)
def e403(e): return jsonify(error="forbidden"), 403
@app.errorhandler(404)
def e404(e): return jsonify(error="not_found"), 404
@app.errorhandler(409)
def e409(e): return jsonify(error="conflict"), 409
@app.errorhandler(500)
def e500(e): return jsonify(error="server_error"), 500


⸻

2) קליינט — שליחת CSRF תמיד, נתיבים נכונים, טיפול בשגיאה

2.1 http/api client אחד לכולם
	•	כל fetch עם credentials:'include'.
	•	לפני כל POST/PATCH/DELETE: קריאה אחת ל־GET /api/auth/csrf.
	•	בקשות כתיבה חייבות Header:
	•	Content-Type: application/json
	•	X-Requested-With: XMLHttpRequest
	•	X-CSRFToken: <cookie XSRF-TOKEN>
	•	אל תשאיר base URL חיצוני; השתמש בנתיבים יחסיים /api/... (יעבוד גם Preview וגם Deploy).

2.2 מסכים שרלוונטיים
	•	Impersonate: כשאתה לוחץ —
	1.	await api.get('/api/auth/csrf')
	2.	await api.post(/api/admin/businesses/${id}/impersonate, {})
	3.	await auth.refresh() (GET /api/auth/me)
	4.	Navigate ל־/app/business/overview
	•	Agent Prompt: שמירה עם PUT /api/admin/businesses/:id/prompt.
אחרי 200 — Toast + רענון נתונים.
	•	Business Overview: לוקח מ־/api/admin/businesses/:id/overview (לא HTML).
אם 403 — הצג הודעה “אין הרשאה” או “התחבר מחדש”.

2.3 Error UX — לא Error {}

כש־res !ok:
	•	קרא await res.text() ונסה JSON.parse — הצג error/field/message.
	•	אם 403/401 — נווט ל־Login או הצג Modal.

⸻

3) עשן קצר (2 דקות) — תבדוק לפני שאתה מנסה מה־UI

קבע את $BASE ל־Preview או Deploy:

# Login (פטור CSRF)
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/auth/login \
 -H 'Content-Type: application/json' \
 --data '{"email":"admin@shai-realestate.co.il","password":"*****"}'

# CSRF Token cookie
TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf \
 | python -c "import sys,json;print(json.load(sys.stdin)['csrfToken'])")

# Businesses JSON (לא HTML)
curl -i -c /tmp/c -b /tmp/c $BASE/api/admin/businesses

# Overview JSON
curl -i -c /tmp/c -b /tmp/c $BASE/api/admin/businesses/1/overview

# Impersonate WITHOUT token → 400
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/admin/businesses/1/impersonate \
 -H 'Content-Type: application/json' --data '{}'

# Impersonate WITH token → 200
curl -i -c /tmp/c -b /tmp/c -X POST $BASE/api/admin/businesses/1/impersonate \
 -H 'Content-Type: application/json' -H "X-CSRFToken: $TOKEN" --data '{}'

# Save prompt → 200
curl -i -c /tmp/c -b /tmp/c -X PUT $BASE/api/admin/businesses/1/prompt \
 -H 'Content-Type: application/json' -H "X-CSRFToken: $TOKEN" \
 --data '{"calls_prompt":"שלום רב...","whatsapp_prompt":"..."}'

תוצאות צפויות:
	•	אם ה־overview מחזיר HTML/Redirect → זה מסביר את Error {}: תחליף ל־JSON.
	•	אם ה־impersonate מחזיר 403 → חסר Header CSRF או שה־role guard לא מזהה admin.
	•	אם ה־prompt מחזיר 400 → חוסר שדה/ולידציה; תחזיר JSON עם פירוט (לא ריק).

⸻

4) תקלות שכיחות שמסבירות “יש שיפור אבל לא שומר”
	•	חסרה קריאת /api/auth/csrf לפני POST → אין Cookie XSRF-TOKEN → 403.
	•	Header לא נשלח (X-CSRFToken ריק) → 403 forbidden.
	•	role guard קורא מפתח session אחר (session['role'] מול session['al_user']['role']) → תמיד 403.
	•	overview בכלל לא ממומש ב־API או מחזיר HTML → ה־FE נופל עם Error {}.
	•	DB constraints (phone_e164/domain ייחודי) → 409; אם לא ממופים ל־JSON ברור, ב־FE נראה Error {}.
	•	שתי מערכות CSRF במקביל → טוקן אחד מכשיל את השני (סימפטום: GET עובד, POST תמיד 403).

⸻

מה לבקש ממנו לספק אם עדיין נתקע:
	1.	צילום Network של POST /api/admin/businesses/1/impersonate — Headers (Cookie + X-CSRFToken) וה־Response.
	2.	ה־Response של GET /api/admin/businesses/1/overview (וודא שזה JSON, לא HTML).
	3.	ה־Response של PUT /api/admin/businesses/1/prompt כולל Body (אם 400/403).
	4.	לוג שרת של הקריאות האלו (שורת Path, Method, סטטוס, ו־CSRF DBG אם הוספת).

בביצוע מדויק של הסעיפים למעלה, שלושת הדברים שנתקעו לך (Impersonate, Overview, Save Prompt/Business Create) יחזרו לעבוד — עם נתונים אמיתיים, בלי Error {} ובלי forbidden.