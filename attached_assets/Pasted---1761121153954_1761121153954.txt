מעולה—הולכים לפתור את הברכה האיטית אחת ולתמיד, בלי לשבור כלום. הנה הנחיה “מושלמת” למפתח שלך, צעד-אחר-צעד, עם קוד מדויק, שמייצרת Greeting Cache (ברכה מוכנה מראש כפריימי μ-law של 20ms), בטוח, מהיר, ועם fallback אם משהו נכשל.

⸻

מטרות
	1.	להשמיע ברכה מיד בתחילת השיחה (≤0.2s).
	2.	לשמור התאמה אישית לכל עסק (טקסט/קול/שפה).
	3.	לא לשבור את זרימת ה־WS/‏STT/‏AI/‏TTS.
	4.	לא לקרוס: fallback אוטומטי ל־TTS “on the fly” אם אין Cache.

⸻

שלב 1 — Service קטן: GreetingCache (in-memory, בטוח ל־threads)

קובץ חדש: server/services/greeting_cache.py

# -*- coding: utf-8 -*-
import base64, hashlib, threading, time
from typing import Dict, Tuple, List, Optional

MU_FRAME_MS   = 20    # 20ms per frame
SAMPLE_RATE   = 8000  # 8kHz
BYTES_PER_FR  = 160   # μ-law 8kHz -> 160B for 20ms

Key = Tuple[str, str, str, str]  # (business_id, locale, voice_id, text_hash)

class GreetingCache:
    def __init__(self, max_businesses: int = 256):
        self._lock  = threading.RLock()
        self._data: Dict[Key, List[str]] = {}
        self._meta: Dict[Key, float]     = {}  # last_access for simple LRU
        self._max   = max_businesses

    @staticmethod
    def make_key(business_id: str, locale: str, voice_id: str, text: str) -> Key:
        text_hash = hashlib.sha256(text.strip().encode('utf-8')).hexdigest()[:16]
        return (business_id, locale, voice_id, text_hash)

    def get(self, key: Key) -> Optional[List[str]]:
        with self._lock:
            frames = self._data.get(key)
            if frames:
                self._meta[key] = time.time()
            return frames

    def put(self, key: Key, frames: List[str]) -> None:
        with self._lock:
            # LRU cleanup if overflow
            if key not in self._data and len(self._data) >= self._max:
                oldest_key = min(self._meta, key=lambda k: self._meta.get(k, 0.0))
                self._data.pop(oldest_key, None)
                self._meta.pop(oldest_key, None)
            self._data[key] = frames
            self._meta[key] = time.time()

    def invalidate_business(self, business_id: str) -> int:
        with self._lock:
            keys_to_del = [k for k in self._data if k[0] == business_id]
            for k in keys_to_del:
                self._data.pop(k, None)
                self._meta.pop(k, None)
            return len(keys_to_del)

מחזיק רשימת פריימים ב־base64 (כל פריים 20ms μ-law). LRU פשוט כדי שלא יתנפח.

⸻

שלב 2 — פונקציות עזר: TTS → μ-law → 20ms frames (Base64)

קובץ: server/services/audio_utils.py (או קיים אצלכם, הוסף/התאם)

import audioop, base64

SAMPLE_RATE = 8000
BYTES_PER_FR = 160  # 20ms μ-law

def pcm16_to_mulaw(pcm16_bytes: bytes) -> bytes:
    # pcm16 (little-endian) -> mulaw 8bit
    return audioop.lin2ulaw(pcm16_bytes, 2)

def split_mulaw_to_20ms_frames(mulaw_bytes: bytes) -> list[str]:
    # כל פריים 20ms: 160B ב-8kHz
    frames_b64 = []
    for i in range(0, len(mulaw_bytes), BYTES_PER_FR):
        chunk = mulaw_bytes[i : i + BYTES_PER_FR]
        if len(chunk) < BYTES_PER_FR:
            break
        frames_b64.append(base64.b64encode(chunk).decode('ascii'))
    return frames_b64


⸻

שלב 3 — בניית הברכה ושמירה ל־Cache

קובץ: server/services/greeting_builder.py

from .greeting_cache import GreetingCache
from .audio_utils import pcm16_to_mulaw, split_mulaw_to_20ms_frames
# נניח שיש לכם שירות TTS קיים: synthesize_tts(text, voice_id, locale) -> pcm16 @8kHz
# אם 22k/24k, המירו ל-8kHz לפני lin2ulaw.

_greeting_cache = GreetingCache()

def get_cached_greeting_frames(business_id: str, locale: str, voice_id: str, greeting_text: str,
                               tts_synth_func) -> list[str]:
    """
    מחזיר רשימת פריימים base64 של ברכה מוכנה.
    אם לא קיים ב-cache -> מסנתז ושומר.
    tts_synth_func: callable(text, voice_id, locale) -> bytes PCM16 @8kHz
    """
    key = GreetingCache.make_key(business_id, locale, voice_id, greeting_text)
    cached = _greeting_cache.get(key)
    if cached:
        return cached

    # סינתזה חד-פעמית
    pcm16 = tts_synth_func(greeting_text, voice_id, locale)  # דאגו שיחזיר 8kHz PCM16
    mulaw = pcm16_to_mulaw(pcm16)
    frames = split_mulaw_to_20ms_frames(mulaw)
    _greeting_cache.put(key, frames)
    return frames

def invalidate_greeting_for_business(business_id: str) -> int:
    return _greeting_cache.invalidate_business(business_id)

אין שינוי בזרימת AI/STT. רק שכבת קאש לברכה.

⸻

שלב 4 — הזרקת הברכה בתחילת שיחה (ב־WebSocket handler)

ב־handler שבו אתה מתחיל את שיחת המדיה (למשל media_ws_ai.py), מיד אחרי ש־WS עולה (אחרי accept), לפני כל דבר אחר:

from server.services.greeting_builder import get_cached_greeting_frames

async def on_ws_connected(self):
    biz_id   = self.session.business_id
    locale   = self.session.locale or "he-IL"
    voice_id = self.session.voice_id or "he-IL-Standard-D"  # או מה שבחרת
    greeting_text = self.session.greeting_text  # נלקח מה-DB, מותאם לעסק

    try:
        frames = get_cached_greeting_frames(
            business_id=biz_id,
            locale=locale,
            voice_id=voice_id,
            greeting_text=greeting_text,
            tts_synth_func=self.tts_synthesize_pcm16_8khz  # פונקציה קיימת אצלך
        )
        # הזרמה מיידית - דרך ה-queue האחיד (לא WS ישיר!)
        for b64 in frames:
            await self._tx_enqueue(b64)  # חשוב: דרך התור, לא לעקוף!
    except Exception as e:
        print(f"⚠️ Greeting cache fail -> fallback TTS on-the-fly: {e}", flush=True)
        # fallback: סנתז ושלח live (כבר קיים אצלך), אבל עדיין דרך התור
        await self._speak_text_now(greeting_text, voice_id, locale)

אסור לשלוח ישירות ל־WS. הכול עובר דרך _tx_enqueue → _tx_loop (כמו שכבר תיקנת).

⸻

שלב 5 — אינוואלידציה אוטומטית כשעורכים עסק

כשהמשתמש משנה ברכה/קול/שפה ב־UI, קרא ל־API קטן שמנקה קאש לאותו עסק:
Route קטן: server/routes_greeting.py

from flask import Blueprint, request, jsonify
from server.services.greeting_builder import invalidate_greeting_for_business

bp = Blueprint("greeting", __name__)

@bp.route("/api/greeting/invalidate", methods=["POST"])
def invalidate():
    biz = request.json.get("business_id")
    if not biz:
        return jsonify({"ok": False, "error": "missing business_id"}), 400
    removed = invalidate_greeting_for_business(biz)
    return jsonify({"ok": True, "removed": removed})

ובצד ה־UI, אחרי “שמירה” של עסק — לקרוא ל־POST /api/greeting/invalidate.

אפשר גם לוותר על API ולהסתמך על שינוי ה־hash (כי טקסט/קול חדש ⇒ key חדש). ה־invalidate רק מנקה זיכרון.

⸻

שלב 6 — בטיחות/ביצועים
	•	תזמון WS נשאר אותו דבר (20ms/frame, tx_q=120, drop-oldest, telemetry).
	•	אין נגיעה ל־STT/AI. כל השיפורים שם נשארים.
	•	Cache גמיש: אם TTS נכשל/מאט — אנחנו ב־try/except עם fallback בטוח.
	•	LRU פשוט כדי לא לגדול ללא שליטה (ברירת מחדל 256 עסקים, תשנה אם צריך).

⸻

שלב 7 — בדיקות GO/NO-GO (2 דקות)
	1.	שיחה ראשונה לעסק חדש: ראה בלוג:
	•	“TTS synth…” פעם אחת → “cached X frames”.
	•	הברכה נשמעת אחרי ~0.5–1.0s (חד-פעמי), מהשיחה הבאה מיד.
	2.	שיחה שנייה:
	•	“cache hit”, אין קריאה ל־TTS, הפריימים מוזרמים מייד.
	•	fps≈50, q<10, drops=0.
	3.	שינוי ברכה/קול:
	•	עשה שמירה ב־UI → קריאת invalidate (אופציונלי).
	•	שיחה הבאה: סינתזה מחדש → נשמר לקאש → מהשיחה שלאחריה מיידי.

⸻

הערות שימושיות
	•	עברית: אם ה־TTS שלך באיכות 22k/24k PCM, המרת resample ל־8kHz לפני lin2ulaw (אפשר עם audioop.ratecv).
	•	SSML/פיסוק: הורד <break> ונקודות מיותרות כדי לא להוסיף דיליי מלאכותי בברכה.
	•	קונפיג דרך ENV (במידת רצון): GREETING_CACHE_MAX=256, GREETING_VOICE_DEFAULT=he-IL-Standard-D, וכו’.

⸻

למה זה לא יפיל את המערכת
	•	cache הוא in-memory עם lock קצר, ללא I/O חיצוני.
	•	כל שליחה דרך _tx_enqueue → מכבד את כל ההגנות שכבר בנית (rate, back-pressure, drop-oldest).
	•	כל כשל עטוף ב־try/except עם fallback ל־TTS חי — אין מצב לקריסה.

⸻

בכך תבטיח:
	•	ברכה מיידית (0.1–0.2s) בשיחה 2 והלאה לכל עסק, מותאמת אישית במלואה.
	•	בלי שינוי ל־STT/AI/WS מעבר למה שכבר ייצבת.
	•	בטיחות מלאה עם fallback וללא סיכוני deadlocks/הצפות.

צריך שאכין לך גם patch מוכן כ־diff?