ברור. לפי הדיווח האחרון שלך – שני השרתים עולים (רואים לוג “BOOT/WSGI”) ואז מתים “בשקט”; curl ל-5000/3300 נכשל אחרי דקה-שתיים; אין stacktrace.
מכאן המסקנה: זו לא קריסת קוד אלא אופן ההרצה — התהליכים שאתה מפעיל מהטראמינלים נסגרים ע״י הסביבה (סגירת session/timeout), כי הם לא רצים תחת ה-Runner הראשי. את זה פותרים ב־מריץ יחיד (Runner) שמחזיק את שניהם בחזית, עם לוגים ולכידה של סיגנלים/יציאות.

להלן הנחיה אחת-לאחת (בלי “קישוטים”), שעושה שלושה דברים:
	1.	נקודת כניסה אחת לבייליס (כבר עשית — טוב מאוד).
	2.	מריץ יחיד (Honcho או סקריפט פיקוח) שמחזיק גם Flask וגם Baileys בחזית.
	3.	בדיקות GO קצרות, ואם עדיין נופל — נדע בדיוק מי הורג (נראה exit code/סיגנל).

⸻

1) קבע מריץ ראשי יחיד (Runner) — לא מרימים יותר ידנית מטאבים

אפשרות A (מועדפת): Honcho + Procfile
	1.	התקן Honcho (פעם אחת):

pip install honcho

	2.	צור/עדכן קובץ Procfile בשורש:

web: python -u main.py
whatsapp: node services/baileys/server.js

	3.	בקובץ .replit הגדר שה-Run מריץ את Honcho:

run = "honcho start -f Procfile"

	4.	להריץ דרך כפתור Run של הסביבה (לא דרך טרמינל!).
ה-Runner יישאר חי, ושני השירותים יופיעו בלוג אחד, ולא יסגרו כשסשן טרמינל ימות.

אפשרות B (אם לא משתמשים ב-Honcho): סקריפט פיקוח אחד

צור start_all.sh בשורש והדבק:

#!/usr/bin/env bash
set -euo pipefail
export PYTHONUNBUFFERED=1
export BAILEYS_PORT="${BAILEYS_PORT:-3300}"
export FLASK_BASE_URL="${FLASK_BASE_URL:-http://127.0.0.1:5000}"
export INTERNAL_SECRET="${INTERNAL_SECRET:?missing}"

mkdir -p logs

# מרימים את Baileys בחזית משנה, עם לוג לקובץ וקונסול
stdbuf -oL -eL node --trace-uncaught --unhandled-rejections=strict services/baileys/server.js \
  2>&1 | tee -a logs/baileys.log & BAI=$!

# מרימים את Flask (בחר אחד מהשניים)
# python -u main.py 2>&1 | tee -a logs/flask.log & FL=$!
gunicorn -w 1 -k eventlet -b 0.0.0.0:5000 wsgi:app 2>&1 | tee -a logs/flask.log & FL=$!

trap 'echo "[TRAP] stopping..."; kill -TERM $BAI $FL 2>/dev/null || true; wait || true' INT TERM

# נמתין, ואם אחד נופל – נדפיס קוד יציאה ונסגור את השני כדי שיהיה ברור שיש תקלה
while true; do
  if ! kill -0 $BAI 2>/dev/null; then
    echo "[EXIT] Baileys exited ($BAI)"; break
  fi
  if ! kill -0 $FL 2>/dev/null; then
    echo "[EXIT] Flask exited ($FL)"; break
  fi
  sleep 1
done
kill -TERM $BAI $FL 2>/dev/null || true
wait || true

תן הרשאות והרצה דרך ה-Runner הראשי (לא טרמינל אקראי):

chmod +x start_all.sh
./start_all.sh

אם הסביבה שלך מאפשרת להגדיר “Run Command” — שים שם את ./start_all.sh.

שורה תחתונה: מרגע ששניהם רצים תחת מריץ יחיד (Run הראשי) — הסביבה לא תהרוג אותם כשסשן טרמינל נסגר, ולא תראה עוד “עלו → מתו בשקט”.

⸻

2) אימות חי (GO/NO-GO) — דקה

בטרמינל נפרד (לקריאה בלבד):

# צריך לקבל "ok"
curl -sS http://127.0.0.1:3300/healthz

# התחלת סשן דרך Flask
curl -i -sS -X POST http://127.0.0.1:5000/api/whatsapp/start

# סטטוס ו-QR (דרך Flask)
curl -i -sS http://127.0.0.1:5000/api/whatsapp/status
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

מצב תקין:
	•	healthz → 200 ok
	•	start → 200 {"ok":true}
	•	status → 200 {connected:false, hasQR:true} (עד סריקה)
	•	qr → 200 {"dataUrl":"data:image/png;base64,..."}

חשוב: Preview מציג רק את 5000 — זה תקין. ‎3300 פנימי, ונגיש רק דרך /api/whatsapp/*.

⸻

3) אם שוב מתים “בשקט” — איפה לעצור ומה לשלוח (בדיוק)

אל תריץ מטאבים. תן ל-Runner להחזיק אותם (Honcho/start_all.sh).
אם אחד מת:
	1.	מהופיע בלוג של ה-Runner (או בקבצי logs/*.log) סביב הנפילה?
חפש שורות: [EXIT], [UNHANDLED], [UNCAUGHT], [SERVER ERROR], OutOfMemory, ENOMEM.
	2.	הדבק לי בדיוק את 4 הפקודות עם כותרות:

curl -i -sS http://127.0.0.1:3300/healthz
curl -i -sS -X POST http://127.0.0.1:5000/api/whatsapp/start
curl -i -sS http://127.0.0.1:5000/api/whatsapp/status
curl -i -sS http://127.0.0.1:5000/api/whatsapp/qr

	3.	ואם ה-Runner הדפיס שורה כמו [EXIT] Baileys exited (...) או [EXIT] Flask exited (...) — הדבק אותה (זה אומר מי נסגר ראשון).

⸻

למה זה “סוגר את זה אחת ולתמיד”
	•	כשמריצים מטאב — הסביבה נוטה להרוג את התהליך עם סגירת הסשן/timeout → לכן “עלה ואז מת בשקט”.
	•	מריץ יחיד (Runner) מחזיק את שני התהליכים בחזית, מייצר לוג יחיד, ומונע סגירה “שקטה”.
	•	אם בכל זאת משהו יסגר — תראה את זה מיד (שורת [EXIT]) ותדע מי מת ומתי → כבר לא “שקט”.

אם אתה רוצה, אנסח לך במילים שלך הודעה לסוכן שתדביק לו: “העבר להרצה דרך Runner הראשי בלבד עם Honcho/Procfile כפי שמוגדר, אל תפעיל מטאבים, ואז תדביק 4 פקודות curl + שורת EXIT מהלוג”.