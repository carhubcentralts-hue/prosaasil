××¢×•×œ×”â€”×¢×›×©×™×• ×›×©×”×›×•×œ â€œ×›××¢×˜â€ ×¢×•×‘×“, ××” ×©× ×©××¨ ×–×” **× ×™×”×•×œ ×ª×•×¨×•×ª (turn-taking)**, **×× ×™×¢×ª ×›×¤×™×œ×•×™×•×ª**, ×•-**Barge-in** (×¢×¦×™×¨×ª ×“×™×‘×•×¨ ×”×‘×•×˜ ×›×©×‘×Ÿ-××“× ××ª×—×™×œ ×œ×“×‘×¨). ×”×œ×•×¤×™× ×©××ª×” ×©×•××¢ × ×•×‘×¢×™× ××–×” ×©Ö¾AI ××¤×¢×™×œ *××ª ××•×ª×” ×ª×’×•×‘×”* ×™×•×ª×¨ ××¤×¢× ××—×ª ×¢×œ ××•×ª×• ××‘×¢, ××• ×××©×™×š ×œ×©×“×¨ ×‘×–××Ÿ ×©×”××“× ×›×‘×¨ ××“×‘×¨.

×œ×”×œ×Ÿ ×”× ×—×™×” ×××•×§×“×ª (×“×‘×§-×•×”×¤×¢×œ) ×©× ×•×ª× ×ª ×œ×š:

1. ××›×•× ×ªÖ¾××¦×‘×™×: LISTENING â†’ THINKING â†’ SPEAKING
2. ×“×”Ö¾×‘×•× ×¡ ××‘×¢ (×¡×•×£-××‘×¢ ×—×“ ×•×‘×¨×•×¨; ×¤×¢× ××—×ª ×‘×œ×‘×“)
3. Barge-in: ×”×‘×•×˜ ××¤×¡×™×§ ×œ×“×‘×¨ ×›×©×‘×Ÿ-××“× ××ª×—×™×œ
4. ×©×œ×™×—×ª ××•×“×™×• ×‘Ö¾20ms ×‘×œ×‘×“, ×¢× ×ª×•×¨Ö¾×©×™×“×•×¨ (TX) × ×¤×¨×“ ×›×š ×©××¤×©×¨ ×œ×¢×¦×•×¨ ××™×“

---

# âœ… ×©×™× ×•×™×™× ××™× ×™××œ×™×™× (Idempotent) â€“ `server/media_ws.py`

## 1) ×§×‘×•×¢×™× ×•Ö¾state

```python
# ×œ××¢×œ×” ×‘×§×•×‘×¥:
import os, json, time, base64, audioop, math, threading, queue

SR = 8000
MIN_UTT_SEC = float(os.getenv("MIN_UTT_SEC", "0.7"))   # ×–××Ÿ ×“×××” ×œ×¡×•×£-××‘×¢
MAX_UTT_SEC = float(os.getenv("MAX_UTT_SEC", "6.0"))   # ×—×™×ª×•×š ×‘×˜×™×—×•×ª
VAD_RMS = int(os.getenv("VAD_RMS", "200"))             # ×¡×£ ×“×™×‘×•×¨ (RMS)
BARGE_IN = os.getenv("BARGE_IN", "true").lower() == "true"

STATE_LISTEN = "LISTENING"
STATE_THINK  = "THINKING"
STATE_SPEAK  = "SPEAKING"
```

## 2) ××ª×—×•×œ ×”×”× ×“×œ×¨ + ×ª×•×¨Ö¾×©×™×“×•×¨ × ×¤×¨×“ (×××¤×©×¨ ×¢×¦×™×¨×” ××™×™×“×™×ª)

```python
class MediaStreamHandler:
    def __init__(self, ws):
        self.ws = ws
        self.mode = os.getenv("WS_MODE", "AI").upper()
        self.stream_sid = None

        # Rx / Tx
        self.rx_frames = 0
        self.tx_frames = 0

        # ××¦×‘ ×©×™×—×”
        self.state = STATE_LISTEN
        self.speaking = False
        self.processing = False            # ××•× ×¢ _process_utterance ×›×¤×•×œ
        self.last_rx_ts = None
        self.buf_pcm16 = bytearray()       # ×‘××¤×¨ ××‘×¢ ×”× ×•×›×—×™
        self.last_reply_text = None        # ×× ×™×¢×ª ×œ×•×¤×™× ×©×œ ××•×ª×” ×ª×©×•×‘×”

        # ×ª×•×¨ ×©×™×“×•×¨ ××¡×™× ×›×¨×•× ×™ (××¤×©×¨ ×œ×¢×¦×•×¨ ××™×“)
        self.tx_q: queue.Queue[dict] = queue.Queue(maxsize=4096)
        self.tx_thread = threading.Thread(target=self._tx_loop, daemon=True)
        self.tx_running = False
```

## 3) ×œ×•×œ××ª Rx (×§×‘×œ×ª ×¤×¨×™×™××™×) â€“ ×¢× turn-taking ×•Ö¾barge-in

```python
def run(self):
    try:
        while True:
            raw = self.ws.receive()
            if raw is None:
                break
            evt = json.loads(raw)
            et = evt.get("event")

            if et == "start":
                self.stream_sid = evt["start"]["streamSid"]
                self.last_rx_ts = time.time()
                print(f"WS_START sid={self.stream_sid} mode={self.mode}")
                # ××¤×¢×™×œ ××©×“×¨ ××¡×™× ×›×¨×•× ×™
                if not self.tx_running:
                    self.tx_running = True
                    self.tx_thread.start()
                # ×¤×ª×™×—×ª ×”×©×™×—×” â€“ ×‘×¨×›×” ×§×¦×¨×” (TTS) ×¤×¢× ××—×ª
                if self.mode == "AI":
                    self._speak_text("×©×œ×•×! ××™×š ××¤×©×¨ ×œ×¢×–×•×¨?")
                continue

            if et == "media":
                self.rx_frames += 1
                b64 = evt["media"]["payload"]
                mulaw = base64.b64decode(b64)
                pcm16 = audioop.ulaw2lin(mulaw, 2)
                self.last_rx_ts = time.time()

                # ××“×“ ×“×™×‘×•×¨/×©×§×˜
                rms = audioop.rms(pcm16, 2)
                is_voice = rms > VAD_RMS

                # Barge-in: ×× ×”×‘×•×˜ ××“×‘×¨ ×•×”××“× ×”×ª×—×™×œ ×œ×“×‘×¨ â†’ ×œ×¢×¦×•×¨ ××™×“
                if BARGE_IN and self.state == STATE_SPEAK and is_voice:
                    self._interrupt_speaking()
                    # × ××©×™×š ×œ×”××–×™×Ÿ ×œ××‘×¢ ×”×—×“×©
                    self.state = STATE_LISTEN

                # ××™×¡×•×£ ××‘×¢ ×¨×§ ×›×©×× ×—× ×• ×‘××¦×‘ ×”××–× ×”
                if self.mode == "AI" and self.state == STATE_LISTEN and not self.speaking:
                    self.buf_pcm16.extend(pcm16)

                    dur = len(self.buf_pcm16) / (2 * SR)
                    silent_enough = (time.time() - self.last_rx_ts) >= MIN_UTT_SEC
                    too_long = dur >= MAX_UTT_SEC

                    # ×¡×•×£-××‘×¢: ×¤×¢× ××—×ª ×‘×œ×‘×“ (processing guard)
                    if (silent_enough or too_long) and dur > 0.3 and not self.processing:
                        self.processing = True
                        self.state = STATE_THINK
                        utt_pcm = bytes(self.buf_pcm16)
                        self.buf_pcm16.clear()
                        try:
                            self._process_utterance(utt_pcm)
                        finally:
                            self.processing = False
                            # ×—×•×–×¨×™× ×œ×”××–× ×” ×¨×§ ×× ×œ× ×”×ª×—×™×œ ×“×™×‘×•×¨ (×™×›×•×œ ×œ×”×™×•×ª ×©×§×¤×¦× ×• ×œ×“×™×‘×•×¨)
                            if not self.speaking:
                                self.state = STATE_LISTEN
                continue

            if et == "stop":
                print(f"WS_STOP sid={self.stream_sid} rx={self.rx_frames} tx={self.tx_frames}")
                break

    except Exception as e:
        print("WS_HANDLER_ERR:", e)
    finally:
        try: self.ws.close()
        except: pass
        # ×¡×™×•× ×ª×•×¨ ×”×©×™×“×•×¨
        self.tx_running = False
        try: self.tx_q.put_nowait({"type": "end"})
        except: pass
        print(f"WS_DONE sid={self.stream_sid} rx={self.rx_frames} tx={self.tx_frames}")
```

## 4) ×ª×•×¨ ×”×©×™×“×•×¨ (TX) â€“ 20ms Âµ-law, ×¢× CLEAR/STOP ××™×™×“×™

```python
def _tx_loop(self):
    # ××¨×™×¥ ×‘×¨×§×¢; ×›×œ ×¤×¨×™×™× ×™×•×¦× ×‘× ×¤×¨×“ â€“ ×××¤×©×¨ ×‘×¨×’'-××™×Ÿ ××™×™×“×™
    while self.tx_running:
        try:
            item = self.tx_q.get(timeout=0.5)
        except queue.Empty:
            continue
        if item.get("type") == "end":
            break
        if item.get("type") == "clear":
            # ×œ×¨×•×§×Ÿ ×‘××¤×¨ × ×’×Ÿ ××¦×œ Twilio
            if self.stream_sid:
                self.ws.send(json.dumps({"event": "clear", "streamSid": self.stream_sid}))
            continue
        if item.get("type") == "media":
            payload = item["payload"]
            self.ws.send(json.dumps({
                "event": "media",
                "streamSid": self.stream_sid,
                "media": {"payload": payload}
            }))
            self.tx_frames += 1
            continue
        if item.get("type") == "mark":
            self.ws.send(json.dumps({"event": "mark", "streamSid": self.stream_sid,
                                     "mark": {"name": item.get("name", "mark")}}))
```

## 5) ×¢×¦×™×¨×ª ×“×™×‘×•×¨ (Barge-in) + × ×™×§×•×™ ×ª×•×¨

```python
def _interrupt_speaking(self):
    if not self.speaking:
        return
    print("BARGE_IN: interrupt speaking")
    self.speaking = False
    self.state = STATE_LISTEN
    # ×¨×™×§×•×Ÿ ××™×™×“×™ ×©×œ ×”×ª×•×¨
    while not self.tx_q.empty():
        try: self.tx_q.get_nowait()
        except: break
    # CLEAR ×œ× ×’×Ÿ
    try: self.tx_q.put_nowait({"type":"clear"})
    except: pass
```

## 6) ×˜×™×¤×•×œ ×‘××‘×¢ (ASRâ†’LLMâ†’TTS) â€“ ×¤×¢× ××—×ª ×‘×œ×‘×“, ×‘×œ×™ ×“×•×¤×œ×™×§×˜×™×

```python
def _process_utterance(self, pcm16_8k: bytes):
    # ×œ× ×××¤×©×¨×™× Re-entry
    if self.speaking:
        return
    try:
        text = asr_hebrew_from_pcm16_8k(pcm16_8k)
    except Exception as e:
        print("ASR_ERR:", e)
        text = ""

    print("ASR_TEXT:", text)
    if not text.strip():
        # ×ª×’×•×‘×” ××™× ×™××œ×™×ª ××• ×œ× ×œ×”×’×™×‘ ×›×œ×œ
        return

    # ×× ×™×¢×ª ×œ×•×¤×™×: ×× ×–×”×” ×œ××‘×¢ ×”×§×•×“× ×‘×˜×•×•×— ×§×¦×¨, ×“×œ×’
    if text.strip() == getattr(self, "last_user_text", None):
        print("DEDUP: same utterance ignored")
        return
    self.last_user_text = text.strip()

    self.state = STATE_THINK

    # ×ª×©×•×‘×” ××”××•×“×œ
    try:
        reply = generate_hebrew_response(text)
    except Exception as e:
        print("LLM_ERR:", e)
        reply = ""

    if not reply.strip():
        reply = "×‘×¡×“×¨, ××™×š ××¤×©×¨ ×œ×¢×–×•×¨?"

    # ×× ×–×”×” ×œ×ª×©×•×‘×” ×”×§×•×“××ª â†’ ×¢×“×›×Ÿ ×§×¦×ª ×›×“×™ ×œ× ×œ×”×™×©××¢ ×ª×§×•×¢
    if reply.strip() == (self.last_reply_text or ""):
        reply = reply + " ×ª×¨×¦×” ×œ×¤×¨×˜?"

    self.last_reply_text = reply.strip()

    # TTS ×•×©×™×“×•×¨
    self._speak_text(reply)
```

## 7) TTS ×•×©×™×“×•×¨ 20ms ×“×¨×š ×”×ª×•×¨

```python
def _speak_text(self, text: str):
    if not text:
        return
    pcm = None
    try:
        pcm = synth_hebrew_tts_pcm16_8k(text)
    except Exception as e:
        print("TTS_ERR:", e)

    if not pcm:
        pcm = self._beep_pcm16_8k(300)

    self.speaking = True
    self.state = STATE_SPEAK

    # CLEAR ×œ×¤× ×™ ×”×¤×¨×™×™× ×”×¨××©×•×Ÿ
    try: self.tx_q.put_nowait({"type":"clear"})
    except: pass

    # ×”××¨×” ×œ-Âµlaw ×•×©×™×“×•×¨ ×¤×¨×™×™××™× ×©×œ 20ms
    mulaw = audioop.lin2ulaw(pcm, 2)
    FR = 160  # 20ms @ 8kHz
    for i in range(0, len(mulaw), FR):
        if not self.speaking:  # ×”×•×¤×¡×§ ×‘×‘××¨×’'-××™×Ÿ
            break
        chunk = mulaw[i:i+FR]
        if len(chunk) < FR:
            break
        b64 = base64.b64encode(chunk).decode("ascii")
        try: self.tx_q.put_nowait({"type":"media", "payload": b64})
        except queue.Full:
            break

    # MARK ×œ×¡×™×•×
    try: self.tx_q.put_nowait({"type":"mark", "name":"tts_done"})
    except: pass

    self.speaking = False
    self.state = STATE_LISTEN
```

## 8) ×¦×¤×¦×•×£ ×¤×•×œ×‘××§ (×× TTS × ×¤×œ)

```python
def _beep_pcm16_8k(self, ms: int) -> bytes:
    samples = int(SR * ms / 1000)
    amp = 9000
    out = bytearray()
    for n in range(samples):
        val = int(amp * math.sin(2*math.pi*440*n/SR))
        out.extend(val.to_bytes(2, "little", signed=True))
    return bytes(out)
```

---

# ğŸ§ª Smoke â€“ ×‘×•×“×§×™× ×©×–×” ×‘×××ª ×¤×•×ª×¨ ×œ×•×¤×™×

1. **×‘×“×™×§×ª ×“×™×‘×•×¨ ×™×—×™×“**
   ×××•×¨: â€œ×©×œ×•×â€. ×‘×œ×•×’×™×:
   `ASR_TEXT: ×©×œ×•×` â†’ `LLM_REPLY: ...` â†’ **×ª×’×•×‘×” ××—×ª ×‘×œ×‘×“**. ××™×Ÿ ×¢×•×“ `_process_utterance` ×¢×“ ×©××“×‘×¨×™× ×©×•×‘.

2. **×‘×“×™×§×ª Barge-in**
   ×ª×Ÿ ×œ×‘×•×˜ ×œ×”×ª×—×™×œ ×œ×¢× ×•×ª ×•××– ×“×‘×¨ ××¢×œ×™×•.
   ×‘×œ×•×’×™×: `BARGE_IN: interrupt speaking` â†’ ×”×”×©××¢×” × ×¢×¦×¨×ª ××™×“, `state=LISTENING`, ×•×”×‘×•×˜ ×™×ª×™×™×—×¡ ×œ××‘×¢ ×”××—×¨×•×Ÿ ×©×œ×š.

3. **×× ×™×¢×ª ×œ×•×œ××•×ª**
   ×××•×¨ ×©×•×‘ ×•×©×•×‘ ××•×ª×” ××™×œ×” ×§×¦×¨×” (â€œ×©×œ×•×â€).
   ×ª×¨××” `DEDUP: same utterance ignored` ××“×™ ×¤×¢×, ×•×”×‘×•×˜ ×œ× ×™×—×–×•×¨ ×¢×œ ××•×ª×” ×ª×©×•×‘×” ×‘×œ×™ ×¡×•×£.

4. **Rx/Tx counters**
   ×‘Ö¾`WS_DONE ... rx>0 tx>0`.
   ×× `tx=0` â†’ ×‘×“×•×§ ×—×¨×™×’×” ×‘Ö¾TTS. ×™×”×™×” ×œ×¤×—×•×ª beep.

---

# âš™ï¸ ENV ××•×¦×¢×™× (×œ× ×—×•×‘×”, × ×•×—×™× ×œ×›×™×•×•× ×•×Ÿ)

```bash
# start_all.sh
export WS_MODE=${WS_MODE:-AI}
export BARGE_IN=${BARGE_IN:-true}
export MIN_UTT_SEC=${MIN_UTT_SEC:-0.7}
export MAX_UTT_SEC=${MAX_UTT_SEC:-6.0}
export VAD_RMS=${VAD_RMS:-200}
```

---

## ×œ××” ×–×” ××¤×¡×™×§ ××ª ×”×œ×•×¤×™×

* `_process_utterance` × ×¢×•×œ ×¢× `self.processing` â†’ × ×§×¨× **×¤×¢× ××—×ª** ×œ×›×œ ×¡×•×£-××‘×¢.
* ×‘×–××Ÿ SPEAKING ××™×Ÿ ××™×¡×•×£ ×§×œ×˜; ×•×× ×‘×Ÿ-××“× ××“×‘×¨ â€“ **Barge-in** ×¢×•×¦×¨ ××ª ×”×”×©××¢×” ×•××—×–×™×¨ ×œ×”××–× ×”.
* ×ª×•×¨ ×©×™×“×•×¨ × ×¤×¨×“ (TX) ×××¤×©×¨ ×œ×¢×¦×•×¨ ×‘×××¦×¢ ×ª×’×•×‘×” ×‘×œ×™ â€œ×œ×©×¤×•×šâ€ ×¤×¨×™×™××™× ×™×©× ×™×.
* DEDUP ×‘×˜×§×¡×˜ ××•× ×¢ â€œ×ª×©×•×‘×” ×–×”×” ×©×•×‘ ×•×©×•×‘â€ ×¢×œ ××•×ª×Ÿ ×ª×‘× ×™×•×ª ×§×¦×¨×•×ª.

×ª×™×™×©× ××ª ×”×§×˜×¢×™× ×œ××¢×œ×” ×‘×§×•×‘×¥ `media_ws.py` (×‘×œ×™ ×œ×©×‘×•×¨ ××ª ×”××™× ×˜×’×¨×¦×™×” ×œ-ASR/TTS ×©×œ×š), ×•×ª×Ÿ ×©×™×—×” × ×•×¡×¤×ª. ×× ×ª×¨××” ×¢×“×™×™×Ÿ ×›×¤×œ ×ª×’×•×‘×•×ªâ€”×ª×“×‘×™×§ ×›××Ÿ ××ª 10 ×©×•×¨×•×ª ×”×œ×•×’ ×¡×‘×™×‘ `ASR_TEXT` ×•-`LLM_REPLY`, ×•××›×•×•×Ÿ ×‘×“×™×•×§ ×œ× ×§×•×“×ª ×”×¤×™×¦×•×œ.
