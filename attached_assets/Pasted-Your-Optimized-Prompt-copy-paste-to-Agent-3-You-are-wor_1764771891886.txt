Your Optimized Prompt (copy–paste to Agent 3):

You are working on the ProSaaS / AI CRM project (Flask + React + Twilio + OpenAI Realtime, Dockerized on Contabo, multi-tenant by business_id).

Your task: add full support for outbound AI calls, including UI, backend logic, Twilio integration and concurrency limits – without breaking existing inbound calls.

All responses, messages to users and UI labels in the app must be in Hebrew, but you and I speak in English here.

⸻

1. High-level goals
	1.	Add a new “שיחות יוצאות” (Outgoing Calls) page in the existing CRM sidebar.
	2.	Allow the business user to:
	•	See a simple list of leads.
	•	Select up to 3 leads at once.
	•	Choose a call prompt / scenario for these outbound calls.
	•	Start AI calls where the bot:
	•	Uses the lead’s name for a natural greeting.
	•	Follows a call-specific outbound prompt instead of the default inbound prompt.
	3.	Enforce strict limits per business:
	•	Max 3 outbound calls in progress at the same time.
	•	Max 5 total calls in progress (incoming + outgoing combined) per business.
	•	If limits are reached:
	•	For inbound: the call should not be answered (return polite TwiML + hangup).
	•	For outbound: the UI must prevent starting more calls and show a clear message in Hebrew.
	4.	Make sure everything is reliable, race-condition-safe and resource-friendly so the server isn’t overloaded.

⸻

2. Architecture assumptions (use existing patterns)
	•	Backend: Python Flask + ASGI (FastAPI style) with Twilio webhooks already implemented:
	•	/webhook/incoming_call
	•	/webhook/stream_status
	•	/webhook/stream_ended
	•	/webhook/call_status
	•	WebSocket /ws/twilio-media handled in media_ws_ai.py with a CallState state machine and CallConfig loaded from BusinessSettings.
	•	Frontend: React + TypeScript + existing sidebar with sections for Leads / Calls / WhatsApp / etc.
	•	DB: PostgreSQL with existing tables for businesses, leads, calls/logs (use/extend what already exists instead of reinventing).

If some of this changed in the current repo, adapt cleanly to the real structure, but keep the same spirit.

⸻

3. Data model & backend changes

3.1. Represent outbound calls
	1.	Extend the existing Call / CallLog / PhoneCall model (whatever is currently used) instead of creating a completely new table:
	•	Add direction enum or string: "inbound" | "outbound".
	•	Add status: "initiated" | "ringing" | "in_progress" | "completed" | "failed" | "no_answer" | "busy" | "canceled".
	•	Add lead_id (FK to leads table), if not already there.
	•	Add outbound_prompt_id (nullable FK) or outbound_prompt_text for ad-hoc prompts.
	2.	Add a lightweight model for outbound call prompts:
	•	Either reuse the existing “scripts” table with a type = 'outbound',
	•	Or create OutboundCallTemplate with:
	•	id
	•	business_id
	•	name (e.g., “תיאום פגישה”, “בירור חוב”, “חידוש שירות”)
	•	prompt_text (Hebrew description of how the AI should behave in this outbound scenario)
	•	Expose a REST endpoint:
	•	GET /api/outbound_call_templates → returns templates for the current business.
	•	(Optional) POST/PUT/DELETE if there is already UI for managing scripts; otherwise just seed a few templates.

3.2. Track active / concurrent calls

Create a single source of truth to count active calls per business:
	•	Add helper functions in backend (in a calls_service.py or similar):

def get_active_call_count(business_id: int) -> int:
    # status in ('initiated', 'ringing', 'in_progress')

def get_active_outbound_call_count(business_id: int) -> int:
    # same filter + direction='outbound'

	•	When calls progress or end (Twilio call_status, stream_ended), make sure you always update status so the counts remain accurate.

3.3. Enforce global per-business limits

Define the limits as constants (or later from BusinessSettings):

MAX_TOTAL_ACTIVE_CALLS_PER_BUSINESS = 5
MAX_ACTIVE_OUTBOUND_CALLS_PER_BUSINESS = 3

Use them in two places:

a. Inbound calls – /webhook/incoming_call
	•	Before you start a media stream or AI session:
	•	Count active calls for this business.
	•	If active_total >= MAX_TOTAL_ACTIVE_CALLS_PER_BUSINESS:
	•	Return TwiML in Hebrew like:
“כרגע כל הקווים של העסק תפוסים. נסה שוב בעוד מספר דקות, תודה.”
	•	And do not open WebSocket / AI session.
	•	Otherwise:
	•	Create the call record with direction='inbound' and status='initiated' as today.
	•	Continue normal flow.

b. Outbound calls – new endpoint
Create an endpoint:

POST /api/outbound_calls/start

Body (JSON):

{
  "lead_ids": [123, 456, 789],
  "template_id": 10,          // or null if using custom text
  "custom_prompt": "..."      // optional
}

Backend behavior:
	1.	Resolve current business_id from auth/session.
	2.	Validate:
	•	1–3 lead_ids (never 0, never >3).
	3.	Check concurrency:
	•	active_total = get_active_call_count(business_id)
	•	active_outbound = get_active_outbound_call_count(business_id)
	•	If active_total >= MAX_TOTAL_ACTIVE_CALLS_PER_BUSINESS → 409 / 429 with Hebrew message:
	•	“כרגע יש יותר מדי שיחות פעילות עבור העסק. המתן לסיום חלק מהשיחות ונסה שוב.”
	•	Else if active_outbound + len(lead_ids) > MAX_ACTIVE_OUTBOUND_CALLS_PER_BUSINESS → 409/429 with:
	•	“ניתן להוציא עד שלוש שיחות יוצאות במקביל. המתן לסיום שיחה פעילה ונסה שוב.”
	4.	For each lead:
	•	Fetch lead from DB (name + phone + business_id validation).
	•	Fetch outbound template (if given) and build the outbound system prompt:
	•	Start from the existing global system prompt used for calls.
	•	Add the business base script (as done today).
	•	Add the outbound template text.
	•	Add a short line like:
“זו שיחה יוצאת יזומה. פנה אל {{lead_name}} באופן אישי וייצג את העסק בצורה מקצועית.”
	•	Create a Call record:
	•	direction='outbound'
	•	status='initiated'
	•	lead_id=<id>
	•	outbound_prompt_id / outbound_prompt_text
	5.	Trigger the actual Twilio call via the REST API:
	•	Use the existing Twilio client / credentials.
	•	Calls.create(...) with:
	•	to=lead.phone
	•	from=<business phone or main Twilio number>
	•	url="https://<your-domain>/webhook/incoming_call?mode=outbound&lead_id=...&call_id=..."
(add any params needed so the webhook knows this is outbound and which prompt to load)
	6.	Return JSON with created call IDs and some basic status.

3.4. Use outbound prompt + lead name in AI

In the AI/media layer (media_ws_ai.py or equivalent):
	1.	When a new call is initialized, pass along:
	•	call.direction
	•	lead_name (for greeting)
	•	outbound_prompt_text or outbound_prompt_id → use to build the system prompt.
	2.	For outbound:
	•	Start with a greeting like:
“שלום {{lead_name}}, כאן העוזרת הדיגיטלית של {{business_name}} …”
(the exact wording can stay configurable from DB, but make sure name is used).
	•	Respect the outbound template instructions (purpose of the call, what to ask, how to close).
	3.	Do not break existing inbound behavior; just branch lightly on direction.

⸻

4. Frontend – “שיחות יוצאות” Page

Create a new React page and wire it into the existing sidebar.

4.1. Sidebar integration
	•	In the existing sidebar config:
	•	Under the appropriate section (e.g., “טלפוניה” / “Calls”), add an item:
	•	Label: “שיחות יוצאות”
	•	Route: /outbound-calls (or similar)
	•	Icon: reuse a phone-outgoing icon if you already have one.

4.2. Page layout

The page can be simpler than the full “Leads” page:
	1.	Filter & search bar (optional):
	•	Search by name / phone / tag – only if easy to reuse.
	2.	Table or list of leads:
	•	Columns:
	•	Checkbox
	•	Lead name
	•	Phone
	•	Tags / Source (optional)
	•	Allow selecting up to 3 leads simultaneously:
	•	If the user tries to select more than 3, show toast/snackbar in Hebrew:
	•	“ניתן לבחור עד שלושה לידים לשיחות יוצאות במקביל.”
	3.	Right panel / top bar for outbound call setup:
	•	Dropdown: “מטרת השיחה” – selects outbound template.
	•	(Optional) textarea to fine-tune the call prompt per batch.
	•	Button: “התחל שיחות”.

4.3. UX rules
	•	Disable the “התחל שיחות” button if:
	•	No leads are selected.
	•	No template chosen (if required).
	•	When clicking “התחל שיחות”:
	•	Send POST /api/outbound_calls/start.
	•	While request pending, show loading state.
	•	On success:
	•	Show toast: “השיחות נשלחו. המערכת תתקשר אל הלקוחות ותעדכן את הלוגים.”
	•	Clear selected leads.
	•	On 409/429 (limit exceeded):
	•	Show the message from backend in a toast.
	•	(Optional) show a small panel with current active calls:
	•	Number of active inbound/outbound calls for this business.
	•	This is optional, only if easy to reuse an existing component.

⸻

5. Concurrency, safety & performance
	1.	Race conditions:
	•	Ensure that both inbound and outbound paths use the same counting logic in a service layer.
	•	If multiple requests come concurrently, the DB should enforce correctness:
	•	Use transactions or SELECT ... FOR UPDATE if needed.
	2.	Twilio webhooks consistency:
	•	Make sure that every call_status update:
	•	Updates the corresponding call row’s status.
	•	When status is in a terminal state (completed, failed, no_answer, busy, etc.), it must no longer count as active.
	3.	Server load:
	•	No heavy joins or N+1 queries when loading leads for the Outbound page.
	•	Use pagination (existing table abstraction) if many leads.
	•	Reuse existing code patterns for API error handling/logging.

⸻

6. Acceptance criteria

Consider the feature complete when ALL of the following work:
	1.	Sidebar & navigation
	•	“שיחות יוצאות” appears in the sidebar.
	•	Clicking it opens the new Outbound Calls page.
	2.	UI behavior
	•	Page shows a list of leads for the current business.
	•	User can select 1–3 leads and choose an outbound template.
	•	If selecting more than 3, UI prevents it with a Hebrew message.
	•	“התחל שיחות” triggers backend and shows success/error states.
	3.	Concurrency limits
	•	With 0–2 active outbound calls, starting 1–3 more works until hitting 3 total outbound.
	•	If there are already 3 outbound calls:
	•	Backend refuses new outbound calls with proper 409/429.
	•	UI shows the Hebrew message.
	•	When total active calls (inbound+outbound) reach 5:
	•	New inbound calls to this business get polite “all lines busy” TwiML and are not connected to AI.
	•	Outbound start API returns an error and UI shows it.
	4.	Outbound AI behavior
	•	Outbound calls greet the lead by name.
	•	The AI uses the chosen outbound template behavior (different wording per template).
	•	Calls are logged with direction='outbound' and correct status transitions.
	5.	No regressions
	•	Inbound calls still work exactly as before when limits are not reached.
	•	Existing CRM pages (Leads, Logs, WhatsApp) are unchanged.
	•	All tests / linters / type checks pass.

⸻

Work incrementally, commit logically, and update any relevant documentation (e.g., replit.md) with a short “Outbound Calls Feature + Concurrency Limits” section so future agents and humans understand the design.