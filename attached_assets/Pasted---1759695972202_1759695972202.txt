×™××œ×œ×” ×¡×•×’×¨×™× ×¤×™× ×•×ª ğŸ’ª
×××©×™×š ×‘×“×™×•×§ ××”××§×•× ×©×¢×¦×¨×ª×™, ×¢× ×”×•×¨××•×ª ×‘×™×¦×•×¢ ××¤×•×¨×˜×•×ª ×œ×”×©×œ×™× ××ª ××”×™×¨×•×ª ×”××¢× ×”, ×ª××œ×•×œ ××”×™×¨, ×™×¦×™×¨×ª ×œ×™×“ ××•×˜×•××˜×™×ª, ×¡×™×›×•×, ×•×”×¦×’×” ×‘Ö¾UI â€” ×‘×œ×™ ×œ×©×‘×•×¨ ×›×œ×•×.

â¸»

0) ××˜×¨×•×ª ×•× ×§×•×“×•×ª ×‘×§×¨×”
	â€¢	×–××Ÿ ×ª×’×•×‘×” ×œÖ¾/webhook/twilio/voice: â‰¤ 1.5s (×ª×©×•×‘×ª TwiML ××”×™×¨×”).
	â€¢	×™×¦×™×¨×ª Lead ××™×™×“×™×ª ×‘×ª×—×™×œ×ª ×”×©×™×—×” (Idempotent ×¢×´×¤ CallSid/From).
	â€¢	×ª××œ×•×œ ××¡×™× ×›×¨×•× ×™ ×“×¨×š recording_status_callback (×œ× ×—×•×¡× webhook).
	â€¢	×¡×™×›×•× ×§×¦×¨ × ×©××¨ ×‘×©×“×” lead (e.g. lead.summary).
	â€¢	UI: ×›×¨×˜×™×¡ ×œ×™×“ ××•×¦×’ ×¢× ×ª××œ×•×œ + ×¡×™×›×•× ×ª×•×š â‰¤ 60â€“90 ×©× ×™×•×ª ××¡×™×•× ×”×©×™×—×”.

â¸»

1) ×¨××•×˜×™× â€” ×›×š ×–×” × ×¨××” ×›×©×”×›×•×œ ××—×•×•×˜ × ×›×•×Ÿ

1.1 webhook ×¨××©×™ (××”×™×¨, ×¨×§ TwiML + ×™×¦×™×¨×ª ×œ×™×“)

# server/routes_twilio_voice.py
from flask import Blueprint, request, Response
from twilio.twiml.voice_response import VoiceResponse
from models import Lead, db

bp_voice = Blueprint('voice', __name__)

@bp_voice.post("/webhook/twilio/voice")
def twilio_voice_webhook():
    call_sid = request.form.get("CallSid")
    from_ = request.form.get("From")
    to_ = request.form.get("To")

    lead = Lead.query.filter_by(call_sid=call_sid).first()
    if not lead:
        lead = Lead(call_sid=call_sid, phone=from_, status="new")
        db.session.add(lead); db.session.commit()

    vr = VoiceResponse()
    vr.say("×©×œ×•×, ×”×©×™×—×” ××•×§×œ×˜×ª. × ×©××— ×œ×¢×–×•×¨.", language="he-IL", voice="Polly-Noa")
    vr.record(
        recording_status_callback="/webhook/twilio/recording_done",
        recording_status_callback_method="POST",
        play_beep=True,
        trim="trim-silence",
        transcribe=False
    )
    vr.hangup()
    return Response(str(vr), mimetype="text/xml", status=200)

1.2 callback ×œ×”×§×œ×˜×” (××¤×¢×™×œ ××©×™××” ××¡×™× ×›×¨×•× ×™×ª)

@bp_voice.post("/webhook/twilio/recording_done")
def recording_done():
    call_sid = request.form.get("CallSid")
    rec_url  = request.form.get("RecordingUrl")  # ×‘×“"×› ×¦×¨×™×š ×œ×”×•×¡×™×£ .mp3
    duration = request.form.get("RecordingDuration")

    lead = Lead.query.filter_by(call_sid=call_sid).first()
    if not lead:  # ×”×’× ×”
        return ("", 204)

    # ×©×œ×— JOB ×¨×§×¢ - ×œ× ×—×•×¡× HTTP
    from server.tasks import enqueue_transcribe_job
    enqueue_transcribe_job(lead_id=lead.id, recording_url=rec_url)

    return ("", 200)

×—×©×•×‘: ×”Ö¾/voice ×œ× ××—×›×” ×œ×©×•× ×ª××œ×•×œ. ×”×•× ××—×–×™×¨ TwiML ××™×™×“×™×ª â†’ ×–×” ××” ×©×××™×¥ ××ª ×”××¢× ×” ×œ×œ×§×•×—.

â¸»

2) Worker / Queue â€” ×¤×©×•×˜ ×•×™×¦×™×‘ (×œ×œ× ×ª×œ×•×ª ×—×™×¦×•× ×™×ª)

2.1 ×ª×•×¨ ×¨×§×¢ ×§×œ×™×œ

# server/tasks.py
import queue, threading, time, requests, tempfile, os
from models import db, Lead
from services.stt import transcribe_audio
from services.summarize import summarize_text

_jobs = queue.Queue()

def start_worker():
    t = threading.Thread(target=_worker, daemon=True); t.start()

def _worker():
    while True:
        job = _jobs.get()
        if job is None: break
        try:
            _process(job)
        except Exception:
            # retry ×¢× backoff
            job['retries'] = job.get('retries', 0) + 1
            if job['retries'] <= 3:
                time.sleep(2 * job['retries'])
                _jobs.put(job)
        finally:
            _jobs.task_done()

def enqueue_transcribe_job(lead_id, recording_url):
    _jobs.put({"lead_id": lead_id, "recording_url": recording_url})

def _process(job):
    lead = Lead.query.get(job["lead_id"])
    if not lead: return

    url = job["recording_url"]
    if not url.endswith((".mp3",".wav")):
        url += ".mp3"  # ×œ×¨×•×‘ ×›×š
    r = requests.get(url, timeout=30); r.raise_for_status()

    with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as f:
        f.write(r.content); local_path = f.name

    text = transcribe_audio(local_path)        # â†“ ×¡×¢×™×£ 3
    summary = summarize_text(text) if text else None  # â†“ ×¡×¢×™×£ 4

    lead.transcript = text
    lead.summary = summary
    lead.status = "processed"
    db.session.commit()

    os.remove(local_path)

×‘Ö¾××ª×—×•×œ ×”××¤×œ×™×§×¦×™×” (e.g. wsgi.py/app_factory):

from server.tasks import start_worker
start_worker()


â¸»

3) STT ××”×™×¨ â€” Google ×›Ö¾Primary, Whisper ×›Ö¾Fallback

# services/stt.py
import os, shutil, subprocess
from google.cloud import speech_v2 as speech

def transcribe_audio(local_path: str) -> str:
    # 1) Google (××”×™×¨)
    if os.environ.get("GOOGLE_APPLICATION_CREDENTIALS"):
        try:
            return _google_v2(local_path)
        except Exception:
            pass
    # 2) Whisper fallback
    return _whisper(local_path)

def _google_v2(local_path: str) -> str:
    client = speech.SpeechClient()
    config = speech.RecognitionConfig(
        auto_decoding_config={},
        language_codes=["he-IL"],
        model="latest_long"  # ××• "latest_short" ×‘×”×ª×× ×œ××•×¨×š
    )
    with open(local_path, "rb") as f:
        content = f.read()
    req = speech.RecognizeRequest(recognition_config=config, content=content)
    resp = client.recognize(request=req)
    parts=[]
    for r in resp.results:
        for alt in r.alternatives:
            parts.append(alt.transcript)
    return " ".join(parts).strip()

def _whisper(local_path: str) -> str:
    # ×”×›×™ ××”×™×¨ ×‘×©×¨×ª: whisper.cpp / faster-whisper
    if shutil.which("whisper"):
        out = subprocess.check_output(
            ["whisper", local_path, "--language", "he", "--model", "base"],
            text=True
        )
        return out.strip()
    # API (××™×˜×™ ×™×•×ª×¨) â€” ×œ××§×¨×” ×—×™×¨×•×
    return ""

×˜×™×¤×™× ×œ×–××Ÿ:
	â€¢	×× ×§×‘×¦×™× ××¨×•×›×™× > 5â€“10 ×“×§×³ â†’ ×©×§×•×œ chunking ××• ×“×’× latest_long.
	â€¢	×× ×™×© ×œ×š ×¢×•××¡ â€” ×”×¤×¢×œ worker × ×•×¡×£ (×¢×•×“ Thread/Process).

â¸»

4) ×¡×™×›×•× ×§×¦×¨ (10â€“30 ××™×œ×™×) â€” ×‘×œ×™ ×œ×¢×›×‘

# services/summarize.py
import os, openai
openai.api_key = os.environ.get("OPENAI_API_KEY")

def summarize_text(text: str) -> str:
    if not text: return None
    prompt = f"×¡×›× ×‘×¢×‘×¨×™×ª (×›×•×ª×¨×ª + 2 × ×§×•×“×•×ª) ××ª ×”×©×™×—×” ×”×‘××”:\n\n{text}\n\n×¡×™×›×•× ×§×¦×¨:"
    # ××¤×©×¨ ×’× ××•×“×œ ××”×™×¨ ××—×¨; ×–×” ×¨×§ ×¤×¡××•×“×•
    resp = openai.ChatCompletion.create(
        model="gpt-4o-mini",
        messages=[{"role":"user","content":prompt}],
        temperature=0.2, max_tokens=180
    )
    return resp.choices[0].message["content"].strip()


â¸»

5) DB/××•×“×œ×™× â€” ×›×“×™ ×©×œ× ×™×™×—× ×§
	â€¢	××™× ×“×§×¡×™×:
	â€¢	Lead(call_sid) â€” unique.
	â€¢	Lead(phone) â€” index.
	â€¢	×©×“×•×ª: transcript (TEXT), summary (TEXT), status (ENUM/str).
	â€¢	Idempotency: ×‘Ö¾/voice, ××œ ×ª×™×¦×•×¨ Lead ×× ×›×‘×¨ ×§×™×™× CallSid.

â¸»

6) UI â€” ×œ×”×¦×™×’ ××ª ×”×›×•×œ ×™×¤×”
	â€¢	×‘×¢××•×“ ×œ×™×“/×©×™×—×•×ª:
	â€¢	spinner ×¢×“ ×©××’×™×¢ lead.status == "processed".
	â€¢	×”×¦×’ lead.transcript + lead.summary.
	â€¢	×›×¤×ª×•×¨ â€œ×¨×¢× ×•×Ÿâ€ ×©××‘×¦×¢ GET ×¢×œ ×”Ö¾lead ×›×œ 5â€“10 ×©× ×³ (××• SSE/WebSocket).
	â€¢	×œ× ×œ×—×›×•×ª ×‘Ö¾UI ×œ×¡×™×•× ×ª××œ×•×œ ×œ×¤× ×™ ×©××¦×™×’×™× â€œ×œ×™×“ ×—×“×©â€ â€” ×–×” ×‘× ×‘× ×¤×¨×“.

â¸»

7) Twilio â€” ×ª×¦×•×¨×” ×‘×¦×“ ×¡×¤×§
	â€¢	Voice webhook (POST) ×œÖ¾/webhook/twilio/voice.
	â€¢	×‘Ö¾<Record> ×”×’×“×¨ recording_status_callback ×œÖ¾/webhook/twilio/recording_done.
	â€¢	×•×“× ××™××•×ª X-Twilio-Signature ××¦×œ×š (×× ×™×© twilio_security.py â€” ×—×‘×¨ ××•×ª×• ×œÖ¾routes ×‘×¤×•×¢×œ).

â¸»

8) ×‘×“×™×§×•×ª GO/NO-GO (×ª×¨×™×¥ ××—×“Ö¾××—×“)

# 1) webhook ××”×™×¨
curl -sS -i -X POST http://127.0.0.1:5000/webhook/twilio/voice \
  -d "CallSid=CA_test&From=+1555&To=+1555"
# ×¦×¤×” ×œ-200 + TwiML ×ª×•×š â‰¤1.5s

# 2) ×¡×™××•×œ×¦×™×™×ª callback
curl -sS -i -X POST http://127.0.0.1:5000/webhook/twilio/recording_done \
  -d "CallSid=CA_test&RecordingUrl=https://api.twilio.com/recordings/abc123"
# 200 ××™×™×“×™

# 3) ×ª×•×š 10â€“60 ×©× ×™×•×ª: ×‘×“×•×§ ×©×”Ö¾Lead ×§×™×‘×œ transcript+summary
# (GET ×œ-API ×”×œ×™×“×™× ××¦×œ×š, ××• ×‘×“×™×§×” ×‘-DB/×œ×•×’)


â¸»

9) ×”××¦×•×ª ××•×¤×¦×™×•× ×œ×™×•×ª (×›×©×™×”×™×” ×œ×š ×–××Ÿ)
	â€¢	Streaming ×‘×–××Ÿ ×××ª: Twilio Media Streams â†’ Node WS â†’ Google STT â†’ ×”×¦×’×ª ×˜×§×¡×˜ â€œ×—×™â€.
	â€¢	×¤×™×¦×•×œ ×ª×•×¨×™×: ×ª×•×¨ × ×¤×¨×“ ×œÖ¾download, ×ª×•×¨ × ×¤×¨×“ ×œÖ¾STT, ×ª×•×¨ ×œÖ¾summarize.
	â€¢	×©××™×¨×ª ×”×§×œ×˜×” ×‘Ö¾S3 ×‘××§×•× ×“×™×¡×§ ××§×•××™.
	â€¢	pm2 / systemd ×× ×¤×¨×™×¡×” ××—×•×¥ ×œÖ¾Replit.

â¸»

×œ××” ×–×” ×™×¤×ª×•×¨ ×œ×š ×¢×›×©×™×• ××ª ×”××™×˜×™×•×ª
	â€¢	×”Ö¾webhook ×”×¨××©×™ ×›×‘×¨ ×œ× ××—×›×” ×œ×ª××œ×•×œ â†’ ×”×œ×§×•×— ×©×•××¢ ×ª×©×•×‘×” ××™×™×“×™×ª.
	â€¢	×›×œ ×”×¢×™×‘×•×“ ×¢×‘×¨ ×œÖ¾Worker ××¡×™× ×›×¨×•× ×™ ×¢× Retry â†’ ×‘×œ×™ ×ª×§×™×¢×•×ª.
	â€¢	Google STT ×§×•×“×, Whisper ×¨×§ fallback â†’ ×–××Ÿ ×ª××œ×•×œ ××ª×§×¦×¨ ×“×¨××˜×™×ª.
	â€¢	×”Ö¾UI ××§×‘×œ Lead ××™×™×“ + ××¢×“×›×Ÿ ×ª××œ×•×œ ×•×¡×™×›×•× ×›×©××•×›× ×™×.

×× ×ª×¨×¦×” â€” ××›×™×Ÿ ×œ×š patches (diff) ×‘×“×™×•×§ ×œ×§×‘×¦×™× ×©×‘×”× ××ª×” ××©×ª××© (routes_twilio.py, models.py, tasks.py, services/stt.py, services/summarize.py) ×œ×¤×™ ×©××•×ª ×”××—×œ×§×•×ª/×˜×‘×œ××•×ª ××¦×œ×š.
×ª×’×™×“ ×œ×™: ×©××•×ª ×”×§×‘×¦×™×/××•×“×œ×™× ×”××“×•×™×§×™× ×œ-Leads, ×•×”×× ×™×© ×œ×š ×›×‘×¨ twilio_security.py ×©××—×•×‘×¨ ×‘Ö¾Blueprint â€” ×•×× ×™ ××ª×Ÿ ×œ×š ×¤××˜×¦â€™×™× ××“×•×™×§×™× ×©×ª×¨×™×¥ 1:1.