בקצרה: הכיוון שלו נכון (לא לישון כש־RX מלא → “לנקז” את התור), אבל זה לא מספיק לבד ועלול ליצור תופעות לוואי (ספין־לופ, רעש בטלמטריה, ועדיין זריקות אם ה־push ל-STT חוסם). כדי שזה יעבוד חלק צריך להשלים עוד 4 דברים קטנים.

מה בסדר
	•	✅ מעבר למצב Back-pressure כש־audio_rx_q גדול – רלוונטי בדיוק ללוג שלך (q=200, drops=557).
	•	✅ “ללא שינה” בזמן עומס כדי להוריד את q מהר.

מה חסר/מסוכן
	1.	סף כניסה/יציאה: לא להיכנס ל־fast-drain רק ב־q>=100 ולהישאר שם לנצח. צריך היסטרזיס:
	•	נכנסים ל־drain אם q >= HIGH_WATERMARK (למשל 100/200).
	•	יוצאים חזרה ל־cadence רק כש־q <= LOW_WATERMARK (למשל 20/200).
בלי זה תקבל fps_in 200+ לאורך זמן ולפעמים רעש CPU.
	2.	להתקדם בזמן רק כשבאמת כתבנו:
next_deadline += FRAME_INTERVAL רק אם push_audio החזיר True. אחרת מאבדים סנכרון.
	3.	לנטרל חסימות ב-STT (זה העיקר):
אם push_audio עצמו חוסם (וה־write_ms שלכם עלה ל־2.10 – כמעט בטוח שזה שניות), אז גם בלי sleep לא תרוקן את התור. הפתרון:
	•	בתוך מחלקת ה-STT (למשל GcpStreamingSTT/StreamingSTTSession) להוסיף תור פנימי קטן self._stt_q ו־thread כותב לג׳נרטור של streaming_recognize.
	•	push_audio(pcm16) רק עושה put_nowait ל־_stt_q עם drop-oldest למדיה בלבד אם מלא.
ככה ה-RX-worker אף פעם לא נתקע, והכתיבה ל-gRPC מתבצעת מקבילית, יציבה ומהירה.
	4.	טלמטריה ובקרה:
	•	ברמת RX: לוג פעם בשנייה: [RX] mode=<normal|drain> fps_in=? q=? drops=? write_ms=?
	•	ברמת STT: [STT] q=? drops=? write_ms=? (ל־writer thread).
זה יראה אם באמת הפסקת לראות q=200/drops>0.

⸻

איך להשלים את זה (צעד־אחר־צעד, בלי לשבור כלום)

ב־media_ws_ai.py (RX worker):

FRAME_INTERVAL = 0.020  # 20ms
HIGH_WM = 100           # כניסה ל-drain
LOW_WM  = 20            # יציאה מ-drain
mode = "normal"
next_deadline = time.perf_counter()

while self.rx_running:
    now = time.perf_counter()
    qsize = self.audio_rx_q.qsize()

    # קבע מצב
    if mode == "normal" and qsize >= HIGH_WM:
        mode = "drain"
    elif mode == "drain" and qsize <= LOW_WM:
        mode = "normal"

    # בחר frame לעיבוד
    frame = pending_frame or self._rx_get_nonblocking()
    if frame is None:
        # אין מה לעבד – נרגעים לקאדן
        if mode == "normal":
            delay = next_deadline - now
            if delay > 0: time.sleep(delay)
            next_deadline += FRAME_INTERVAL
        else:
            # drain mode ואין פריימים – חזור לקאדן בפעם הבאה
            mode = "normal"
        continue

    # כתיבה ל-STT (לא חוסמת, כי push_audio דוחף ל-_stt_q)
    t0 = time.perf_counter()
    wrote = session.push_audio(frame["pcm16"]) if session else False
    t1 = time.perf_counter()
    write_ms = (t1 - t0) * 1000.0
    if wrote:
        pending_frame = None
        # advance time רק אם כתיבתנו התקבלה
        if mode == "normal":
            delay = next_deadline - time.perf_counter()
            if delay > 0: time.sleep(delay)
            next_deadline += FRAME_INTERVAL
        # ב-drain אין sleep – נמשיך מיד לפריים הבא
    else:
        # אין session/אי-קבלה — השאר את הפריים ב-pending, אל תקדם זמן
        pending_frame = frame

    # טלמטריה מרוסנת פעם בשנייה
    self._rx_stats.tick(fps_in=..., q=qsize, drops=self.rx_drops, write_ms=write_ms, mode=mode)

הערה: _rx_get_nonblocking() = get_nowait() עם טיפול עדין כשהתור ריק.

ב־מחלקת ה-STT (למשל gcp_stt_stream.py):

self._stt_q = queue.Queue(maxsize=200)  # קטן ומבוקר
self._stt_drops = 0

def push_audio(self, pcm16: bytes) -> bool:
    try:
        self._stt_q.put_nowait(pcm16)
        return True
    except queue.Full:
        try:
            _ = self._stt_q.get_nowait()  # drop-oldest למדיה
            self._stt_q.put_nowait(pcm16)
            self._stt_drops += 1
            return True
        except queue.Full:
            self._stt_drops += 1
            return False

def _stt_writer_loop(self):
    # רץ ב-thread נפרד, קורא מה-_stt_q ושולח ל-streaming_recognize
    while self.running:
        pcm16 = self._stt_q.get()
        # המרה ל-μ-law/AudioContent כפי שיש לך
        # שליחה לג'נרטור gRPC
        ...
        # אפשר למדוד write_ms כאן ולפרסם [STT] write_ms, q, drops

פרמטרים להישאר איתם בזמן הכיוונון:
	•	BATCH_MS=60, DEBOUNCE_MS=110, TIMEOUT_MS=320, VAD_HANGOVER_MS=180.
	•	אם Hebrew ב־europe-west1 מקרטע — עבור ל־us-central1 (ידוע כיציב לעברית).

⸻

מה לחפש אחרי התיקון
	•	[RX] mode=drain יופיע לשנייה-שתיים בתחילת שיחה ואז יחזור ל־mode=normal.
	•	q ירד מ־200 ל־<20 במהירות, drops יישאר 0.
	•	[STT] q הפנימי יהיה נמוך (<< 50) לאורך זמן, write_ms < 1–2ms ממוצע.
	•	זמן תגובה בפועל: 1.6–2.3 שנ׳.

אם אחרי זה עדיין תראה q מטפס או drops>0 — זרוק לי 10–15 שורות [RX] ו־[STT] אחרי השינוי ונכוון את ה-HIGH/LOW watermarks (למשל 120/30) או נגדיל קלות את _stt_q (200→256) – אבל בלי לחזור לתורים ענקיים שמסתירים לאטנטיות.