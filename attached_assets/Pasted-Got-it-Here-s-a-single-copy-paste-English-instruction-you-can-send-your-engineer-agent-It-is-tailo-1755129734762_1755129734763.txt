Got it. Here’s a single copy-paste English instruction you can send your engineer/agent.
It is tailored to the latest ZIP you shared (Flask backend under server/, React+Vite frontend under src/, existing CRM/WhatsApp modules, and SPA serving via server/routes/frontend.py).
It covers calls (Twilio, Hebrew), CRM (including timeline), WhatsApp, and Business management with permissions (add/update/deactivate/reactivate/delete) — all ready for deployment with logging, healthchecks, tests, and CI.

⸻

✅ FULL IMPLEMENTATION INSTRUCTIONS — Calls (Hebrew) + CRM + WhatsApp + Business Management (with Permissions) — Production-Ready

Do not change the existing server architecture.
Keep all Python modules, blueprints, and the SPA serving logic (server/routes/frontend.py).
We are adding/fixing: Twilio voice webhooks + CRM paging/search + timeline + WhatsApp stabilization + Business CRUD with permissions + auth guards + tests + CI.

⸻

0) Branch, Environment, Invariants

git checkout -b feature/full-stack-hardening
python3 -m venv .venv && source .venv/bin/activate
python -m pip install -U pip wheel
# install backend deps
pip install -r server/requirements.txt 2>/dev/null || pip install -r requirements.txt
# install frontend deps
npm ci

Do not install/remove global packages. Use .venv.
If the ZIP is wrapped in a top folder, cd into it before running.

⸻

1) Security & Auth (Sessions + Roles) — server-wide

1.1 Config & Session

In server/main.py (or wherever app is created), ensure:

import os
app.secret_key = os.getenv("SECRET_KEY", "change-me")  # use a real secret in prod
app.config.update(
    SESSION_COOKIE_SAMESITE="Lax",
    SESSION_COOKIE_SECURE=False  # True behind HTTPS/Proxy
)

1.2 Role-based permissions (decorators)

Create server/authz.py:

# server/authz.py
from functools import wraps
from flask import session, jsonify

def auth_required(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        if not session.get("user"):
            return jsonify({"error": "unauthorized"}), 401
        return fn(*args, **kwargs)
    return wrapper

def roles_required(*roles):
    def deco(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            user = session.get("user")
            if not user:
                return jsonify({"error":"unauthorized"}), 401
            if "role" not in user or user["role"] not in roles:
                return jsonify({"error":"forbidden"}), 403
            return fn(*args, **kwargs)
        return wrapper
    return deco

If you already have auth/session endpoints (e.g., /api/auth/login), keep them. Make sure the user object in the session includes { email, role } where role is one of admin | staff | viewer.
Webhooks must remain publicly accessible (no auth on /webhook/*).

⸻

2) Calls (Twilio Voice, Hebrew) — Webhooks + TwiML + Processing

Create/Update server/routes_twilio.py (or server/routes/twilio.py) and register the blueprint (section 6).

# server/routes_twilio.py
from flask import Blueprint, request, Response
from twilio.twiml.voice_response import VoiceResponse
import os, requests, io

twilio_bp = Blueprint("twilio", __name__, url_prefix="/webhook")

@twilio_bp.route("/incoming_call", methods=["POST"])
def incoming_call():
    host = os.getenv("HOST", "").rstrip("/")
    vr = VoiceResponse()
    if host:
        vr.play(f"{host}/static/voice_responses/welcome.mp3")  # optional greeting
    vr.record(
        max_length=30,       # required
        timeout=5,           # required
        finish_on_key="*",   # required
        play_beep=True,
        action="/webhook/handle_recording",
        method="POST",
        trim="do-not-trim"
    )
    return Response(str(vr), mimetype="text/xml", status=200)

@twilio_bp.route("/handle_recording", methods=["POST"])
def handle_recording():
    rec_url = request.form.get("RecordingUrl")
    if not rec_url:
        return _say("סליחה, לא קיבלתי הקלטה. איך אפשר לעזור?")
    audio_url = f"{rec_url}.mp3"
    try:
        r = requests.get(audio_url, timeout=20); r.raise_for_status()
        audio_bytes = io.BytesIO(r.content)
    except Exception:
        return _say("תקלה זמנית בהורדת ההקלטה. כיצד לעזור?")

    # === Replace these stubs with your real modules ===
    try:
        text_he = transcribe_he(audio_bytes)        # Whisper Hebrew
    except Exception:
        return _say("לא הצלחתי להבין את ההקלטה. איך לעזור?")

    try:
        reply_he = generate_reply(text_he)          # GPT/business logic
    except Exception:
        reply_he = "קיבלתי את הבקשה. לבצע כעת?"

    try:
        tts_url = synthesize_tts_he(reply_he)       # should return a public URL or None
        if tts_url:
            vr = VoiceResponse(); vr.play(tts_url)
            return Response(str(vr), mimetype="text/xml", status=200)
    except Exception:
        pass

    return _say("אוקיי. רשמתי לפני. איך עוד לעזור?")

@twilio_bp.route("/call_status", methods=["POST","GET"])
def call_status():
    return ("", 200)

def _say(text_he: str):
    vr = VoiceResponse()
    vr.say(text_he, language="he-IL")
    return Response(str(vr), mimetype="text/xml", status=200)

# === Stubs to connect to your real code (replace) ===
def transcribe_he(audio_bytes): return "שלום, מה הסטטוס?"
def generate_reply(text_he: str): return "הסטטוס: הוזמן וייצא היום."
def synthesize_tts_he(text_he: str): return None

Requirements: ensure twilio and requests are in server/requirements.txt.

Smoke tests:

curl -s -X POST http://localhost:5000/webhook/incoming_call | grep -E 'Record|maxLength="30"|timeout="5"|finishOnKey="\\*"'
curl -s -o /dev/null -w "%{http_code}\n" -X POST http://localhost:5000/webhook/call_status  # 200


⸻

3) CRM — Customers + Search/Pagination + Validations

Open your CRM module (likely server/api_crm_advanced.py). Replace any legacy customers_paginate with a single canonical endpoint:

# server/api_crm_advanced.py (or your CRM file)
from flask import Blueprint, request, jsonify
from server.authz import auth_required, roles_required
from models import db, Customer  # adapt names

crm_bp = Blueprint("crm", __name__, url_prefix="/api/crm")

@crm_bp.get("/customers")
@auth_required
def list_customers():
    try:
        page  = max(int(request.args.get("page", 1)), 1)
        limit = min(max(int(request.args.get("limit", 25)), 1), 100)
    except ValueError:
        return jsonify({"error":"invalid paging"}), 400

    q = (request.args.get("q") or "").strip()
    query = Customer.query
    if q:
        like = f"%{q}%"
        query = query.filter(
            (Customer.name.ilike(like)) |
            (Customer.phone.ilike(like)) |
            (Customer.email.ilike(like))
        )

    total = query.count()
    items = (query.order_by(Customer.created_at.desc())
                  .offset((page-1)*limit)
                  .limit(limit)
                  .all())
    return jsonify({
        "page": page,
        "limit": limit,
        "total": total,
        "items": [c.to_dict() for c in items]
    }), 200

Smoke:

curl -s "http://localhost:5000/api/crm/customers?page=1&limit=25" | head


⸻

4) CRM — Unified Timeline per Customer

Create server/api_timeline.py:

from flask import Blueprint, jsonify
from server.authz import auth_required
from models import db, CallLog, WhatsAppMsg, Task, Invoice, Contract  # adapt to your models

timeline_bp = Blueprint("timeline", __name__, url_prefix="/api/customers")

@timeline_bp.get("/<int:cid>/timeline")
@auth_required
def customer_timeline(cid):
    items = []
    items += [ {"type":"call", "at":c.created_at, "data":c.to_dict()} for c in CallLog.query.filter_by(customer_id=cid).all() ]
    items += [ {"type":"whatsapp", "at":w.created_at, "data":w.to_dict()} for w in WhatsAppMsg.query.filter_by(customer_id=cid).all() ]
    items += [ {"type":"task", "at":t.due_at, "data":t.to_dict()} for t in Task.query.filter_by(customer_id=cid).all() ]
    items += [ {"type":"invoice", "at":i.issued_at, "data":i.to_dict()} for i in Invoice.query.filter_by(customer_id=cid).all() ]
    items += [ {"type":"contract", "at":k.signed_at, "data":k.to_dict()} for k in Contract.query.filter_by(customer_id=cid).all() ]
    items.sort(key=lambda x: x["at"], reverse=True)
    return jsonify(items), 200


⸻

5) Business Management (Add/Update/Deactivate/Reactivate/Delete) — with Permissions

5.1 Model (if missing)

In your models module (e.g., server/models.py), add if absent:

from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()

class Business(db.Model):
    __tablename__ = "business"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(160), nullable=False, unique=True)
    domain = db.Column(db.String(160))
    active = db.Column(db.Boolean, default=True, index=True)
    created_at = db.Column(db.DateTime, server_default=db.func.now())

    def to_dict(self):
        return {"id": self.id, "name": self.name, "domain": self.domain, "active": self.active}

Make sure your Customer (and other entities) can reference business_id if you want per-business scoping.

5.2 API (Admin-only for destructive ops)

Create server/api_business.py:

from flask import Blueprint, request, jsonify
from server.authz import auth_required, roles_required
from models import db, Business

biz_bp = Blueprint("business", __name__, url_prefix="/api/businesses")

@biz_bp.get("")
@auth_required
def list_businesses():
    items = Business.query.order_by(Business.created_at.desc()).all()
    return jsonify([b.to_dict() for b in items]), 200

@biz_bp.post("")
@roles_required("admin")
def create_business():
    data = request.get_json(force=True)
    name = (data.get("name") or "").strip()
    if not name:
        return jsonify({"error":"name required"}), 400
    if Business.query.filter_by(name=name).first():
        return jsonify({"error":"name exists"}), 409
    b = Business(name=name, domain=(data.get("domain") or "").strip() or None)
    db.session.add(b); db.session.commit()
    return jsonify(b.to_dict()), 201

@biz_bp.put("/<int:bid>")
@roles_required("admin")
def update_business(bid):
    b = Business.query.get_or_404(bid)
    data = request.get_json(force=True)
    if "name" in data:
        new_name = (data["name"] or "").strip()
        if not new_name: return jsonify({"error":"invalid name"}), 400
        if new_name != b.name and Business.query.filter_by(name=new_name).first():
            return jsonify({"error":"name exists"}), 409
        b.name = new_name
    if "domain" in data:
        b.domain = (data["domain"] or "").strip() or None
    db.session.commit()
    return jsonify(b.to_dict()), 200

@biz_bp.post("/<int:bid>/deactivate")
@roles_required("admin")
def deactivate_business(bid):
    b = Business.query.get_or_404(bid); b.active = False; db.session.commit()
    return jsonify(b.to_dict()), 200

@biz_bp.post("/<int:bid>/reactivate")
@roles_required("admin")
def reactivate_business(bid):
    b = Business.query.get_or_404(bid); b.active = True; db.session.commit()
    return jsonify(b.to_dict()), 200

@biz_bp.delete("/<int:bid>")
@roles_required("admin")
def delete_business(bid):
    # Soft delete preferred; if you really need hard delete, ensure FK handling first.
    b = Business.query.get_or_404(bid)
    b.active = False
    db.session.commit()
    return jsonify({"ok": True}), 200

Notes
	•	Only admins can create/update/deactivate/reactivate/delete.
	•	List is available to all authenticated users.
	•	Favor soft-delete (active=False), it’s safer.
	•	If you later need strict ownership (per-business data isolation), add a business_id to users/customers and filter queries by the authenticated user’s business.

Smoke:

# (after logging in as admin)
curl -s -X POST http://localhost:5000/api/businesses -H "Content-Type: application/json" -d '{"name":"My Biz","domain":"mybiz.com"}'
curl -s http://localhost:5000/api/businesses | head
curl -s -X POST http://localhost:5000/api/businesses/1/deactivate
curl -s -X POST http://localhost:5000/api/businesses/1/reactivate
curl -s -X DELETE http://localhost:5000/api/businesses/1


⸻

6) Register Blueprints (single place)

In server/routes/__init__.py (or equivalent):

from server.routes_twilio import twilio_bp
from server.api_crm_advanced import crm_bp           # existing
from server.api_timeline import timeline_bp          # new
from server.api_business import biz_bp               # new
from server.routes.frontend import frontend_bp       # existing SPA serving
# from server.whatsapp_api import whatsapp_bp        # if you have it

def register_blueprints(app):
    app.register_blueprint(twilio_bp)     # /webhook/*
    app.register_blueprint(crm_bp)        # /api/crm/*
    app.register_blueprint(timeline_bp)   # /api/customers/:id/timeline
    app.register_blueprint(biz_bp)        # /api/businesses/*
    # app.register_blueprint(whatsapp_bp) # if present
    app.register_blueprint(frontend_bp)   # SPA/static

Ensure your app_factory.py calls register_blueprints(app).
If you don’t use app_factory, register in server/main.py after app is created.

⸻

7) WhatsApp — Stabilize

If you have server/whatsapp_api.py (or Node/Baileys service), ensure:
	•	API:
	•	POST /api/whatsapp/send → { to, text } returns { ok, id }.
	•	Webhook endpoint (Twilio/Meta) → always 200 and logs inbound messages.
	•	Persistence: store messages in WhatsAppMsg table with direction (inbound/outbound), status (queued/sent/delivered/read/failed), and customer_id if it can be resolved (phone matching).
	•	Resilience: reconnect handling / auth state persistence for Baileys; logging on failures.

(If the module exists, do not rename; add missing pieces only.)

⸻

8) Frontend SPA — Production serving (already present)

You already have SPA serving via server/routes/frontend.py.
Make sure vite.config.js has:

export default defineConfig({
  base: './',
  plugins: [react()],
  server: {
    host: '0.0.0.0',
    port: 3000,
    proxy: {
      '/api': 'http://localhost:5000',
      '/webhook': 'http://localhost:5000',
      '/socket.io': { target: 'http://localhost:5000', ws: true }
    }
  }
})

Build & serve:

npm run build      # creates dist/
# frontend blueprint serves dist in production


⸻

9) Logging, Errors, Health, Env
	•	Health:
Ensure GET /health → 200 (in your main app).
	•	Logging:
Add server/logging_setup.py with RotatingFileHandler (INFO) and call it early.
Mask secrets in logs.
	•	Errors:
Centralize error handlers (server/error_handlers.py) to return JSON for API routes.
	•	ENV:

SECRET_KEY=...
TWILIO_ACCOUNT_SID=...
TWILIO_AUTH_TOKEN=...
HOST=https://your-domain.com
OPENAI_API_KEY=...            # if using GPT
GOOGLE_APPLICATION_CREDENTIALS=/secrets/google_tts_key.json  # if using GCP TTS

Do not hardcode secrets.

⸻

10) Tests & CI

10.1 Minimal pytest (smoke)

Create server/tests/test_smoke.py:

def test_health(client):
    r = client.get("/health"); assert r.status_code == 200

def test_twilio_incoming(client):
    r = client.post("/webhook/incoming_call")
    assert r.status_code == 200
    assert b"<Record" in r.data
    assert b'maxLength="30"' in r.data
    assert b'timeout="5"' in r.data
    assert b'finishOnKey="*"' in r.data

Provide a conftest.py with a test app using your app_factory.

10.2 GitHub Actions CI — .github/workflows/ci.yml
	•	Setup Python, install server/requirements.txt, run pytest -q.
	•	Setup Node, npm ci, npm run build.

⸻

11) Final “Ready” Smoke Script (run before merging)

# Backend
cd server
source ../.venv/bin/activate || (python3 -m venv .venv && source .venv/bin/activate)
pip install -U pip wheel
pip install -r requirements.txt
python main.py  # serves API+webhooks on :5000

# Frontend
cd ..
npm ci
npm run build   # SPA build

# Health
curl -s -o /dev/null -w "%{http_code}\n" http://localhost:5000/health    # 200

# Calls (TwiML)
curl -s -X POST http://localhost:5000/webhook/incoming_call | grep -E 'Record|maxLength="30"|timeout="5"|finishOnKey="\\*"'
curl -s -o /dev/null -w "%{http_code}\n" -X POST http://localhost:5000/webhook/call_status   # 200

# CRM
curl -s "http://localhost:5000/api/crm/customers?page=1&limit=25" | head

# Timeline
curl -s "http://localhost:5000/api/customers/1/timeline" | head

# Business (requires admin role in session)
# simulate via your login endpoint or temporary override in dev
curl -s -X POST http://localhost:5000/api/businesses -H "Content-Type: application/json" -d '{"name":"My Biz","domain":"mybiz.com"}'
curl -s http://localhost:5000/api/businesses | head
curl -s -X POST http://localhost:5000/api/businesses/1/deactivate
curl -s -X POST http://localhost:5000/api/businesses/1/reactivate
curl -s -X DELETE http://localhost:5000/api/businesses/1


⸻

12) Acceptance Checklist (mark ✅)
	•	Calls (Twilio Voice)
	•	/webhook/incoming_call returns TwiML with <Record maxLength="30" timeout="5" finishOnKey="*"> (+ optional <Play>)
	•	/webhook/handle_recording returns 200 even with no RecordingUrl (Hebrew fallback)
	•	/webhook/call_status returns 200
	•	Whisper Hebrew → GPT → single TTS fallback path works
	•	CRM
	•	GET /api/crm/customers?page=1&limit=25 returns 200 with pagination/search
	•	Input validation and sane limits in place
	•	Timeline
	•	GET /api/customers/:id/timeline merges calls/whatsapp/tasks/contracts/invoices and sorts desc
	•	Business Management (with permissions)
	•	GET /api/businesses (auth)
	•	POST /api/businesses (admin) creates
	•	PUT /api/businesses/:id (admin) updates
	•	POST /api/businesses/:id/deactivate (admin) soft-deactivates
	•	POST /api/businesses/:id/reactivate (admin) reactivates
	•	DELETE /api/businesses/:id (admin) soft-deletes (or hard delete if you guaranteed FKs)
	•	WhatsApp
	•	/api/whatsapp/send works; inbound webhook logs messages; persistence for inbound/outbound
	•	Prod Readiness
	•	GET /health 200
	•	Logging + error handling in place
	•	npm run build builds the SPA, blueprint serves dist
	•	CI runs pytest + build and passes

⸻

Notes
	•	Permissions: Only admin can add/update/deactivate/reactivate/delete businesses. Viewing lists (and CRM/timeline) requires authentication (auth_required). Webhooks are open.
	•	Don’t rename or move existing server files; only add/update as instructed.
	•	Avoid caching pitfalls in the browser: if you use a Service Worker, unregister during dev.

That’s it. Follow this end-to-end and the system will be clean, powerful, and deployment-ready — Hebrew calls, CRM, WhatsApp, and Business management with proper permissions and smooth UX.