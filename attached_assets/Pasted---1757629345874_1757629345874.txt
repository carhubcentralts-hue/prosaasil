חד-משמעית כן — ההנחיה שכתבת טובה ככיוון. עכשיו אני “מהדק” אותה להוראות עבודה פרקטיות שיסגרו את כל הפינות: CSRF/SeaSurf, אימפרסונציה, שמירת פרומפט, לידים, Preview מול Deploy — כדי שהכול יעבוד, בלי כפילויות ובלי 403/Access denied.

הנחיה סופית למפתח — ליישם אחד-לאחד

0) מצב ריצה אחד (Single-Origin)
	•	Vite רק בונה, Flask מגיש את ה־FE ואת ה־API מאותו דומיין.
	•	ב־Preview וב־Deploy משתמשים באותו Run Command (בלי vite dev).
	•	בכל fetch מה־FE: credentials: 'include'.

1) SeaSurf בלבד (בלי CSRFProtect שני)
	•	השאר רק SeaSurf כמנגנון CSRF. אל תטעין ולא תייבא ספריית CSRF נוספת (כמו Flask-WTF/CSRFProtect).
	•	אתחול SeaSurf במקום מרכזי (אצלך זה server/extensions.py/app_factory.py) — פעם אחת בלבד.

2) רשימת ה־CSRF Exempt (קבועה ומצומצמת)

תבטל CSRF רק בנתיבים הבאים — ואל תחריג כלום מעבר לזה:
	•	POST /api/auth/login
	•	POST /api/auth/logout
	•	כל ה־webhooks הנכנסים: /webhook/** (Twilio, Baileys וכו’)
	•	בריאות/גרסה (GET בלבד): /healthz, /readyz, /livez, /version

כל שאר ה־POST/PUT/PATCH/DELETE חייבים CSRF!
במיוחד:
POST /api/admin/businesses/:id/impersonate (התחזות),
PUT /api/business/current/prompt / PUT /api/admin/businesses/:id/prompt,
POST /api/leads / PATCH /api/leads/:id / POST /api/leads/:id/status,
POST /api/leads/:id/reminders,
POST /api/leads/:id/message/whatsapp.

יישום נכון של Exempt
	•	אל תשים wildcard רחב. חריגה פר־נתיב בלבד.
	•	אם יש לך קוד ישן עם דקורטורים @csrf.exempt על עוד דברים — להסיר.
	•	רשימת החריגים תחיה במקום אחד (app factory) כדי שלא יזלוג.

3) מסלול הטוקן (Double-Submit) — FE ↔ BE

שרת (BE):
	•	GET /api/auth/csrf מחזיר { csrfToken } וגם מציב cookie בשם XSRF-TOKEN.
	•	Cookie flags:
	•	Deploy (דומיין אמיתי): SameSite=Lax, Secure=True, HttpOnly=True
	•	Preview (אם יש סאב־דומיין/Proxy): אם חייבים חוצת-דומיין — SameSite=None, Secure=True, HttpOnly=True.
	•	אל תחזיר סטטוס 200 בלי להציב cookie — זה העוגן של הלקוח.

לקוח (FE):
	•	מיד אחרי Login (וגם ב־App bootstrap) לקרוא GET /api/auth/csrf.
	•	ב־HTTP client: בכל כתיבה לצרף header X-CSRFToken עם הערך מה־cookie XSRF-TOKEN + credentials: 'include'.
	•	אופציונלי: X-Requested-With: fetch.

4) אימפרסונציה (בלי “דריסת” רול)
	•	ב־POST /api/admin/businesses/:id/impersonate (עם CSRF):
	•	לא משנים session.user.role.
	•	כן מוסיפים:
	•	session.impersonating = true
	•	session.impersonated_tenant_id = <id>
	•	POST /api/admin/impersonate/exit: מאפס את שני הדגלים למעלה.
	•	כל ה־guards בשרת יבדקו תמיד session.user.role לרמות הרשאה, וscope לפי tenant ייגזר מ:
	•	session.impersonated_tenant_id אם impersonating=true, אחרת session.user.tenant_id.

5) שמירת פרומפטים (שני שדות, לא “prompt” יחיד)
	•	ה־API מצפה למבנה:

{ "calls_prompt": "...", "whatsapp_prompt": "..." }


	•	ב־FE, כששומרים, שלח בדיוק את שני השדות האלה (לא {prompt: ...}), עם X-CSRFToken וכמובן credentials:'include'.
	•	בחוט השיחה (WS/WebSocket) — טעינת הפרומפט תמיד מ־DB לפי tenant_id של השיחה (נשלף מטוויליו/מספר), לא ממחרוזת קשיחה.

6) לידים — יצירה/סטטוסים/תזכורות
	•	DB: leads, lead_activities, lead_reminders (כמו שסיכמנו).
	•	API:
	•	GET /api/leads?... — נתוני העסק בלבד (או כולם אם Admin).
	•	POST /api/leads — בניה ידנית (CSRF).
	•	POST /api/leads/:id/status — עדכון סטטוס (CSRF).
	•	POST /api/leads/:id/reminders — קביעת “חזור אליי” (CSRF).
	•	POST /api/leads/:id/message/whatsapp — שליחה (CSRF) דרך Baileys/Twilio לפי health.
	•	Webhook שיחה/וואטסאפ נכנסת: upsert lead + יוצרים Activity; לא פטור מ־CSRF כי זה אינו דפדפן (webhook כבר exempt).

7) Preview מול Deploy — בלי הפתעות
	•	אותה פקודת Run בשתי הסביבות:
	1.	Build Vite → מוציא dist/
	2.	Flask מגיש את dist/ + ה־API
	•	Cache busting: תגדיל BUILD מספרי ב־index.html, ו/או Cache-Control: no-store לקבצי index.
	•	אל תכבה CSRF ב־Deploy. אם חייבים לעקוף ב־Preview לצורך דיבוג — עשה זאת רק לפי תנאי host (דגל ENV), ותשאיר פעיל ב־Deploy.

8) בדיקות עשן (חייב, כדי שלא ניפול על “מרגיש לי”)

החלף $BASE ל־URL אצלך.
Login + CSRF:

curl -i -c /tmp/c -b /tmp/c -H 'Content-Type: application/json' \
  -X POST $BASE/api/auth/login --data '{"email":"admin@...","password":"..."}'

curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf
# ודא שב-Set-Cookie אתה רואה XSRF-TOKEN, ושחוזר {"csrfToken":"..."}

Create Lead:

TOKEN=$(curl -s -c /tmp/c -b /tmp/c $BASE/api/auth/csrf | python - <<'PY'
import sys,json; print(json.load(sys.stdin)['csrfToken'])
PY
)

curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X POST $BASE/api/leads --data '{"first_name":"דן","phone_e164":"+9725...","source":"form"}'

Impersonate (Admin):

curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" \
  -X POST $BASE/api/admin/businesses/1/impersonate
curl -i -c /tmp/c -b /tmp/c $BASE/api/auth/me

Save Prompts:

curl -i -c /tmp/c -b /tmp/c -H "X-CSRFToken: $TOKEN" -H 'Content-Type: application/json' \
  -X PUT $BASE/api/business/current/prompt \
  --data '{"calls_prompt":"...","whatsapp_prompt":"..."}'

אם אחת הקריאות מחזירה 403:
	•	בדפדפן: ודא שיש cookie XSRF-TOKEN ו־header X-CSRFToken, ושהבקשה מאותו דומיין.
	•	בשרת: ודא שהנתיב לא מופיע בטעות ב־exempt, ושה־SeaSurf נטען פעם אחת.

9) ניקוי כפילויות ושאר “שאריות”
	•	הסר דקורטורי @csrf.exempt היסטוריים מכל מקום שלא ברשימת ה־exempt של סעיף 2.
	•	ודא שאין שני אתחולי CSRF (אין CSRFProtect נוסף).
	•	ודא שה־guards של RBAC קוראים רק מ־session.user.role + scope לפי impersonated_tenant_id כשצריך.
	•	אל “תתפור” פתרונות רגעיים (למשל דחיפת g.csrf_exempt=True ב־before_request) — זה שוברת האבטחה.

⸻

מה עוד לתקן עכשיו לפי המציאות אצלך
	•	Impersonating=false אחרי Login: תקין — עד שאתה לוחץ “התחזות”. אל תדרוס תפקיד; תוסיף דגלים נפרדים.
	•	“Failed to save calls prompt: {}”: נובע כמעט תמיד מאי־התאמה של JSON FE↔BE (שלח שני שדות), או מחוסר CSRF header.
	•	כפתורי “צפה בעסק/התחזות/עריכה” שלא עושים כלום: לרוב בגלל 403 מצטבר או route שגוי; פתח DevTools → Network → תראה סטטוס ושגיאה JSON (דאג שהשרת מחזיר error/message/hint).

⸻

אם תיישם את זה בדיוק, תרוויח:
	•	שמירות שעובדות (לידים/פרומפטים/סטטוסים/תזכורות).
	•	אימפרסונציה חלקה בלי לאבד הרשאות אדמין.
	•	אפס 403 “מוזרים” ואפס “Access denied” לא מוסבר.
	•	אותו התנהגות ב־Preview וב־Deploy — בלי הפתעות.

צריך שאנסח גם “טודו” קצר למעלה בקוד? אשמח.