יאללה, נסגור את זה “once and for all”.
בניתי לך הנחיה אחת, מלאה ומדויקת, שמביאה את המערכת למצב **מושלם**: Media Streams יציב (בלי 426), Fallback שעובד תמיד, וואטסאפ אינטגרלי, ו־CRM מתעד הכל. איפה שצריך—יש קטעי קוד להדבק/החלפה.

---

# A) למה אתה מקבל 426 ולמה “Extensions: \[]”

Twilio עושה WebSocket Upgrade (GET + Upgrade). אם **flask-sock** **לא נרשם** לאפליקציה (או נרשם לפני שנוצר `app`, או לא קוראים ל־`Sock(app)`/`sock.init_app(app)`), Flask לא מזהה את נתיב ה־WS → הספרייה `simple-websocket` מחזירה 426 (“Upgrade Required”) → Twilio מנתקת → “ברכה ואז שקט”.

## הפתרון (קוד קנוני, אפליקציה אחת, הרחבה אחת)

1. ודא **אפליקציה אחת** נוצרת במקום אחד (“Application Factory”), ו־Sock נרשם **אחרי** יצירת האפליקציה.
2. אל תיצור `app` כפולה בקבצים שונים.
3. אל תערבב Socket.IO עם מסלול המדיה.

### `AgentLocator/main.py` (דוגמה נקייה)

```python
# AgentLocator/main.py
from server.app_factory import create_app
app = create_app()
```

### `AgentLocator/server/app_factory.py` (רישום Sock נכון + שני נתיבי WS)

```python
import os
from flask import Flask, request, current_app
from werkzeug.middleware.proxy_fix import ProxyFix
from flask_sock import Sock

sock = Sock()  # ← יוזם פעם אחת כאן

def create_app():
    app = Flask(
        __name__,
        static_url_path="/static",
        static_folder=os.path.join(os.path.dirname(__file__), "..", "static")
    )

    # Proxy headers כדי ש-URLים מוחלטים יהיו נכון
    app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1)

    # רישום Sock אחרי יצירת app
    sock.init_app(app)
    assert "sock" in app.extensions, "Flask-Sock not registered"

    # WS routes (עם ובלי סלאש – מונע 404/Redirect בהנדשייק)
    from .media_ws import MediaStreamHandler

    @sock.route("/ws/twilio-media")
    def ws_a(ws):  # אל תעטוף בדקורטור חתימה!
        MediaStreamHandler(ws).run()

    @sock.route("/ws/twilio-media/")
    def ws_b(ws):
        MediaStreamHandler(ws).run()

    # רישום ה-webhooks וה-API
    from .routes_twilio import register_twilio_routes
    register_twilio_routes(app)

    # /healthz + /readyz
    @app.get("/healthz")
    def healthz(): return "ok", 200

    @app.get("/readyz")
    def readyz():
        out = {"status":"ready","db":"ok","openai":"ok","tts":"ok"}
        if not os.getenv("OPENAI_API_KEY"): out["openai"]="disabled"
        if not os.getenv("GOOGLE_APPLICATION_CREDENTIALS"): out["tts"]="disabled"
        return out, 200

    return app
```

> טיפ: בלוג האתחול, הדפס `list(app.extensions.keys())` ותראה שיש `sock`.

---

# B) פריסה נכונה (Replit, בלי “רוחות רפאים”)

**אין** Socket.IO בשרת המדיה. מריצים Gunicorn + **Eventlet** בלבד.

**Build**

```
pip install -r AgentLocator/requirements.txt
```

**Run**

```
python3 -m gunicorn -k eventlet -w 1 -b 0.0.0.0:$PORT AgentLocator.main:app
```

ב־`AgentLocator/requirements.txt` השאר (מינימום):

```
flask==3.*
gunicorn==21.*
eventlet==0.36.1
flask-sock==0.6.0
simple-websocket==1.0.0
twilio==9.*
openai>=1.30.0
google-cloud-texttospeech>=2.16.3
requests>=2.32.3
psycopg2-binary>=2.9
```

**אל** תתקין: `flask-socketio`, `python-socketio`, `python-engineio`, `gevent` — אלא אם רצים על פורט/אפליקציה נפרדים לדשבורד בלבד.

ENV בשני המקומות (Workspace+Deployment):
`DATABASE_URL`, `OPENAI_API_KEY`, `GOOGLE_APPLICATION_CREDENTIALS`, `TWILIO_ACCOUNT_SID`, `TWILIO_AUTH_TOKEN`, (מומלץ) `PUBLIC_BASE_URL=https://ai-crmd.replit.app`.

---

# C) TwiML נכון 100% (בלי `<Say he-IL>`, URLs מוחלטים)

טיפול בשתי תקלות שנתקלת בהן: `11100 Invalid Play URL` ו־`13512`.

```python
# AgentLocator/server/routes_twilio.py
import os, threading, time
from flask import request, current_app
from twilio.request_validator import RequestValidator
from twilio.rest import Client
from .stream_state import stream_registry  # ראה סעיף D

def abs_url(path: str) -> str:
    base = os.getenv("PUBLIC_BASE_URL") or request.url_root.rstrip("/")
    return f"{base}{path}"

def register_twilio_routes(app):
    @app.post("/webhook/incoming_call")
    def incoming_call():
        call_sid = request.form.get("CallSid")
        # Insert ראשוני ל-DB (מומלץ)
        # insert_call_log(call_sid, request.form.get("From"), request.form.get("To"), status="ringing", source="stream")

        greeting_url = abs_url("/static/tts/greeting_he.mp3")
        wss_host = (os.getenv("PUBLIC_BASE_URL") or request.url_root).replace("https://","").replace("http://","").strip("/")
        twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Play>{greeting_url}</Play>
  <Connect action="/webhook/stream_ended">
    <Stream url="wss://{wss_host}/ws/twilio-media">
      <Parameter name="call_sid" value="{call_sid}"/>
    </Stream>
  </Connect>
</Response>"""

        # מפעיל Watchdog – ראה סעיף D (לא תלוי stream_ended)
        host_for_watchdog = wss_host
        threading.Thread(target=_watchdog, args=(call_sid, host_for_watchdog), daemon=True).start()

        return twiml, 200, {"Content-Type": "text/xml"}

    @app.post("/webhook/stream_ended")
    def stream_ended():
        # update_call_log_status(call_sid, "stream_closed")
        fallback_url = abs_url("/static/tts/fallback_he.mp3")
        return f"""<Response>
  <Record playBeep="false" timeout="4" maxLength="30" transcribe="false"
          action="/webhook/handle_recording" />
  <Play>{fallback_url}</Play>
</Response>""", 200, {"Content-Type":"text/xml"}

    @app.post("/webhook/handle_recording")
    def handle_recording():
        call_sid = request.form.get("CallSid")
        rec_url  = request.form.get("RecordingUrl")
        if rec_url:
            try:
                import requests
                audio = requests.get(rec_url + ".mp3", timeout=10).content
                # text = transcribe_he(audio)  # קרא ל-Whisper שלך
                # update_call_log_transcript(call_sid, text)
            except Exception:
                current_app.logger.exception("recording_transcribe_fail")
        return "", 204

def _watchdog(call_sid, wss_host, start_timeout=8, no_media_timeout=6):
    # אם ה-WS לא התחיל/אין פריימים – redirect ל-Record תוך כדי שיחה
    time.sleep(start_timeout)
    st = stream_registry.get(call_sid)
    client = Client(os.environ["TWILIO_ACCOUNT_SID"], os.environ["TWILIO_AUTH_TOKEN"])
    if not st.get("started"):
        _do_redirect(client, call_sid, wss_host, reason="no_stream_start"); return
    if time.time() - st.get("last_media_at", 0) > no_media_timeout:
        _do_redirect(client, call_sid, wss_host, reason="no_media")

def _do_redirect(client, call_sid, wss_host, reason):
    current_app.logger.warning("WATCHDOG_REDIRECT", extra={"call_sid": call_sid, "reason": reason})
    twiml = f"""<Response>
  <Record playBeep="false" timeout="4" maxLength="30" transcribe="false"
          action="/webhook/handle_recording" />
  <Play>https://{wss_host}/static/tts/fallback_he.mp3</Play>
</Response>"""
    client.calls(call_sid).update(twiml=twiml)
```

> אין `<Say language="he-IL">`—תמיד `<Play>` ל־MP3 עברי.
> כל URL בנוי מוחלט מ־`PUBLIC_BASE_URL`/`request.url_root` — פותר `11100`.

---

# D) שמירת מצב סטרים + עדכון ב־WS (כדי ש־Watchdog ידע מה קורה)

`AgentLocator/server/stream_state.py`:

```python
import time, threading
class StreamRegistry:
    def __init__(self): self._lock=threading.Lock(); self._st={}
    def mark_start(self, call_sid):
        with self._lock: self._st.setdefault(call_sid, {})["started"]=True; self._st[call_sid]["last_media_at"]=time.time()
    def touch_media(self, call_sid):
        with self._lock: self._st.setdefault(call_sid, {})["last_media_at"]=time.time()
    def get(self, call_sid):
        with self._lock: return dict(self._st.get(call_sid, {}))
    def clear(self, call_sid):
        with self._lock: self._st.pop(call_sid, None)
stream_registry = StreamRegistry()
```

`AgentLocator/server/media_ws.py` (ליבה בלבד):

```python
import json
from flask import current_app
from .stream_state import stream_registry

class MediaStreamHandler:
    def __init__(self, websocket):
        self.ws = websocket
        self.stream_sid = None
        self.call_sid = None  # שלוף אותו מה-<Parameter> אם אתה מעביר, או מחלחל מבחוץ

    def run(self):
        current_app.logger.info("WS_CONNECTED")
        try:
            while True:
                raw = self.ws.receive()
                if raw is None:
                    current_app.logger.info("WS_CLOSED"); break
                try: data = json.loads(raw)
                except: current_app.logger.warning("WS_BAD_JSON"); continue

                ev = data.get("event")
                if ev == "start":
                    self.stream_sid = data["start"]["streamSid"]
                    current_app.logger.info("WS_START", extra={"streamSid": self.stream_sid})
                    if self.call_sid: stream_registry.mark_start(self.call_sid)

                elif ev == "media":
                    if self.call_sid: stream_registry.touch_media(self.call_sid)
                    # TODO: לצבור ולשלוח ל-STT (he), ואז NLP+TTS

                elif ev == "stop":
                    current_app.logger.info("WS_STOP"); break

        except Exception:
            current_app.logger.exception("WS_HANDLER_ERROR")
        finally:
            if self.call_sid: stream_registry.clear(self.call_sid)
```

> **אל** תשלח `mark/clear` עם `streamSid` מומצא. אם תשלח—תשלח **רק** את זה שקיבלת ב־`start`.

---

# E) WhatsApp + CRM — “מסלול זהב” אחיד

## 1) Webhook לוואטסאפ (Twilio WhatsApp)

```python
# AgentLocator/server/routes_whatsapp.py
from flask import request
from twilio.twiml.messaging_response import MessagingResponse

def register_whatsapp_routes(app):
    @app.post("/webhook/whatsapp/inbound")
    def whatsapp_inbound():
        sid  = request.form.get("MessageSid")
        from_ = request.form.get("From")       # "whatsapp:+972..."
        body  = request.form.get("Body","")

        # insert_interaction(channel="whatsapp", external_sid=sid, from_=from_, text=body, status="received")

        # NLP/DB/עסקי...
        reply = handle_whatsapp_logic(body)  # פונקציה שלך — נדל"ן וכו'
        # insert_interaction(..., status="replied", reply=reply)

        resp = MessagingResponse()
        resp.message(reply)
        return str(resp), 200
```

* ודא Twilio Sandbox/Number מקושר ל־`/webhook/whatsapp/inbound`.
* חתימת Twilio: אפשר להוסיף את אותו דקורטור אימות של ה־HTTP (לא WS).

## 2) CRM — סכמת DB מינימלית מאוחדת

מיגרציה (פשוטה, אדפטיבית—לא שוברת):

* `call_log(call_sid, from_number, to_number, status, transcript, created_at, updated_at)`
* `call_turn(id, call_sid, t_audio_ms, t_nlp_ms, t_tts_ms, t_total_ms, mode, started_at)`
* `interactions(id, channel, external_sid, from_id, to_id, text, reply_text, status, created_at)`

בכל webhook/WS:

* **INSERT** מוקדם (שיחה/הודעה התקבלה)
* **UPDATE** סטטוסים בתהליך
* **COMMIT** בכל שלב (לא לחכות לסוף)

---

# F) בדיקות קבלה (שלא תישאר “ברכה ואז שקט” לעולם)

1. **/readyz** על דומיין הדיפלוי → `{"status":"ready", ...}`.
2. **TwiML**

   ```
   curl -s https://ai-crmd.replit.app/webhook/incoming_call | sed -n '1,25p'
   ```

   רואה `<Play>https://.../static/tts/greeting_he.mp3</Play>` ואז `<Connect><Stream url="wss://ai-crmd.replit.app/ws/twilio-media">`.
3. **קבצי MP3**

   ```
   curl -I https://ai-crmd.replit.app/static/tts/greeting_he.mp3
   curl -I https://ai-crmd.replit.app/static/tts/fallback_he.mp3
   ```

   שניהם 200, `Content-Type: audio/mpeg`.
4. **WS אמיתי** (לא curl -I):
   התחבר עם websocketking.com ל־`wss://ai-crmd.replit.app/ws/twilio-media` → “Connected (101)”.
5. **שיחה אמיתית**

   * ב־Request Inspector **אין** 31920/31924.
   * אם אין `WS_START`/`WS_FRAME` תוך כמה שניות → `WATCHDOG_REDIRECT` בלוג, ו־Inspector יראה `handle_recording` → תמלול נשמר.
6. **וואטסאפ**
   שלח הודעה; webhook מחזיר 200, ב־DB נרשמה אינטראקציה, וחוזרת תשובה.

---

## TL;DR

* 426 נובע מכך ש־flask-sock **לא רשום** נכון. פתרנו עם `Sock()` גלובלי ו־`sock.init_app(app)` **אחרי** יצירת האפליקציה, ושני נתיבי WS.
* פריסה: `gunicorn -k eventlet` בלבד. בלי Socket.IO במסלול המדיה.
* TwiML: URLs מוחלטים ו־`<Play>` (לא `<Say he-IL>`).
* Watchdog: אם סטרים לא עולה → Redirect ל־`<Record>` בזמן השיחה (תמיד יש תמלול).
* וואטסאפ + CRM: webhook מסודר וטבלאות מאוחדות לרישום אירועים.

אם תדביק כאן את **`app_factory.py` ו־`routes_twilio.py`** כפי שהם עכשיו—אחזיר לך פאטצ’ים 1:1 לפי הקבצים שלך.
