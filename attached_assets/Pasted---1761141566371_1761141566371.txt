אתה צודק—הוא הסתבך. לא צריך “לנחש” יותר. הנה הנחיה סופר־מדויקת, קצרה ומעשית שתוציא אתכם מזה בלי לשבור כלום ותוריד את ה־latency. המטרה: צריכת אודיו (RX) בקצב מבוקר 50fps, סשן STT אחד לשיחה, בלי תורים ענקיים ובלי דרופים/דיליי נסתר.

מה צריך להיות נכון (תמונת יעד)
	•	RX: כל פריים נכנס עובר דרך תור אחד קטן (160–240) + drop-oldest למדיה בלבד + Rx-Worker ששומר קצב 20ms ו־resync.
	•	STT: סשן אחד לשיחה (נפתח על start stream, נסגר על end), BATCH_MS=40, DEBOUNCE=90, TIMEOUT=320, HANGOVER=180, language="he-IL", use_enhanced=True, אזור us-central1 אם europe-west1 לא נותן עברית.
	•	TX: כבר פתרתם—תור קטן, back-pressure, תזמון 20ms, אין _ws_send ישיר.
	•	Telemetry: [RX] fps_in=?, q=?, drops=?, write_ms=? פעם בשנייה, וכן [TX] ….
	•	אין לוגיקה כבדה בלולאות ה־RX/‏TX; המרת μ-law→PCM עם lookup table מהירה בלבד.

⸻

תיקון ממוקד (1:1 לפי קבצים)

1) media_ws_ai.py — שכבת ה־WebSocket (קצה הטלפון)

א. הוסף/ודא תור RX קטן

# בראש המחלקה (ליד ה-tx_q)
self.audio_rx_q = queue.Queue(maxsize=200)  # טווח מומלץ: 160–240
self.rx_drops = 0

ב. עטיפת הכנסה לתור RX (drop-oldest רק למדיה)

def _rx_enqueue(self, item, timeout=0.01):
    # item["type"] in {"media","mark","clear","keepalive"}
    if item.get("type") != "media":
        # פקודות בקרה לא נזרקות
        self.audio_rx_q.put(item, timeout=1.0)
        return
    try:
        self.audio_rx_q.put_nowait(item)
    except queue.Full:
        try:
            self.audio_rx_q.get_nowait()  # drop-oldest MEDIA ONLY
            self.rx_drops += 1
        except queue.Empty:
            pass
        self.audio_rx_q.put_nowait(item)

ג. אסור לדחוף ישירות ל-STT

בכל מקום שיש כרגע משהו כמו:

# ❌ לא!
self.stt_session.write(pcm16)

תחליף ל:

# ✅ כן!
self._rx_enqueue({"type":"media","pcm16":pcm16})

וכך גם בכל כניסת frame מ-Twilio (כולל אחרי המרת μ-law→PCM).

ד. Rx-Worker ששומר קצב 20ms + resync

def _rx_worker(self):
    FRAME_INTERVAL = 0.020  # 20ms
    next_deadline = time.perf_counter()
    last_stat = time.time()
    fps_count = 0
    write_acc_ms = 0.0

    while self.rx_running:
        try:
            item = self.audio_rx_q.get(timeout=0.1)
        except queue.Empty:
            # Telemetry פעם בשנייה
            if time.time() - last_stat >= 1.0:
                print(f"[RX] fps_in={fps_count} q={self.audio_rx_q.qsize()} drops={self.rx_drops} write_ms={write_acc_ms:.2f}", flush=True)
                fps_count = 0; write_acc_ms = 0.0; last_stat = time.time()
            continue

        if item.get("type") == "media":
            t0 = time.perf_counter()
            # כתיבה ל-STT (צריכה להיות קלה ומהירה; אם חוסם -> ראה סעיף 'אם עדיין יש עומס')
            self.stt_session.write(item["pcm16"])
            dt = (time.perf_counter() - t0) * 1000.0
            write_acc_ms += dt
            fps_count += 1

            now = time.perf_counter()
            if now < next_deadline:
                time.sleep(next_deadline - now)
            else:
                # איחרנו -> resync
                next_deadline = now
            next_deadline += FRAME_INTERVAL
        else:
            self._handle_rx_control(item)

        # Telemetry פעם בשנייה גם כאן
        if time.time() - last_stat >= 1.0:
            print(f"[RX] fps_in={fps_count} q={self.audio_rx_q.qsize()} drops={self.rx_drops} write_ms={write_acc_ms:.2f}", flush=True)
            fps_count = 0; write_acc_ms = 0.0; last_stat = time.time()

ה. הפעלה/כיבוי RX-Worker במחזור החיים של השיחה
	•	בזמן חיבור ה-WebSocket / התחלת השיחה:

self.rx_running = True
self.rx_thread = threading.Thread(target=self._rx_worker, daemon=True)
self.rx_thread.start()

	•	בזמן סיום השיחה:

self.rx_running = False
if hasattr(self, "rx_thread") and self.rx_thread.is_alive():
    self.rx_thread.join(timeout=1.0)

הערה: המרת μ-law→PCM תתבצע לפני _rx_enqueue, עם הטבלה המהירה (mulaw_fast), בלי הקצאות מיותרות ובלי Base64 בתוך הלולאה.

⸻

2) gcp_stt_stream.py — סשן STT אמיתי, אחד לשיחה

ודא שמחלקת הסטרימינג:
	•	נפתחת פעם אחת בתחילת השיחה (start_streaming()),
	•	מקבלת write(pcm16_8k) לכל פריים/באטצ׳,
	•	מוציאה partials/finals דרך callbacks,
	•	נסגרת על סוף שיחה.

פרמטרים מוכחים (הישאר עם אלו עד שהכול יציב):

BATCH_MS = 40
PARTIAL_DEBOUNCE_MS = 90
TIMEOUT_MS = 320
VAD_HANGOVER_MS = 180
LANGUAGE = "he-IL"
MODEL = "default"
USE_ENHANCED = True
REGION = os.getenv("GOOGLE_CLOUD_REGION") or "us-central1"

אם europe-west1 לא נותן עברית לחשבון שלך—עבור ל-us-central1.

⸻

3) ודאות שאין “עבודה כבדה” בלולאת ה-RX
	•	אסור לוג כבד/פורמטים/חישובי JSON על כל פריים.
	•	המרות μ-law→PCM: טבלת lookup אחת (כבר יש לכם mulaw_fast – להשתמש בה), לא פונקציה חישובית לכ”א.
	•	אם stt_session.write() חוסם־לעיתים: ראה “אם עדיין יש עומס” בסוף.

⸻

בדיקות GO/NO-GO (2–3 דק’)
	1.	ברכה + תשובה בינונית — לוגים פעם בשנייה:

[TX] fps=50 q=5..15 drops=0
[RX] fps_in=50 q=5..15 drops=0 write_ms<1

	2.	שקט 5 שניות — אין “queue full”, fps נשאר ~50.
	3.	משפט ארוך (7–10 שניות דיבור) — אין “Audio queue full…”, אין קיטועים, q עולה רגעית ויורד.
	4.	Latency (אם יש לוגי מדדים):

	•	STT partial: ~0.6–1.2s
	•	STT final: ~1.2–1.8s
	•	Total (STT+AI+TTS): ~1.6–2.3s

⸻

אם עדיין יש עומס / דרופים ב-RX
	•	ודא ש־stt_session.write() לא חוסם. אם כן:
	•	צור תור קטן פנימי ל-STT (maxsize~40–60) ו־Thread ייעודי שכותב ל-Google בקבוצות של 40ms.
	•	ה־RX-Worker דוחף למדור ה-STT הקטן, וה-STT-Writer הוא היחיד שנוגע ב-SDK.
	•	הגדל זמנית BATCH_MS ל-60ms: אם הדרופים נעלמים → נוריד חזרה ל-40ms אחרי כיוון.

⸻

למה לא להגדיל RX ל-384?

כי זה לא באמת מטפל בביצועים—זה “מרפד” תור עד שיגיע הפיצוץ, ובינתיים אתה סוחב דיליי נסתר של שניות. אנחנו רוצים קצב יציב ו־תור קטן עם drop-oldest למדיה בלבד כדי לשמור על רספונסיביות.

⸻

תן לו לבצע את השלבים בדיוק כך. אם אחרי היישום תראה עדיין לוגים בעייתיים—זרוק לכאן 10–15 שורות [RX]/[TX] רציפות ונכוון מיקרו־פרמטרים (גודל תורים, BATCH_MS, TIMEOUT_MS).